[
    {
        "index": 554,
        "cve_id": "CVE-2014-0131",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the skb_segment function in net/core/skbuff.c in the Linux kernel through 3.13.6 allows attackers to obtain sensitive information from kernel memory by leveraging the absence of a certain orphaning operation.",
        "cvss": "3.1",
        "publish_date": "March 24, 2014",
        "AV": "ADJACENT_NETWORK",
        "AC": "ADJACENT_NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "LOW",
        "I": "NONE",
        "A": "NONE",
        "commit_id": "1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "commit_message": "skbuff: skb_segment: orphan frags before copying\n\nskb_segment copies frags around, so we need\nto copy them carefully to avoid accessing\nuser memory after reporting completion to userspace\nthrough a callback.\n\nskb_segment doesn't normally happen on datapath:\nTSO needs to be disabled - so disabling zero copy\nin this case does not look like a big deal.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nAcked-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2014-03-11T20:26:38Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "html_url": "https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "parents": [
            {
                "commit_id_before": "1a4cedaf65491e66e1e55b8428c89209da729209",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/1a4cedaf65491e66e1e55b8428c89209da729209",
                "html_url_before": "https://github.com/torvalds/linux/commit/1a4cedaf65491e66e1e55b8428c89209da729209"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/core/skbuff.c"
    },
    {
        "index": 611,
        "cve_id": "CVE-2014-0203",
        "cwe_id": [
            "CWE-20",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The __do_follow_link function in fs/namei.c in the Linux kernel before 2.6.33 does not properly handle the last pathname component during use of certain filesystems, which allows local users to cause a denial of service (incorrect free operations and system crash) via an open system call.",
        "cvss": "5.5",
        "publish_date": "June 23, 2014",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "86acdca1b63e6890540fa19495cfc708beff3d8b",
        "commit_message": "fix autofs/afs/etc. magic mountpoint breakage\n\nWe end up trying to kfree() nd.last.name on open(\"/mnt/tmp\", O_CREAT)\nif /mnt/tmp is an autofs direct mount.  The reason is that nd.last_type\nis bogus here; we want LAST_BIND for everything of that kind and we\nget LAST_NORM left over from finding parent directory.\n\nSo make sure that it *is* set properly; set to LAST_BIND before\ndoing ->follow_link() - for normal symlinks it will be changed\nby __vfs_follow_link() and everything else needs it set that way.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "commit_date": "2010-01-14T14:05:25Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/86acdca1b63e6890540fa19495cfc708beff3d8b",
        "html_url": "https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b",
        "parents": [
            {
                "commit_id_before": "004b35063296b6772fa72404a35b498f1e71e87e",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/004b35063296b6772fa72404a35b498f1e71e87e",
                "html_url_before": "https://github.com/torvalds/linux/commit/004b35063296b6772fa72404a35b498f1e71e87e"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "fs/namei.c"
    },
    {
        "index": 665,
        "cve_id": "CVE-2014-4653",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not ensure possession of a read/write lock, which allows local users to cause a denial of service (use-after-free) and obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access.",
        "cvss": "5.9",
        "publish_date": "July 2, 2014",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "LOW",
        "I": "LOW",
        "A": "LOW",
        "commit_id": "fd9f26e4eca5d08a27d12c0933fceef76ed9663d",
        "commit_message": "ALSA: control: Don't access controls outside of protected regions\n\nA control that is visible on the card->controls list can be freed at any time.\nThis means we must not access any of its memory while not holding the\ncontrols_rw_lock. Otherwise we risk a use after free access.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2014-06-18T13:13:07Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/fd9f26e4eca5d08a27d12c0933fceef76ed9663d",
        "html_url": "https://github.com/torvalds/linux/commit/fd9f26e4eca5d08a27d12c0933fceef76ed9663d",
        "parents": [
            {
                "commit_id_before": "82262a46627bebb0febcc26664746c25cef08563",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/82262a46627bebb0febcc26664746c25cef08563",
                "html_url_before": "https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "sound/core/control.c"
    },
    {
        "index": 666,
        "cve_id": "CVE-2014-4654",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The snd_ctl_elem_add function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not check authorization for SNDRV_CTL_IOCTL_ELEM_REPLACE commands, which allows local users to remove kernel controls and cause a denial of service (use-after-free and system crash) by leveraging /dev/snd/controlCX access for an ioctl call.",
        "cvss": "5.9",
        "publish_date": "July 2, 2014",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "LOW",
        "I": "LOW",
        "A": "LOW",
        "commit_id": "82262a46627bebb0febcc26664746c25cef08563",
        "commit_message": "ALSA: control: Fix replacing user controls\n\nThere are two issues with the current implementation for replacing user\ncontrols. The first is that the code does not check if the control is actually a\nuser control and neither does it check if the control is owned by the process\nthat tries to remove it. That allows userspace applications to remove arbitrary\ncontrols, which can cause a user after free if a for example a driver does not\nexpect a control to be removed from under its feed.\n\nThe second issue is that on one hand when a control is replaced the\nuser_ctl_count limit is not checked and on the other hand the user_ctl_count is\nincreased (even though the number of user controls does not change). This allows\nuserspace, once the user_ctl_count limit as been reached, to repeatedly replace\na control until user_ctl_count overflows. Once that happens new controls can be\nadded effectively bypassing the user_ctl_count limit.\n\nBoth issues can be fixed by instead of open-coding the removal of the control\nthat is to be replaced to use snd_ctl_remove_user_ctl(). This function does\nproper permission checks as well as decrements user_ctl_count after the control\nhas been removed.\n\nNote that by using snd_ctl_remove_user_ctl() the check which returns -EBUSY at\nbeginning of the function if the control already exists is removed. This is not\na problem though since the check is quite useless, because the lock that is\nprotecting the control list is released between the check and before adding the\nnew control to the list, which means that it is possible that a different\ncontrol with the same settings is added to the list after the check. Luckily\nthere is another check that is done while holding the lock in snd_ctl_add(), so\nwe'll rely on that to make sure that the same control is not added twice.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2014-06-18T13:12:49Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/82262a46627bebb0febcc26664746c25cef08563",
        "html_url": "https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563",
        "parents": [
            {
                "commit_id_before": "07f4d9d74a04aa7c72c5dae0ef97565f28f17b92",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92",
                "html_url_before": "https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "sound/core/control.c"
    },
    {
        "index": 1597,
        "cve_id": "CVE-2014-9914",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the ip4_datagram_release_cb function in net/ipv4/datagram.c in the Linux kernel before 3.15.2 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect expectations about locking during multithreaded access to internal data structures for IPv4 UDP sockets.",
        "cvss": "7.8",
        "publish_date": "February 7, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "9709674e68646cee5a24e3000b3558d25412203a",
        "commit_message": "ipv4: fix a race in ip4_datagram_release_cb()\n\nAlexey gave a AddressSanitizer[1] report that finally gave a good hint\nat where was the origin of various problems already reported by Dormando\nin the past [2]\n\nProblem comes from the fact that UDP can have a lockless TX path, and\nconcurrent threads can manipulate sk_dst_cache, while another thread,\nis holding socket lock and calls __sk_dst_set() in\nip4_datagram_release_cb() (this was added in linux-3.8)\n\nIt seems that all we need to do is to use sk_dst_check() and\nsk_dst_set() so that all the writers hold same spinlock\n(sk->sk_dst_lock) to prevent corruptions.\n\nTCP stack do not need this protection, as all sk_dst_cache writers hold\nthe socket lock.\n\n[1]\nhttps://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernel\n\nAddressSanitizer: heap-use-after-free in ipv4_dst_check\nRead of size 2 by thread T15453:\n [<ffffffff817daa3a>] ipv4_dst_check+0x1a/0x90 ./net/ipv4/route.c:1116\n [<ffffffff8175b789>] __sk_dst_check+0x89/0xe0 ./net/core/sock.c:531\n [<ffffffff81830a36>] ip4_datagram_release_cb+0x46/0x390 ??:0\n [<ffffffff8175eaea>] release_sock+0x17a/0x230 ./net/core/sock.c:2413\n [<ffffffff81830882>] ip4_datagram_connect+0x462/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\nFreed by thread T15455:\n [<ffffffff8178d9b8>] dst_destroy+0xa8/0x160 ./net/core/dst.c:251\n [<ffffffff8178de25>] dst_release+0x45/0x80 ./net/core/dst.c:280\n [<ffffffff818304c1>] ip4_datagram_connect+0xa1/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\nAllocated by thread T15453:\n [<ffffffff8178d291>] dst_alloc+0x81/0x2b0 ./net/core/dst.c:171\n [<ffffffff817db3b7>] rt_dst_alloc+0x47/0x50 ./net/ipv4/route.c:1406\n [<     inlined    >] __ip_route_output_key+0x3e8/0xf70\n__mkroute_output ./net/ipv4/route.c:1939\n [<ffffffff817dde08>] __ip_route_output_key+0x3e8/0xf70 ./net/ipv4/route.c:2161\n [<ffffffff817deb34>] ip_route_output_flow+0x14/0x30 ./net/ipv4/route.c:2249\n [<ffffffff81830737>] ip4_datagram_connect+0x317/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\n[2]\n<4>[196727.311203] general protection fault: 0000 [#1] SMP\n<4>[196727.311224] Modules linked in: xt_TEE xt_dscp xt_DSCP macvlan bridge coretemp crc32_pclmul ghash_clmulni_intel gpio_ich microcode ipmi_watchdog ipmi_devintf sb_edac edac_core lpc_ich mfd_core tpm_tis tpm tpm_bios ipmi_si ipmi_msghandler isci igb libsas i2c_algo_bit ixgbe ptp pps_core mdio\n<4>[196727.311333] CPU: 17 PID: 0 Comm: swapper/17 Not tainted 3.10.26 #1\n<4>[196727.311344] Hardware name: Supermicro X9DRi-LN4+/X9DR3-LN4+/X9DRi-LN4+/X9DR3-LN4+, BIOS 3.0 07/05/2013\n<4>[196727.311364] task: ffff885e6f069700 ti: ffff885e6f072000 task.ti: ffff885e6f072000\n<4>[196727.311377] RIP: 0010:[<ffffffff815f8c7f>]  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80\n<4>[196727.311399] RSP: 0018:ffff885effd23a70  EFLAGS: 00010282\n<4>[196727.311409] RAX: dead000000200200 RBX: ffff8854c398ecc0 RCX: 0000000000000040\n<4>[196727.311423] RDX: dead000000100100 RSI: dead000000100100 RDI: dead000000200200\n<4>[196727.311437] RBP: ffff885effd23a80 R08: ffffffff815fd9e0 R09: ffff885d5a590800\n<4>[196727.311451] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\n<4>[196727.311464] R13: ffffffff81c8c280 R14: 0000000000000000 R15: ffff880e85ee16ce\n<4>[196727.311510] FS:  0000000000000000(0000) GS:ffff885effd20000(0000) knlGS:0000000000000000\n<4>[196727.311554] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n<4>[196727.311581] CR2: 00007a46751eb000 CR3: 0000005e65688000 CR4: 00000000000407e0\n<4>[196727.311625] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n<4>[196727.311669] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n<4>[196727.311713] Stack:\n<4>[196727.311733]  ffff8854c398ecc0 ffff8854c398ecc0 ffff885effd23ab0 ffffffff815b7f42\n<4>[196727.311784]  ffff88be6595bc00 ffff8854c398ecc0 0000000000000000 ffff8854c398ecc0\n<4>[196727.311834]  ffff885effd23ad0 ffffffff815b86c6 ffff885d5a590800 ffff8816827821c0\n<4>[196727.311885] Call Trace:\n<4>[196727.311907]  <IRQ>\n<4>[196727.311912]  [<ffffffff815b7f42>] dst_destroy+0x32/0xe0\n<4>[196727.311959]  [<ffffffff815b86c6>] dst_release+0x56/0x80\n<4>[196727.311986]  [<ffffffff81620bd5>] tcp_v4_do_rcv+0x2a5/0x4a0\n<4>[196727.312013]  [<ffffffff81622b5a>] tcp_v4_rcv+0x7da/0x820\n<4>[196727.312041]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360\n<4>[196727.312070]  [<ffffffff815de02d>] ? nf_hook_slow+0x7d/0x150\n<4>[196727.312097]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360\n<4>[196727.312125]  [<ffffffff815fda92>] ip_local_deliver_finish+0xb2/0x230\n<4>[196727.312154]  [<ffffffff815fdd9a>] ip_local_deliver+0x4a/0x90\n<4>[196727.312183]  [<ffffffff815fd799>] ip_rcv_finish+0x119/0x360\n<4>[196727.312212]  [<ffffffff815fe00b>] ip_rcv+0x22b/0x340\n<4>[196727.312242]  [<ffffffffa0339680>] ? macvlan_broadcast+0x160/0x160 [macvlan]\n<4>[196727.312275]  [<ffffffff815b0c62>] __netif_receive_skb_core+0x512/0x640\n<4>[196727.312308]  [<ffffffff811427fb>] ? kmem_cache_alloc+0x13b/0x150\n<4>[196727.312338]  [<ffffffff815b0db1>] __netif_receive_skb+0x21/0x70\n<4>[196727.312368]  [<ffffffff815b0fa1>] netif_receive_skb+0x31/0xa0\n<4>[196727.312397]  [<ffffffff815b1ae8>] napi_gro_receive+0xe8/0x140\n<4>[196727.312433]  [<ffffffffa00274f1>] ixgbe_poll+0x551/0x11f0 [ixgbe]\n<4>[196727.312463]  [<ffffffff815fe00b>] ? ip_rcv+0x22b/0x340\n<4>[196727.312491]  [<ffffffff815b1691>] net_rx_action+0x111/0x210\n<4>[196727.312521]  [<ffffffff815b0db1>] ? __netif_receive_skb+0x21/0x70\n<4>[196727.312552]  [<ffffffff810519d0>] __do_softirq+0xd0/0x270\n<4>[196727.312583]  [<ffffffff816cef3c>] call_softirq+0x1c/0x30\n<4>[196727.312613]  [<ffffffff81004205>] do_softirq+0x55/0x90\n<4>[196727.312640]  [<ffffffff81051c85>] irq_exit+0x55/0x60\n<4>[196727.312668]  [<ffffffff816cf5c3>] do_IRQ+0x63/0xe0\n<4>[196727.312696]  [<ffffffff816c5aaa>] common_interrupt+0x6a/0x6a\n<4>[196727.312722]  <EOI>\n<1>[196727.313071] RIP  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80\n<4>[196727.313100]  RSP <ffff885effd23a70>\n<4>[196727.313377] ---[ end trace 64b3f14fae0f2e29 ]---\n<0>[196727.380908] Kernel panic - not syncing: Fatal exception in interrupt\n\nReported-by: Alexey Preobrazhensky <preobr@google.com>\nReported-by: dormando <dormando@rydia.ne>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nFixes: 8141ed9fcedb2 (\"ipv4: Add a socket release callback for datagram sockets\")\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2014-06-11T22:39:18Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/9709674e68646cee5a24e3000b3558d25412203a",
        "html_url": "https://github.com/torvalds/linux/commit/9709674e68646cee5a24e3000b3558d25412203a",
        "parents": [
            {
                "commit_id_before": "a101ccd141fa777febc510a5c3f3da0c23cd47ce",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/a101ccd141fa777febc510a5c3f3da0c23cd47ce",
                "html_url_before": "https://github.com/torvalds/linux/commit/a101ccd141fa777febc510a5c3f3da0c23cd47ce"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/ipv4/datagram.c"
    },
    {
        "index": 2060,
        "cve_id": "CVE-2014-9940",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The regulator_ena_gpio_free function in drivers/regulator/core.c in the Linux kernel before 3.19 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted application.",
        "cvss": "7.0",
        "publish_date": "May 2, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "commit_message": "regulator: core: Fix regualtor_ena_gpio_free not to access pin after freeing\n\nAfter freeing pin from regulator_ena_gpio_free, loop can access\nthe pin. So this patch fixes not to access pin after freeing.\n\nSigned-off-by: Seung-Woo Kim <sw0312.kim@samsung.com>\nSigned-off-by: Mark Brown <broonie@kernel.org>",
        "commit_date": "2014-12-04T22:45:36Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "html_url": "https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "parents": [
            {
                "commit_id_before": "194dbaefa0da24bb60d9df1c99dda807f51fc33f",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/194dbaefa0da24bb60d9df1c99dda807f51fc33f",
                "html_url_before": "https://github.com/torvalds/linux/commit/194dbaefa0da24bb60d9df1c99dda807f51fc33f"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/regulator/core.c"
    },
    {
        "index": 921,
        "cve_id": "CVE-2015-5706",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the path_openat function in fs/namei.c in the Linux kernel 3.x and 4.x before 4.0.4 allows local users to cause a denial of service or possibly have unspecified other impact via O_TMPFILE filesystem operations that leverage a duplicate cleanup operation.",
        "cvss": "5.3",
        "publish_date": "August 31, 2015",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "LOW",
        "commit_id": "f15133df088ecadd141ea1907f2c96df67c729f0",
        "commit_message": "path_openat(): fix double fput()\n\npath_openat() jumps to the wrong place after do_tmpfile() - it has\nalready done path_cleanup() (as part of path_lookupat() called by\ndo_tmpfile()), so doing that again can lead to double fput().\n\nCc: stable@vger.kernel.org\t# v3.11+\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "commit_date": "2015-05-09T04:12:48Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/f15133df088ecadd141ea1907f2c96df67c729f0",
        "html_url": "https://github.com/torvalds/linux/commit/f15133df088ecadd141ea1907f2c96df67c729f0",
        "parents": [
            {
                "commit_id_before": "766c4cbfacd8634d7580bac6a1b8456e63de3e84",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/766c4cbfacd8634d7580bac6a1b8456e63de3e84",
                "html_url_before": "https://github.com/torvalds/linux/commit/766c4cbfacd8634d7580bac6a1b8456e63de3e84"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "fs/namei.c"
    },
    {
        "index": 1385,
        "cve_id": "CVE-2015-8961",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The __ext4_journal_stop function in fs/ext4/ext4_jbd2.c in the Linux kernel before 4.3.3 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging improper access to a certain error field.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "6934da9238da947628be83635e365df41064b09b",
        "commit_message": "ext4: fix potential use after free in __ext4_journal_stop\n\nThere is a use-after-free possibility in __ext4_journal_stop() in the\ncase that we free the handle in the first jbd2_journal_stop() because\nwe're referencing handle->h_err afterwards. This was introduced in\n9705acd63b125dee8b15c705216d7186daea4625 and it is wrong. Fix it by\nstoring the handle->h_err value beforehand and avoid referencing\npotentially freed handle.\n\nFixes: 9705acd63b125dee8b15c705216d7186daea4625\nSigned-off-by: Lukas Czerner <lczerner@redhat.com>\nReviewed-by: Andreas Dilger <adilger@dilger.ca>\nCc: stable@vger.kernel.org",
        "commit_date": "2015-10-18T02:57:06Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/6934da9238da947628be83635e365df41064b09b",
        "html_url": "https://github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b",
        "parents": [
            {
                "commit_id_before": "33d14975e5ac469963d5d63856b61698ad0bff07",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/33d14975e5ac469963d5d63856b61698ad0bff07",
                "html_url_before": "https://github.com/torvalds/linux/commit/33d14975e5ac469963d5d63856b61698ad0bff07"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "fs/ext4/ext4_jbd2.c"
    },
    {
        "index": 1384,
        "cve_id": "CVE-2015-8963",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in kernel/events/core.c in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect handling of an swevent data structure during a CPU unplug operation.",
        "cvss": "7.0",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "12ca6ad2e3a896256f086497a7c7406a547ee373",
        "commit_message": "perf: Fix race in swevent hash\n\nThere's a race on CPU unplug where we free the swevent hash array\nwhile it can still have events on. This will result in a\nuse-after-free which is BAD.\n\nSimply do not free the hash array on unplug. This leaves the thing\naround and no use-after-free takes place.\n\nWhen the last swevent dies, we do a for_each_possible_cpu() iteration\nanyway to clean these up, at which time we'll free it, so no leakage\nwill occur.\n\nReported-by: Sasha Levin <sasha.levin@oracle.com>\nTested-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "commit_date": "2016-01-06T09:52:39Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/12ca6ad2e3a896256f086497a7c7406a547ee373",
        "html_url": "https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373",
        "parents": [
            {
                "commit_id_before": "c127449944659543e5e2423002f08f0af98dba5c",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c127449944659543e5e2423002f08f0af98dba5c",
                "html_url_before": "https://github.com/torvalds/linux/commit/c127449944659543e5e2423002f08f0af98dba5c"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "kernel/events/core.c"
    },
    {
        "index": 1408,
        "cve_id": "CVE-2016-10088",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The sg implementation in the Linux kernel through 4.9 does not properly restrict write operations in situations where the KERNEL_DS option is set, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device, related to block/bsg.c and drivers/scsi/sg.c.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-9576.",
        "cvss": "7.0",
        "publish_date": "December 30, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "128394eff343fc6d2f32172f03e24829539c5835",
        "commit_message": "sg_write()/bsg_write() is not fit to be called under KERNEL_DS\n\nBoth damn things interpret userland pointers embedded into the payload;\nworse, they are actually traversing those.  Leaving aside the bad\nAPI design, this is very much _not_ safe to call with KERNEL_DS.\nBail out early if that happens.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "commit_date": "2016-12-23T04:03:42Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/128394eff343fc6d2f32172f03e24829539c5835",
        "html_url": "https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835",
        "parents": [
            {
                "commit_id_before": "f698cccbc89e33cda4795a375e47daaa3689485e",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f698cccbc89e33cda4795a375e47daaa3689485e",
                "html_url_before": "https://github.com/torvalds/linux/commit/f698cccbc89e33cda4795a375e47daaa3689485e"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "block/bsg.c"
    },
    {
        "index": 1615,
        "cve_id": "CVE-2016-10150",
        "cwe_id": [
            "CWE-264",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the kvm_ioctl_create_device function in virt/kvm/kvm_main.c in the Linux kernel before 4.8.13 allows host OS users to cause a denial of service (host OS crash) or possibly gain privileges via crafted ioctl calls on the /dev/kvm device.",
        "cvss": "9.8",
        "publish_date": "February 6, 2017",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "commit_message": "KVM: use after free in kvm_ioctl_create_device()\n\nWe should move the ops->destroy(dev) after the list_del(&dev->vm_node)\nso that we don't use \"dev\" after freeing it.\n\nFixes: a28ebea2adc4 (\"KVM: Protect device ops->create and list_add with kvm->lock\")\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: David Hildenbrand <david@redhat.com>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
        "commit_date": "2016-12-01T15:10:50Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "html_url": "https://github.com/torvalds/linux/commit/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "parents": [
            {
                "commit_id_before": "0f4828a1da3342be81e812b28fbcf29261146d25",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/0f4828a1da3342be81e812b28fbcf29261146d25",
                "html_url_before": "https://github.com/torvalds/linux/commit/0f4828a1da3342be81e812b28fbcf29261146d25"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "virt/kvm/kvm_main.c"
    },
    {
        "index": 1819,
        "cve_id": "CVE-2016-10200",
        "cwe_id": [
            "CWE-362",
            "CWE-264",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.",
        "cvss": "7.0",
        "publish_date": "March 7, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "32c231164b762dddefa13af5a0101032c70b50ef",
        "commit_message": "l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()\n\nLock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().\nWithout lock, a concurrent call could modify the socket flags between\nthe sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,\na socket could be inserted twice in l2tp_ip6_bind_table. Releasing it\nwould then leave a stale pointer there, generating use-after-free\nerrors when walking through the list or modifying adjacent entries.\n\nBUG: KASAN: use-after-free in l2tp_ip6_close+0x22e/0x290 at addr ffff8800081b0ed8\nWrite of size 8 by task syz-executor/10987\nCPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014\n ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0\n ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc\n ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0\nCall Trace:\n [<ffffffff829f835b>] dump_stack+0xb3/0x118 lib/dump_stack.c:15\n [<ffffffff8174d3cc>] kasan_object_err+0x1c/0x70 mm/kasan/report.c:156\n [<     inline     >] print_address_description mm/kasan/report.c:194\n [<ffffffff8174d666>] kasan_report_error+0x1f6/0x4d0 mm/kasan/report.c:283\n [<     inline     >] kasan_report mm/kasan/report.c:303\n [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e/0x40 mm/kasan/report.c:329\n [<     inline     >] __write_once_size ./include/linux/compiler.h:249\n [<     inline     >] __hlist_del ./include/linux/list.h:622\n [<     inline     >] hlist_del_init ./include/linux/list.h:637\n [<ffffffff8579047e>] l2tp_ip6_close+0x22e/0x290 net/l2tp/l2tp_ip6.c:239\n [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415\n [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422\n [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570\n [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017\n [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208\n [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244\n [<ffffffff813774f9>] task_work_run+0xf9/0x170\n [<ffffffff81324aae>] do_exit+0x85e/0x2a00\n [<ffffffff81326dc8>] do_group_exit+0x108/0x330\n [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307\n [<ffffffff811b49af>] do_signal+0x7f/0x18f0\n [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156\n [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190\n [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259\n [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6\nObject at ffff8800081b0ec0, in cache L2TP/IPv6 size: 1448\nAllocated:\nPID = 10987\n [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20\n [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0\n [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad/0xe0\n [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12/0x20\n [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm/slab.h:417\n [ 1116.897025] [<     inline     >] slab_alloc_node mm/slub.c:2708\n [ 1116.897025] [<     inline     >] slab_alloc mm/slub.c:2716\n [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8/0x2b0 mm/slub.c:2721\n [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69/0x2b0 net/core/sock.c:1326\n [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38/0xae0 net/core/sock.c:1388\n [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7/0x1000 net/ipv6/af_inet6.c:182\n [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b/0x640 net/socket.c:1153\n [ 1116.897025] [<     inline     >] sock_create net/socket.c:1193\n [ 1116.897025] [<     inline     >] SYSC_socket net/socket.c:1223\n [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef/0x1b0 net/socket.c:1203\n [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23/0xc6\nFreed:\nPID = 10987\n [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20\n [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0\n [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71/0xb0\n [ 1116.897025] [<     inline     >] slab_free_hook mm/slub.c:1352\n [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm/slub.c:1374\n [ 1116.897025] [<     inline     >] slab_free mm/slub.c:2951\n [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8/0x330 mm/slub.c:2973\n [ 1116.897025] [<     inline     >] sk_prot_free net/core/sock.c:1369\n [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b/0x4f0 net/core/sock.c:1444\n [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44/0x80 net/core/sock.c:1452\n [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53/0x220 net/core/sock.c:1460\n [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23/0x30 net/core/sock.c:1471\n [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c/0x3e0 ./include/net/sock.h:1589\n [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe/0x290 net/l2tp/l2tp_ip6.c:243\n [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415\n [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422\n [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570\n [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017\n [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208\n [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244\n [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9/0x170\n [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e/0x2a00\n [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108/0x330\n [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307\n [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f/0x18f0\n [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156\n [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190\n [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259\n [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6\nMemory state around the buggy address:\n ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb\n                                                    ^\n ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\n==================================================================\n\nThe same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.\n\nFixes: c51ce49735c1 (\"l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case\")\nReported-by: Baozeng Ding <sploving1@gmail.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Baozeng Ding <sploving1@gmail.com>\nSigned-off-by: Guillaume Nault <g.nault@alphalink.fr>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2016-11-20T03:09:21Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/32c231164b762dddefa13af5a0101032c70b50ef",
        "html_url": "https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef",
        "parents": [
            {
                "commit_id_before": "adda306744ec64c7bcd6c230a6bc060fb77bd7c3",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/adda306744ec64c7bcd6c230a6bc060fb77bd7c3",
                "html_url_before": "https://github.com/torvalds/linux/commit/adda306744ec64c7bcd6c230a6bc060fb77bd7c3"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/l2tp/l2tp_ip.c"
    },
    {
        "index": 1258,
        "cve_id": "CVE-2016-3841",
        "cwe_id": [
            "CWE-264",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call.",
        "cvss": "7.3",
        "publish_date": "August 6, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "45f6fad84cc305103b28d73482b344d7f5b76f39",
        "commit_message": "ipv6: add complete rcu protection around np->opt\n\nThis patch addresses multiple problems :\n\nUDP/RAW sendmsg() need to get a stable struct ipv6_txoptions\nwhile socket is not locked : Other threads can change np->opt\nconcurrently. Dmitry posted a syzkaller\n(http://github.com/google/syzkaller) program desmonstrating\nuse-after-free.\n\nStarting with TCP/DCCP lockless listeners, tcp_v6_syn_recv_sock()\nand dccp_v6_request_recv_sock() also need to use RCU protection\nto dereference np->opt once (before calling ipv6_dup_options())\n\nThis patch adds full RCU protection to np->opt\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2015-12-03T04:37:16Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/45f6fad84cc305103b28d73482b344d7f5b76f39",
        "html_url": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39",
        "parents": [
            {
                "commit_id_before": "01b3f52157ff5a47d6d8d796f396a4b34a53c61d",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/01b3f52157ff5a47d6d8d796f396a4b34a53c61d",
                "html_url_before": "https://github.com/torvalds/linux/commit/01b3f52157ff5a47d6d8d796f396a4b34a53c61d"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "include/linux/ipv6.h"
    },
    {
        "index": 1117,
        "cve_id": "CVE-2016-4805",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in drivers/net/ppp/ppp_generic.c in the Linux kernel before 4.5.2 allows local users to cause a denial of service (memory corruption and system crash, or spinlock) or possibly have unspecified other impact by removing a network namespace, related to the ppp_register_net_channel and ppp_unregister_channel functions.",
        "cvss": "7.8",
        "publish_date": "May 23, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "commit_message": "ppp: take reference on channels netns\n\nLet channels hold a reference on their network namespace.\nSome channel types, like ppp_async and ppp_synctty, can have their\nuserspace controller running in a different namespace. Therefore they\ncan't rely on them to preclude their netns from being removed from\nunder them.\n\n==================================================================\nBUG: KASAN: use-after-free in ppp_unregister_channel+0x372/0x3a0 at\naddr ffff880064e217e0\nRead of size 8 by task syz-executor/11581\n=============================================================================\nBUG net_namespace (Not tainted): kasan: bad access detected\n-----------------------------------------------------------------------------\n\nDisabling lock debugging due to kernel taint\nINFO: Allocated in copy_net_ns+0x6b/0x1a0 age=92569 cpu=3 pid=6906\n[<      none      >] ___slab_alloc+0x4c7/0x500 kernel/mm/slub.c:2440\n[<      none      >] __slab_alloc+0x4c/0x90 kernel/mm/slub.c:2469\n[<     inline     >] slab_alloc_node kernel/mm/slub.c:2532\n[<     inline     >] slab_alloc kernel/mm/slub.c:2574\n[<      none      >] kmem_cache_alloc+0x23a/0x2b0 kernel/mm/slub.c:2579\n[<     inline     >] kmem_cache_zalloc kernel/include/linux/slab.h:597\n[<     inline     >] net_alloc kernel/net/core/net_namespace.c:325\n[<      none      >] copy_net_ns+0x6b/0x1a0 kernel/net/core/net_namespace.c:360\n[<      none      >] create_new_namespaces+0x2f6/0x610 kernel/kernel/nsproxy.c:95\n[<      none      >] copy_namespaces+0x297/0x320 kernel/kernel/nsproxy.c:150\n[<      none      >] copy_process.part.35+0x1bf4/0x5760 kernel/kernel/fork.c:1451\n[<     inline     >] copy_process kernel/kernel/fork.c:1274\n[<      none      >] _do_fork+0x1bc/0xcb0 kernel/kernel/fork.c:1723\n[<     inline     >] SYSC_clone kernel/kernel/fork.c:1832\n[<      none      >] SyS_clone+0x37/0x50 kernel/kernel/fork.c:1826\n[<      none      >] entry_SYSCALL_64_fastpath+0x16/0x7a kernel/arch/x86/entry/entry_64.S:185\n\nINFO: Freed in net_drop_ns+0x67/0x80 age=575 cpu=2 pid=2631\n[<      none      >] __slab_free+0x1fc/0x320 kernel/mm/slub.c:2650\n[<     inline     >] slab_free kernel/mm/slub.c:2805\n[<      none      >] kmem_cache_free+0x2a0/0x330 kernel/mm/slub.c:2814\n[<     inline     >] net_free kernel/net/core/net_namespace.c:341\n[<      none      >] net_drop_ns+0x67/0x80 kernel/net/core/net_namespace.c:348\n[<      none      >] cleanup_net+0x4e5/0x600 kernel/net/core/net_namespace.c:448\n[<      none      >] process_one_work+0x794/0x1440 kernel/kernel/workqueue.c:2036\n[<      none      >] worker_thread+0xdb/0xfc0 kernel/kernel/workqueue.c:2170\n[<      none      >] kthread+0x23f/0x2d0 kernel/drivers/block/aoe/aoecmd.c:1303\n[<      none      >] ret_from_fork+0x3f/0x70 kernel/arch/x86/entry/entry_64.S:468\nINFO: Slab 0xffffea0001938800 objects=3 used=0 fp=0xffff880064e20000\nflags=0x5fffc0000004080\nINFO: Object 0xffff880064e20000 @offset=0 fp=0xffff880064e24200\n\nCPU: 1 PID: 11581 Comm: syz-executor Tainted: G    B           4.4.0+\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\nrel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014\n 00000000ffffffff ffff8800662c7790 ffffffff8292049d ffff88003e36a300\n ffff880064e20000 ffff880064e20000 ffff8800662c77c0 ffffffff816f2054\n ffff88003e36a300 ffffea0001938800 ffff880064e20000 0000000000000000\nCall Trace:\n [<     inline     >] __dump_stack kernel/lib/dump_stack.c:15\n [<ffffffff8292049d>] dump_stack+0x6f/0xa2 kernel/lib/dump_stack.c:50\n [<ffffffff816f2054>] print_trailer+0xf4/0x150 kernel/mm/slub.c:654\n [<ffffffff816f875f>] object_err+0x2f/0x40 kernel/mm/slub.c:661\n [<     inline     >] print_address_description kernel/mm/kasan/report.c:138\n [<ffffffff816fb0c5>] kasan_report_error+0x215/0x530 kernel/mm/kasan/report.c:236\n [<     inline     >] kasan_report kernel/mm/kasan/report.c:259\n [<ffffffff816fb4de>] __asan_report_load8_noabort+0x3e/0x40 kernel/mm/kasan/report.c:280\n [<     inline     >] ? ppp_pernet kernel/include/linux/compiler.h:218\n [<ffffffff83ad71b2>] ? ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392\n [<     inline     >] ppp_pernet kernel/include/linux/compiler.h:218\n [<ffffffff83ad71b2>] ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392\n [<     inline     >] ? ppp_pernet kernel/drivers/net/ppp/ppp_generic.c:293\n [<ffffffff83ad6f26>] ? ppp_unregister_channel+0xe6/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392\n [<ffffffff83ae18f3>] ppp_asynctty_close+0xa3/0x130 kernel/drivers/net/ppp/ppp_async.c:241\n [<ffffffff83ae1850>] ? async_lcp_peek+0x5b0/0x5b0 kernel/drivers/net/ppp/ppp_async.c:1000\n [<ffffffff82c33239>] tty_ldisc_close.isra.1+0x99/0xe0 kernel/drivers/tty/tty_ldisc.c:478\n [<ffffffff82c332c0>] tty_ldisc_kill+0x40/0x170 kernel/drivers/tty/tty_ldisc.c:744\n [<ffffffff82c34943>] tty_ldisc_release+0x1b3/0x260 kernel/drivers/tty/tty_ldisc.c:772\n [<ffffffff82c1ef21>] tty_release+0xac1/0x13e0 kernel/drivers/tty/tty_io.c:1901\n [<ffffffff82c1e460>] ? release_tty+0x320/0x320 kernel/drivers/tty/tty_io.c:1688\n [<ffffffff8174de36>] __fput+0x236/0x780 kernel/fs/file_table.c:208\n [<ffffffff8174e405>] ____fput+0x15/0x20 kernel/fs/file_table.c:244\n [<ffffffff813595ab>] task_work_run+0x16b/0x200 kernel/kernel/task_work.c:115\n [<     inline     >] exit_task_work kernel/include/linux/task_work.h:21\n [<ffffffff81307105>] do_exit+0x8b5/0x2c60 kernel/kernel/exit.c:750\n [<ffffffff813fdd20>] ? debug_check_no_locks_freed+0x290/0x290 kernel/kernel/locking/lockdep.c:4123\n [<ffffffff81306850>] ? mm_update_next_owner+0x6f0/0x6f0 kernel/kernel/exit.c:357\n [<ffffffff813215e6>] ? __dequeue_signal+0x136/0x470 kernel/kernel/signal.c:550\n [<ffffffff8132067b>] ? recalc_sigpending_tsk+0x13b/0x180 kernel/kernel/signal.c:145\n [<ffffffff81309628>] do_group_exit+0x108/0x330 kernel/kernel/exit.c:880\n [<ffffffff8132b9d4>] get_signal+0x5e4/0x14f0 kernel/kernel/signal.c:2307\n [<     inline     >] ? kretprobe_table_lock kernel/kernel/kprobes.c:1113\n [<ffffffff8151d355>] ? kprobe_flush_task+0xb5/0x450 kernel/kernel/kprobes.c:1158\n [<ffffffff8115f7d3>] do_signal+0x83/0x1c90 kernel/arch/x86/kernel/signal.c:712\n [<ffffffff8151d2a0>] ? recycle_rp_inst+0x310/0x310 kernel/include/linux/list.h:655\n [<ffffffff8115f750>] ? setup_sigcontext+0x780/0x780 kernel/arch/x86/kernel/signal.c:165\n [<ffffffff81380864>] ? finish_task_switch+0x424/0x5f0 kernel/kernel/sched/core.c:2692\n [<     inline     >] ? finish_lock_switch kernel/kernel/sched/sched.h:1099\n [<ffffffff81380560>] ? finish_task_switch+0x120/0x5f0 kernel/kernel/sched/core.c:2678\n [<     inline     >] ? context_switch kernel/kernel/sched/core.c:2807\n [<ffffffff85d794e9>] ? __schedule+0x919/0x1bd0 kernel/kernel/sched/core.c:3283\n [<ffffffff81003901>] exit_to_usermode_loop+0xf1/0x1a0 kernel/arch/x86/entry/common.c:247\n [<     inline     >] prepare_exit_to_usermode kernel/arch/x86/entry/common.c:282\n [<ffffffff810062ef>] syscall_return_slowpath+0x19f/0x210 kernel/arch/x86/entry/common.c:344\n [<ffffffff85d88022>] int_ret_from_sys_call+0x25/0x9f kernel/arch/x86/entry/entry_64.S:281\nMemory state around the buggy address:\n ffff880064e21680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff880064e21700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff880064e21780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                                       ^\n ffff880064e21800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff880064e21880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n==================================================================\n\nFixes: 273ec51dd7ce (\"net: ppp_generic - introduce net-namespace functionality v2\")\nReported-by: Baozeng Ding <sploving1@gmail.com>\nSigned-off-by: Guillaume Nault <g.nault@alphalink.fr>\nReviewed-by: Cyrill Gorcunov <gorcunov@openvz.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2016-03-23T18:35:31Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "html_url": "https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "parents": [
            {
                "commit_id_before": "5197f3499c470ccc4b247db66ff883e597e3adda",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/5197f3499c470ccc4b247db66ff883e597e3adda",
                "html_url_before": "https://github.com/torvalds/linux/commit/5197f3499c470ccc4b247db66ff883e597e3adda"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/net/ppp/ppp_generic.c"
    },
    {
        "index": 1334,
        "cve_id": "CVE-2016-6828",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The tcp_check_send_head function in include/net/tcp.h in the Linux kernel before 4.7.5 does not properly maintain certain SACK state after a failed data copy, which allows local users to cause a denial of service (tcp_xmit_retransmit_queue use-after-free and system crash) via a crafted SACK option.",
        "cvss": "5.5",
        "publish_date": "October 16, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "bb1fceca22492109be12640d49f5ea5a544c6bb4",
        "commit_message": "tcp: fix use after free in tcp_xmit_retransmit_queue()\n\nWhen tcp_sendmsg() allocates a fresh and empty skb, it puts it at the\ntail of the write queue using tcp_add_write_queue_tail()\n\nThen it attempts to copy user data into this fresh skb.\n\nIf the copy fails, we undo the work and remove the fresh skb.\n\nUnfortunately, this undo lacks the change done to tp->highest_sack and\nwe can leave a dangling pointer (to a freed skb)\n\nLater, tcp_xmit_retransmit_queue() can dereference this pointer and\naccess freed memory. For regular kernels where memory is not unmapped,\nthis might cause SACK bugs because tcp_highest_sack_seq() is buggy,\nreturning garbage instead of tp->snd_nxt, but with various debug\nfeatures like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.\n\nThis bug was found by Marco Grassi thanks to syzkaller.\n\nFixes: 6859d49475d4 (\"[TCP]: Abstract tp->highest_sack accessing & point to next skb\")\nReported-by: Marco Grassi <marco.gra@gmail.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Ilpo J\u00e4rvinen <ilpo.jarvinen@helsinki.fi>\nCc: Yuchung Cheng <ycheng@google.com>\nCc: Neal Cardwell <ncardwell@google.com>\nAcked-by: Neal Cardwell <ncardwell@google.com>\nReviewed-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2016-08-19T06:22:57Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/bb1fceca22492109be12640d49f5ea5a544c6bb4",
        "html_url": "https://github.com/torvalds/linux/commit/bb1fceca22492109be12640d49f5ea5a544c6bb4",
        "parents": [
            {
                "commit_id_before": "e0d8b2908696d30583ae5764e33332e71cbbccc9",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/e0d8b2908696d30583ae5764e33332e71cbbccc9",
                "html_url_before": "https://github.com/torvalds/linux/commit/e0d8b2908696d30583ae5764e33332e71cbbccc9"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "include/net/tcp.h"
    },
    {
        "index": 1377,
        "cve_id": "CVE-2016-7910",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the disk_seqf_stop function in block/genhd.c in the Linux kernel before 4.7.1 allows local users to gain privileges by leveraging the execution of a certain stop operation even if the corresponding start operation had failed.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "77da160530dd1dc94f6ae15a981f24e5f0021e84",
        "commit_message": "block: fix use-after-free in seq file\n\nI got a KASAN report of use-after-free:\n\n    ==================================================================\n    BUG: KASAN: use-after-free in klist_iter_exit+0x61/0x70 at addr ffff8800b6581508\n    Read of size 8 by task trinity-c1/315\n    =============================================================================\n    BUG kmalloc-32 (Not tainted): kasan: bad access detected\n    -----------------------------------------------------------------------------\n\n    Disabling lock debugging due to kernel taint\n    INFO: Allocated in disk_seqf_start+0x66/0x110 age=144 cpu=1 pid=315\n            ___slab_alloc+0x4f1/0x520\n            __slab_alloc.isra.58+0x56/0x80\n            kmem_cache_alloc_trace+0x260/0x2a0\n            disk_seqf_start+0x66/0x110\n            traverse+0x176/0x860\n            seq_read+0x7e3/0x11a0\n            proc_reg_read+0xbc/0x180\n            do_loop_readv_writev+0x134/0x210\n            do_readv_writev+0x565/0x660\n            vfs_readv+0x67/0xa0\n            do_preadv+0x126/0x170\n            SyS_preadv+0xc/0x10\n            do_syscall_64+0x1a1/0x460\n            return_from_SYSCALL_64+0x0/0x6a\n    INFO: Freed in disk_seqf_stop+0x42/0x50 age=160 cpu=1 pid=315\n            __slab_free+0x17a/0x2c0\n            kfree+0x20a/0x220\n            disk_seqf_stop+0x42/0x50\n            traverse+0x3b5/0x860\n            seq_read+0x7e3/0x11a0\n            proc_reg_read+0xbc/0x180\n            do_loop_readv_writev+0x134/0x210\n            do_readv_writev+0x565/0x660\n            vfs_readv+0x67/0xa0\n            do_preadv+0x126/0x170\n            SyS_preadv+0xc/0x10\n            do_syscall_64+0x1a1/0x460\n            return_from_SYSCALL_64+0x0/0x6a\n\n    CPU: 1 PID: 315 Comm: trinity-c1 Tainted: G    B           4.7.0+ #62\n    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n     ffffea0002d96000 ffff880119b9f918 ffffffff81d6ce81 ffff88011a804480\n     ffff8800b6581500 ffff880119b9f948 ffffffff8146c7bd ffff88011a804480\n     ffffea0002d96000 ffff8800b6581500 fffffffffffffff4 ffff880119b9f970\n    Call Trace:\n     [<ffffffff81d6ce81>] dump_stack+0x65/0x84\n     [<ffffffff8146c7bd>] print_trailer+0x10d/0x1a0\n     [<ffffffff814704ff>] object_err+0x2f/0x40\n     [<ffffffff814754d1>] kasan_report_error+0x221/0x520\n     [<ffffffff8147590e>] __asan_report_load8_noabort+0x3e/0x40\n     [<ffffffff83888161>] klist_iter_exit+0x61/0x70\n     [<ffffffff82404389>] class_dev_iter_exit+0x9/0x10\n     [<ffffffff81d2e8ea>] disk_seqf_stop+0x3a/0x50\n     [<ffffffff8151f812>] seq_read+0x4b2/0x11a0\n     [<ffffffff815f8fdc>] proc_reg_read+0xbc/0x180\n     [<ffffffff814b24e4>] do_loop_readv_writev+0x134/0x210\n     [<ffffffff814b4c45>] do_readv_writev+0x565/0x660\n     [<ffffffff814b8a17>] vfs_readv+0x67/0xa0\n     [<ffffffff814b8de6>] do_preadv+0x126/0x170\n     [<ffffffff814b92ec>] SyS_preadv+0xc/0x10\n\nThis problem can occur in the following situation:\n\nopen()\n - pread()\n    - .seq_start()\n       - iter = kmalloc() // succeeds\n       - seqf->private = iter\n    - .seq_stop()\n       - kfree(seqf->private)\n - pread()\n    - .seq_start()\n       - iter = kmalloc() // fails\n    - .seq_stop()\n       - class_dev_iter_exit(seqf->private) // boom! old pointer\n\nAs the comment in disk_seqf_stop() says, stop is called even if start\nfailed, so we need to reinitialise the private pointer to NULL when seq\niteration stops.\n\nAn alternative would be to set the private pointer to NULL when the\nkmalloc() in disk_seqf_start() fails.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Vegard Nossum <vegard.nossum@oracle.com>\nAcked-by: Tejun Heo <tj@kernel.org>\nSigned-off-by: Jens Axboe <axboe@fb.com>",
        "commit_date": "2016-08-04T20:19:16Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/77da160530dd1dc94f6ae15a981f24e5f0021e84",
        "html_url": "https://github.com/torvalds/linux/commit/77da160530dd1dc94f6ae15a981f24e5f0021e84",
        "parents": [
            {
                "commit_id_before": "1aee6b9a7d947d42ed84baa4cf461e9d943b80f0",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/1aee6b9a7d947d42ed84baa4cf461e9d943b80f0",
                "html_url_before": "https://github.com/torvalds/linux/commit/1aee6b9a7d947d42ed84baa4cf461e9d943b80f0"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "block/genhd.c"
    },
    {
        "index": 1382,
        "cve_id": "CVE-2016-7911",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the get_task_ioprio function in block/ioprio.c in the Linux kernel before 4.6.6 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted ioprio_get system call.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "8ba8682107ee2ca3347354e018865d8e1967c5f4",
        "commit_message": "block: fix use-after-free in sys_ioprio_get()\n\nget_task_ioprio() accesses the task->io_context without holding the task\nlock and thus can race with exit_io_context(), leading to a\nuse-after-free. The reproducer below hits this within a few seconds on\nmy 4-core QEMU VM:\n\n#define _GNU_SOURCE\n#include <assert.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/wait.h>\n\nint main(int argc, char **argv)\n{\n\tpid_t pid, child;\n\tlong nproc, i;\n\n\t/* ioprio_set(IOPRIO_WHO_PROCESS, 0, IOPRIO_PRIO_VALUE(IOPRIO_CLASS_IDLE, 0)); */\n\tsyscall(SYS_ioprio_set, 1, 0, 0x6000);\n\n\tnproc = sysconf(_SC_NPROCESSORS_ONLN);\n\n\tfor (i = 0; i < nproc; i++) {\n\t\tpid = fork();\n\t\tassert(pid != -1);\n\t\tif (pid == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tpid = fork();\n\t\t\t\tassert(pid != -1);\n\t\t\t\tif (pid == 0) {\n\t\t\t\t\t_exit(0);\n\t\t\t\t} else {\n\t\t\t\t\tchild = wait(NULL);\n\t\t\t\t\tassert(child == pid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpid = fork();\n\t\tassert(pid != -1);\n\t\tif (pid == 0) {\n\t\t\tfor (;;) {\n\t\t\t\t/* ioprio_get(IOPRIO_WHO_PGRP, 0); */\n\t\t\t\tsyscall(SYS_ioprio_get, 2, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t/* ioprio_get(IOPRIO_WHO_PGRP, 0); */\n\t\tsyscall(SYS_ioprio_get, 2, 0);\n\t}\n\n\treturn 0;\n}\n\nThis gets us KASAN dumps like this:\n\n[   35.526914] ==================================================================\n[   35.530009] BUG: KASAN: out-of-bounds in get_task_ioprio+0x7b/0x90 at addr ffff880066f34e6c\n[   35.530009] Read of size 2 by task ioprio-gpf/363\n[   35.530009] =============================================================================\n[   35.530009] BUG blkdev_ioc (Not tainted): kasan: bad access detected\n[   35.530009] -----------------------------------------------------------------------------\n\n[   35.530009] Disabling lock debugging due to kernel taint\n[   35.530009] INFO: Allocated in create_task_io_context+0x2b/0x370 age=0 cpu=0 pid=360\n[   35.530009] \t___slab_alloc+0x55d/0x5a0\n[   35.530009] \t__slab_alloc.isra.20+0x2b/0x40\n[   35.530009] \tkmem_cache_alloc_node+0x84/0x200\n[   35.530009] \tcreate_task_io_context+0x2b/0x370\n[   35.530009] \tget_task_io_context+0x92/0xb0\n[   35.530009] \tcopy_process.part.8+0x5029/0x5660\n[   35.530009] \t_do_fork+0x155/0x7e0\n[   35.530009] \tSyS_clone+0x19/0x20\n[   35.530009] \tdo_syscall_64+0x195/0x3a0\n[   35.530009] \treturn_from_SYSCALL_64+0x0/0x6a\n[   35.530009] INFO: Freed in put_io_context+0xe7/0x120 age=0 cpu=0 pid=1060\n[   35.530009] \t__slab_free+0x27b/0x3d0\n[   35.530009] \tkmem_cache_free+0x1fb/0x220\n[   35.530009] \tput_io_context+0xe7/0x120\n[   35.530009] \tput_io_context_active+0x238/0x380\n[   35.530009] \texit_io_context+0x66/0x80\n[   35.530009] \tdo_exit+0x158e/0x2b90\n[   35.530009] \tdo_group_exit+0xe5/0x2b0\n[   35.530009] \tSyS_exit_group+0x1d/0x20\n[   35.530009] \tentry_SYSCALL_64_fastpath+0x1a/0xa4\n[   35.530009] INFO: Slab 0xffffea00019bcd00 objects=20 used=4 fp=0xffff880066f34ff0 flags=0x1fffe0000004080\n[   35.530009] INFO: Object 0xffff880066f34e58 @offset=3672 fp=0x0000000000000001\n[   35.530009] ==================================================================\n\nFix it by grabbing the task lock while we poke at the io_context.\n\nCc: stable@vger.kernel.org\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Omar Sandoval <osandov@fb.com>\nSigned-off-by: Jens Axboe <axboe@fb.com>",
        "commit_date": "2016-07-01T14:39:24Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/8ba8682107ee2ca3347354e018865d8e1967c5f4",
        "html_url": "https://github.com/torvalds/linux/commit/8ba8682107ee2ca3347354e018865d8e1967c5f4",
        "parents": [
            {
                "commit_id_before": "74524955556096a0b2a821a49b4d0abebad3ee16",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/74524955556096a0b2a821a49b4d0abebad3ee16",
                "html_url_before": "https://github.com/torvalds/linux/commit/74524955556096a0b2a821a49b4d0abebad3ee16"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "block/ioprio.c"
    },
    {
        "index": 1383,
        "cve_id": "CVE-2016-7912",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the ffs_user_copy_worker function in drivers/usb/gadget/function/f_fs.c in the Linux kernel before 4.5.3 allows local users to gain privileges by accessing an I/O data structure after a certain callback call.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "38740a5b87d53ceb89eb2c970150f6e94e00373a",
        "commit_message": "usb: gadget: f_fs: Fix use-after-free\n\nWhen using asynchronous read or write operations on the USB endpoints the\nissuer of the IO request is notified by calling the ki_complete() callback\nof the submitted kiocb when the URB has been completed.\n\nCalling this ki_complete() callback will free kiocb. Make sure that the\nstructure is no longer accessed beyond that point, otherwise undefined\nbehaviour might occur.\n\nFixes: 2e4c7553cd6f (\"usb: gadget: f_fs: add aio support\")\nCc: <stable@vger.kernel.org> # v3.15+\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nSigned-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>",
        "commit_date": "2016-04-20T07:38:06Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/38740a5b87d53ceb89eb2c970150f6e94e00373a",
        "html_url": "https://github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a",
        "parents": [
            {
                "commit_id_before": "9772b47a4c2916d645c551228b6085ea24acbe5d",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/9772b47a4c2916d645c551228b6085ea24acbe5d",
                "html_url_before": "https://github.com/torvalds/linux/commit/9772b47a4c2916d645c551228b6085ea24acbe5d"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/usb/gadget/function/f_fs.c"
    },
    {
        "index": 1376,
        "cve_id": "CVE-2016-7913",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The xc2028_set_config function in drivers/media/tuners/tuner-xc2028.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) via vectors involving omission of the firmware name from a certain data structure.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "8dfbcc4351a0b6d2f2d77f367552f48ffefafe18",
        "commit_message": "[media] xc2028: avoid use after free\n\nIf struct xc2028_config is passed without a firmware name,\nthe following trouble may happen:\n\n[11009.907205] xc2028 5-0061: type set to XCeive xc2028/xc3028 tuner\n[11009.907491] ==================================================================\n[11009.907750] BUG: KASAN: use-after-free in strcmp+0x96/0xb0 at addr ffff8803bd78ab40\n[11009.907992] Read of size 1 by task modprobe/28992\n[11009.907994] =============================================================================\n[11009.907997] BUG kmalloc-16 (Tainted: G        W      ): kasan: bad access detected\n[11009.907999] -----------------------------------------------------------------------------\n\n[11009.908008] INFO: Allocated in xhci_urb_enqueue+0x214/0x14c0 [xhci_hcd] age=0 cpu=3 pid=28992\n[11009.908012] \t___slab_alloc+0x581/0x5b0\n[11009.908014] \t__slab_alloc+0x51/0x90\n[11009.908017] \t__kmalloc+0x27b/0x350\n[11009.908022] \txhci_urb_enqueue+0x214/0x14c0 [xhci_hcd]\n[11009.908026] \tusb_hcd_submit_urb+0x1e8/0x1c60\n[11009.908029] \tusb_submit_urb+0xb0e/0x1200\n[11009.908032] \tusb_serial_generic_write_start+0xb6/0x4c0\n[11009.908035] \tusb_serial_generic_write+0x92/0xc0\n[11009.908039] \tusb_console_write+0x38a/0x560\n[11009.908045] \tcall_console_drivers.constprop.14+0x1ee/0x2c0\n[11009.908051] \tconsole_unlock+0x40d/0x900\n[11009.908056] \tvprintk_emit+0x4b4/0x830\n[11009.908061] \tvprintk_default+0x1f/0x30\n[11009.908064] \tprintk+0x99/0xb5\n[11009.908067] \tkasan_report_error+0x10a/0x550\n[11009.908070] \t__asan_report_load1_noabort+0x43/0x50\n[11009.908074] INFO: Freed in xc2028_set_config+0x90/0x630 [tuner_xc2028] age=1 cpu=3 pid=28992\n[11009.908077] \t__slab_free+0x2ec/0x460\n[11009.908080] \tkfree+0x266/0x280\n[11009.908083] \txc2028_set_config+0x90/0x630 [tuner_xc2028]\n[11009.908086] \txc2028_attach+0x310/0x8a0 [tuner_xc2028]\n[11009.908090] \tem28xx_attach_xc3028.constprop.7+0x1f9/0x30d [em28xx_dvb]\n[11009.908094] \tem28xx_dvb_init.part.3+0x8e4/0x5cf4 [em28xx_dvb]\n[11009.908098] \tem28xx_dvb_init+0x81/0x8a [em28xx_dvb]\n[11009.908101] \tem28xx_register_extension+0xd9/0x190 [em28xx]\n[11009.908105] \tem28xx_dvb_register+0x10/0x1000 [em28xx_dvb]\n[11009.908108] \tdo_one_initcall+0x141/0x300\n[11009.908111] \tdo_init_module+0x1d0/0x5ad\n[11009.908114] \tload_module+0x6666/0x9ba0\n[11009.908117] \tSyS_finit_module+0x108/0x130\n[11009.908120] \tentry_SYSCALL_64_fastpath+0x16/0x76\n[11009.908123] INFO: Slab 0xffffea000ef5e280 objects=25 used=25 fp=0x          (null) flags=0x2ffff8000004080\n[11009.908126] INFO: Object 0xffff8803bd78ab40 @offset=2880 fp=0x0000000000000001\n\n[11009.908130] Bytes b4 ffff8803bd78ab30: 01 00 00 00 2a 07 00 00 9d 28 00 00 01 00 00 00  ....*....(......\n[11009.908133] Object ffff8803bd78ab40: 01 00 00 00 00 00 00 00 b0 1d c3 6a 00 88 ff ff  ...........j....\n[11009.908137] CPU: 3 PID: 28992 Comm: modprobe Tainted: G    B   W       4.5.0-rc1+ #43\n[11009.908140] Hardware name:                  /NUC5i7RYB, BIOS RYBDWi35.86A.0350.2015.0812.1722 08/12/2015\n[11009.908142]  ffff8803bd78a000 ffff8802c273f1b8 ffffffff81932007 ffff8803c6407a80\n[11009.908148]  ffff8802c273f1e8 ffffffff81556759 ffff8803c6407a80 ffffea000ef5e280\n[11009.908153]  ffff8803bd78ab40 dffffc0000000000 ffff8802c273f210 ffffffff8155ccb4\n[11009.908158] Call Trace:\n[11009.908162]  [<ffffffff81932007>] dump_stack+0x4b/0x64\n[11009.908165]  [<ffffffff81556759>] print_trailer+0xf9/0x150\n[11009.908168]  [<ffffffff8155ccb4>] object_err+0x34/0x40\n[11009.908171]  [<ffffffff8155f260>] kasan_report_error+0x230/0x550\n[11009.908175]  [<ffffffff81237d71>] ? trace_hardirqs_off_caller+0x21/0x290\n[11009.908179]  [<ffffffff8155e926>] ? kasan_unpoison_shadow+0x36/0x50\n[11009.908182]  [<ffffffff8155f5c3>] __asan_report_load1_noabort+0x43/0x50\n[11009.908185]  [<ffffffff8155ea00>] ? __asan_register_globals+0x50/0xa0\n[11009.908189]  [<ffffffff8194cea6>] ? strcmp+0x96/0xb0\n[11009.908192]  [<ffffffff8194cea6>] strcmp+0x96/0xb0\n[11009.908196]  [<ffffffffa13ba4ac>] xc2028_set_config+0x15c/0x630 [tuner_xc2028]\n[11009.908200]  [<ffffffffa13bac90>] xc2028_attach+0x310/0x8a0 [tuner_xc2028]\n[11009.908203]  [<ffffffff8155ea78>] ? memset+0x28/0x30\n[11009.908206]  [<ffffffffa13ba980>] ? xc2028_set_config+0x630/0x630 [tuner_xc2028]\n[11009.908211]  [<ffffffffa157a59a>] em28xx_attach_xc3028.constprop.7+0x1f9/0x30d [em28xx_dvb]\n[11009.908215]  [<ffffffffa157aa2a>] ? em28xx_dvb_init.part.3+0x37c/0x5cf4 [em28xx_dvb]\n[11009.908219]  [<ffffffffa157a3a1>] ? hauppauge_hvr930c_init+0x487/0x487 [em28xx_dvb]\n[11009.908222]  [<ffffffffa01795ac>] ? lgdt330x_attach+0x1cc/0x370 [lgdt330x]\n[11009.908226]  [<ffffffffa01793e0>] ? i2c_read_demod_bytes.isra.2+0x210/0x210 [lgdt330x]\n[11009.908230]  [<ffffffff812e87d0>] ? ref_module.part.15+0x10/0x10\n[11009.908233]  [<ffffffff812e56e0>] ? module_assert_mutex_or_preempt+0x80/0x80\n[11009.908238]  [<ffffffffa157af92>] em28xx_dvb_init.part.3+0x8e4/0x5cf4 [em28xx_dvb]\n[11009.908242]  [<ffffffffa157a6ae>] ? em28xx_attach_xc3028.constprop.7+0x30d/0x30d [em28xx_dvb]\n[11009.908245]  [<ffffffff8195222d>] ? string+0x14d/0x1f0\n[11009.908249]  [<ffffffff8195381f>] ? symbol_string+0xff/0x1a0\n[11009.908253]  [<ffffffff81953720>] ? uuid_string+0x6f0/0x6f0\n[11009.908257]  [<ffffffff811a775e>] ? __kernel_text_address+0x7e/0xa0\n[11009.908260]  [<ffffffff8104b02f>] ? print_context_stack+0x7f/0xf0\n[11009.908264]  [<ffffffff812e9846>] ? __module_address+0xb6/0x360\n[11009.908268]  [<ffffffff8137fdc9>] ? is_ftrace_trampoline+0x99/0xe0\n[11009.908271]  [<ffffffff811a775e>] ? __kernel_text_address+0x7e/0xa0\n[11009.908275]  [<ffffffff81240a70>] ? debug_check_no_locks_freed+0x290/0x290\n[11009.908278]  [<ffffffff8104a24b>] ? dump_trace+0x11b/0x300\n[11009.908282]  [<ffffffffa13e8143>] ? em28xx_register_extension+0x23/0x190 [em28xx]\n[11009.908285]  [<ffffffff81237d71>] ? trace_hardirqs_off_caller+0x21/0x290\n[11009.908289]  [<ffffffff8123ff56>] ? trace_hardirqs_on_caller+0x16/0x590\n[11009.908292]  [<ffffffff812404dd>] ? trace_hardirqs_on+0xd/0x10\n[11009.908296]  [<ffffffffa13e8143>] ? em28xx_register_extension+0x23/0x190 [em28xx]\n[11009.908299]  [<ffffffff822dcbb0>] ? mutex_trylock+0x400/0x400\n[11009.908302]  [<ffffffff810021a1>] ? do_one_initcall+0x131/0x300\n[11009.908306]  [<ffffffff81296dc7>] ? call_rcu_sched+0x17/0x20\n[11009.908309]  [<ffffffff8159e708>] ? put_object+0x48/0x70\n[11009.908314]  [<ffffffffa1579f11>] em28xx_dvb_init+0x81/0x8a [em28xx_dvb]\n[11009.908317]  [<ffffffffa13e81f9>] em28xx_register_extension+0xd9/0x190 [em28xx]\n[11009.908320]  [<ffffffffa0150000>] ? 0xffffffffa0150000\n[11009.908324]  [<ffffffffa0150010>] em28xx_dvb_register+0x10/0x1000 [em28xx_dvb]\n[11009.908327]  [<ffffffff810021b1>] do_one_initcall+0x141/0x300\n[11009.908330]  [<ffffffff81002070>] ? try_to_run_init_process+0x40/0x40\n[11009.908333]  [<ffffffff8123ff56>] ? trace_hardirqs_on_caller+0x16/0x590\n[11009.908337]  [<ffffffff8155e926>] ? kasan_unpoison_shadow+0x36/0x50\n[11009.908340]  [<ffffffff8155e926>] ? kasan_unpoison_shadow+0x36/0x50\n[11009.908343]  [<ffffffff8155e926>] ? kasan_unpoison_shadow+0x36/0x50\n[11009.908346]  [<ffffffff8155ea37>] ? __asan_register_globals+0x87/0xa0\n[11009.908350]  [<ffffffff8144da7b>] do_init_module+0x1d0/0x5ad\n[11009.908353]  [<ffffffff812f2626>] load_module+0x6666/0x9ba0\n[11009.908356]  [<ffffffff812e9c90>] ? symbol_put_addr+0x50/0x50\n[11009.908361]  [<ffffffffa1580037>] ? em28xx_dvb_init.part.3+0x5989/0x5cf4 [em28xx_dvb]\n[11009.908366]  [<ffffffff812ebfc0>] ? module_frob_arch_sections+0x20/0x20\n[11009.908369]  [<ffffffff815bc940>] ? open_exec+0x50/0x50\n[11009.908374]  [<ffffffff811671bb>] ? ns_capable+0x5b/0xd0\n[11009.908377]  [<ffffffff812f5e58>] SyS_finit_module+0x108/0x130\n[11009.908379]  [<ffffffff812f5d50>] ? SyS_init_module+0x1f0/0x1f0\n[11009.908383]  [<ffffffff81004044>] ? lockdep_sys_exit_thunk+0x12/0x14\n[11009.908394]  [<ffffffff822e6936>] entry_SYSCALL_64_fastpath+0x16/0x76\n[11009.908396] Memory state around the buggy address:\n[11009.908398]  ffff8803bd78aa00: 00 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[11009.908401]  ffff8803bd78aa80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[11009.908403] >ffff8803bd78ab00: fc fc fc fc fc fc fc fc 00 00 fc fc fc fc fc fc\n[11009.908405]                                            ^\n[11009.908407]  ffff8803bd78ab80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[11009.908409]  ffff8803bd78ac00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[11009.908411] ==================================================================\n\nIn order to avoid it, let's set the cached value of the firmware\nname to NULL after freeing it. While here, return an error if\nthe memory allocation fails.\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>",
        "commit_date": "2016-02-01T09:16:18Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/8dfbcc4351a0b6d2f2d77f367552f48ffefafe18",
        "html_url": "https://github.com/torvalds/linux/commit/8dfbcc4351a0b6d2f2d77f367552f48ffefafe18",
        "parents": [
            {
                "commit_id_before": "d83a96a53dd2c36948be37b64a85a761b942ddfd",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/d83a96a53dd2c36948be37b64a85a761b942ddfd",
                "html_url_before": "https://github.com/torvalds/linux/commit/d83a96a53dd2c36948be37b64a85a761b942ddfd"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/media/tuners/tuner-xc2028.c"
    },
    {
        "index": 1454,
        "cve_id": "CVE-2016-8655",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in net/packet/af_packet.c in the Linux kernel through 4.8.12 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging the CAP_NET_RAW capability to change a socket version, related to the packet_set_ring and packet_setsockopt functions.",
        "cvss": "7.8",
        "publish_date": "December 8, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "84ac7260236a49c79eede91617700174c2c19b0c",
        "commit_message": "packet: fix race condition in packet_set_ring\n\nWhen packet_set_ring creates a ring buffer it will initialize a\nstruct timer_list if the packet version is TPACKET_V3. This value\ncan then be raced by a different thread calling setsockopt to\nset the version to TPACKET_V1 before packet_set_ring has finished.\n\nThis leads to a use-after-free on a function pointer in the\nstruct timer_list when the socket is closed as the previously\ninitialized timer will not be deleted.\n\nThe bug is fixed by taking lock_sock(sk) in packet_setsockopt when\nchanging the packet version while also taking the lock at the start\nof packet_set_ring.\n\nFixes: f6fb8f100b80 (\"af-packet: TPACKET_V3 flexible buffer implementation.\")\nSigned-off-by: Philip Pettersson <philip.pettersson@gmail.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2016-12-02T17:16:49Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/84ac7260236a49c79eede91617700174c2c19b0c",
        "html_url": "https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c",
        "parents": [
            {
                "commit_id_before": "2219d5ed77e8bdc2ef1f0b79f34d2cc0be802b25",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/2219d5ed77e8bdc2ef1f0b79f34d2cc0be802b25",
                "html_url_before": "https://github.com/torvalds/linux/commit/2219d5ed77e8bdc2ef1f0b79f34d2cc0be802b25"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/packet/af_packet.c"
    },
    {
        "index": 1452,
        "cve_id": "CVE-2016-9120",
        "cwe_id": [
            "CWE-264",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the ion_ioctl function in drivers/staging/android/ion/ion.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) by calling ION_IOC_FREE on two CPUs at the same time.",
        "cvss": "7.8",
        "publish_date": "December 8, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "9590232bb4f4cc824f3425a6e1349afbe6d6d2b7",
        "commit_message": "staging/android/ion : fix a race condition in the ion driver\n\nThere is a use-after-free problem in the ion driver.\nThis is caused by a race condition in the ion_ioctl()\nfunction.\n\nA handle has ref count of 1 and two tasks on different\ncpus calls ION_IOC_FREE simultaneously.\n\ncpu 0                                   cpu 1\n-------------------------------------------------------\nion_handle_get_by_id()\n(ref == 2)\n                            ion_handle_get_by_id()\n                            (ref == 3)\n\nion_free()\n(ref == 2)\n\nion_handle_put()\n(ref == 1)\n\n                            ion_free()\n                            (ref == 0 so ion_handle_destroy() is\n                            called\n                            and the handle is freed.)\n\n                            ion_handle_put() is called and it\n                            decreases the slub's next free pointer\n\nThe problem is detected as an unaligned access in the\nspin lock functions since it uses load exclusive\n instruction. In some cases it corrupts the slub's\nfree pointer which causes a mis-aligned access to the\nnext free pointer.(kmalloc returns a pointer like\nffffc0745b4580aa). And it causes lots of other\nhard-to-debug problems.\n\nThis symptom is caused since the first member in the\nion_handle structure is the reference count and the\nion driver decrements the reference after it has been\nfreed.\n\nTo fix this problem client->lock mutex is extended\nto protect all the codes that uses the handle.\n\nSigned-off-by: Eun Taik Lee <eun.taik.lee@samsung.com>\nReviewed-by: Laura Abbott <labbott@redhat.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "commit_date": "2016-03-12T06:09:09Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7",
        "html_url": "https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7",
        "parents": [
            {
                "commit_id_before": "5a20df724f712e9daa9fd41b430ff63ecd203e85",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/5a20df724f712e9daa9fd41b430ff63ecd203e85",
                "html_url_before": "https://github.com/torvalds/linux/commit/5a20df724f712e9daa9fd41b430ff63ecd203e85"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/staging/android/ion/ion.c"
    },
    {
        "index": 1420,
        "cve_id": "CVE-2016-9576",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The blk_rq_map_user_iov function in block/blk-map.c in the Linux kernel before 4.8.14 does not properly restrict the type of iterator, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device.",
        "cvss": "7.8",
        "publish_date": "December 28, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "a0ac402cfcdc904f9772e1762b3fda112dcc56a0",
        "commit_message": "Don't feed anything but regular iovec's to blk_rq_map_user_iov\n\nIn theory we could map other things, but there's a reason that function\nis called \"user_iov\".  Using anything else (like splice can do) just\nconfuses it.\n\nReported-and-tested-by: Johannes Thumshirn <jthumshirn@suse.de>\nCc: Al Viro <viro@ZenIV.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2016-12-07T16:23:35Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/a0ac402cfcdc904f9772e1762b3fda112dcc56a0",
        "html_url": "https://github.com/torvalds/linux/commit/a0ac402cfcdc904f9772e1762b3fda112dcc56a0",
        "parents": [
            {
                "commit_id_before": "bc3913a5378cd0ddefd1dfec6917cc12eb23a946",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/bc3913a5378cd0ddefd1dfec6917cc12eb23a946",
                "html_url_before": "https://github.com/torvalds/linux/commit/bc3913a5378cd0ddefd1dfec6917cc12eb23a946"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "block/blk-map.c"
    },
    {
        "index": 1423,
        "cve_id": "CVE-2016-9794",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the snd_pcm_period_elapsed function in sound/core/pcm_lib.c in the ALSA subsystem in the Linux kernel before 4.7 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted SNDRV_PCM_TRIGGER_START command.",
        "cvss": "7.8",
        "publish_date": "December 28, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4",
        "commit_message": "ALSA: pcm : Call kill_fasync() in stream lock\n\nCurrently kill_fasync() is called outside the stream lock in\nsnd_pcm_period_elapsed().  This is potentially racy, since the stream\nmay get released even during the irq handler is running.  Although\nsnd_pcm_release_substream() calls snd_pcm_drop(), this doesn't\nguarantee that the irq handler finishes, thus the kill_fasync() call\noutside the stream spin lock may be invoked after the substream is\ndetached, as recently reported by KASAN.\n\nAs a quick workaround, move kill_fasync() call inside the stream\nlock.  The fasync is rarely used interface, so this shouldn't have a\nbig impact from the performance POV.\n\nIdeally, we should implement some sync mechanism for the proper finish\nof stream and irq handler.  But this oneliner should suffice for most\ncases, so far.\n\nReported-by: Baozeng Ding <sploving1@gmail.com>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2016-04-14T16:02:37Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4",
        "html_url": "https://github.com/torvalds/linux/commit/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4",
        "parents": [
            {
                "commit_id_before": "fa44b7ec9bc4115513e59f31da1167166bd6346a",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/fa44b7ec9bc4115513e59f31da1167166bd6346a",
                "html_url_before": "https://github.com/torvalds/linux/commit/fa44b7ec9bc4115513e59f31da1167166bd6346a"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "sound/core/pcm_lib.c"
    },
    {
        "index": 2209,
        "cve_id": "CVE-2017-10661",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in fs/timerfd.c in the Linux kernel before 4.10.15 allows local users to gain privileges or cause a denial of service (list corruption or use-after-free) via simultaneous file-descriptor operations that leverage improper might_cancel queueing.",
        "cvss": "7.0",
        "publish_date": "August 19, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "1e38da300e1e395a15048b0af1e5305bd91402f6",
        "commit_message": "timerfd: Protect the might cancel mechanism proper\n\nThe handling of the might_cancel queueing is not properly protected, so\nparallel operations on the file descriptor can race with each other and\nlead to list corruptions or use after free.\n\nProtect the context for these operations with a seperate lock.\n\nThe wait queue lock cannot be reused for this because that would create a\nlock inversion scenario vs. the cancel lock. Replacing might_cancel with an\natomic (atomic_t or atomic bit) does not help either because it still can\nrace vs. the actual list operation.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: \"linux-fsdevel@vger.kernel.org\"\nCc: syzkaller <syzkaller@googlegroups.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: linux-fsdevel@vger.kernel.org\nLink: http://lkml.kernel.org/r/alpine.DEB.2.20.1701311521430.3457@nanos\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>",
        "commit_date": "2017-02-10T10:15:09Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1e38da300e1e395a15048b0af1e5305bd91402f6",
        "html_url": "https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6",
        "parents": [
            {
                "commit_id_before": "7551b02b94ad1daee3a79d667dc3c46d08328f87",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/7551b02b94ad1daee3a79d667dc3c46d08328f87",
                "html_url_before": "https://github.com/torvalds/linux/commit/7551b02b94ad1daee3a79d667dc3c46d08328f87"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "fs/timerfd.c"
    },
    {
        "index": 2150,
        "cve_id": "CVE-2017-11176",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The mq_notify function in the Linux kernel through 4.11.9 does not set the sock pointer to NULL upon entry into the retry logic. During a user-space close of a Netlink socket, it allows attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact.",
        "cvss": "7.8",
        "publish_date": "July 11, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "f991af3daabaecff34684fd51fac80319d1baad1",
        "commit_message": "mqueue: fix a use-after-free in sys_mq_notify()\n\nThe retry logic for netlink_attachskb() inside sys_mq_notify()\nis nasty and vulnerable:\n\n1) The sock refcnt is already released when retry is needed\n2) The fd is controllable by user-space because we already\n   release the file refcnt\n\nso we when retry but the fd has been just closed by user-space\nduring this small window, we end up calling netlink_detachskb()\non the error path which releases the sock again, later when\nthe user-space closes this socket a use-after-free could be\ntriggered.\n\nSetting 'sock' to NULL here should be sufficient to fix it.\n\nReported-by: GeneBlue <geneblue.mail@gmail.com>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Manfred Spraul <manfred@colorfullife.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2017-07-09T21:37:19Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/f991af3daabaecff34684fd51fac80319d1baad1",
        "html_url": "https://github.com/torvalds/linux/commit/f991af3daabaecff34684fd51fac80319d1baad1",
        "parents": [
            {
                "commit_id_before": "2b976203417cf033079e0be30cae5f41d88e385e",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/2b976203417cf033079e0be30cae5f41d88e385e",
                "html_url_before": "https://github.com/torvalds/linux/commit/2b976203417cf033079e0be30cae5f41d88e385e"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "ipc/mqueue.c"
    },
    {
        "index": 2535,
        "cve_id": "CVE-2017-15115",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The sctp_do_peeloff function in net/sctp/socket.c in the Linux kernel before 4.14 does not check whether the intended netns is used in a peel-off action, which allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls.",
        "cvss": "7.8",
        "publish_date": "November 15, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "df80cd9b28b9ebaa284a41df611dbf3a2d05ca74",
        "commit_message": "sctp: do not peel off an assoc from one netns to another one\n\nNow when peeling off an association to the sock in another netns, all\ntransports in this assoc are not to be rehashed and keep use the old\nkey in hashtable.\n\nAs a transport uses sk->net as the hash key to insert into hashtable,\nit would miss removing these transports from hashtable due to the new\nnetns when closing the sock and all transports are being freeed, then\nlater an use-after-free issue could be caused when looking up an asoc\nand dereferencing those transports.\n\nThis is a very old issue since very beginning, ChunYu found it with\nsyzkaller fuzz testing with this series:\n\n  socket$inet6_sctp()\n  bind$inet6()\n  sendto$inet6()\n  unshare(0x40000000)\n  getsockopt$inet_sctp6_SCTP_GET_ASSOC_ID_LIST()\n  getsockopt$inet_sctp6_SCTP_SOCKOPT_PEELOFF()\n\nThis patch is to block this call when peeling one assoc off from one\nnetns to another one, so that the netns of all transport would not\ngo out-sync with the key in hashtable.\n\nNote that this patch didn't fix it by rehashing transports, as it's\ndifficult to handle the situation when the tuple is already in use\nin the new netns. Besides, no one would like to peel off one assoc\nto another netns, considering ipaddrs, ifaces, etc. are usually\ndifferent.\n\nReported-by: ChunYu Wang <chunwang@redhat.com>\nSigned-off-by: Xin Long <lucien.xin@gmail.com>\nAcked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2017-10-19T12:16:07Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74",
        "html_url": "https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74",
        "parents": [
            {
                "commit_id_before": "4bbb5083484016d4448739237aa1e6a9577ebb43",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/4bbb5083484016d4448739237aa1e6a9577ebb43",
                "html_url_before": "https://github.com/torvalds/linux/commit/4bbb5083484016d4448739237aa1e6a9577ebb43"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/sctp/socket.c"
    },
    {
        "index": 2644,
        "cve_id": "CVE-2017-15126",
        "cwe_id": [
            "CWE-119",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in fs/userfaultfd.c in the Linux kernel before 4.13.6. The issue is related to the handling of fork failure when dealing with event messages. Failure to fork correctly can lead to a situation where a fork event will be removed from an already freed list of events with userfaultfd_ctx_put().",
        "cvss": "5.5",
        "publish_date": "January 14, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "NONE",
        "commit_id": "384632e67e0829deb8015ee6ad916b180049d252",
        "commit_message": "userfaultfd: non-cooperative: fix fork use after free\n\nWhen reading the event from the uffd, we put it on a temporary\nfork_event list to detect if we can still access it after releasing and\nretaking the event_wqh.lock.\n\nIf fork aborts and removes the event from the fork_event all is fine as\nlong as we're still in the userfault read context and fork_event head is\nstill alive.\n\nWe've to put the event allocated in the fork kernel stack, back from\nfork_event list-head to the event_wqh head, before returning from\nuserfaultfd_ctx_read, because the fork_event head lifetime is limited to\nthe userfaultfd_ctx_read stack lifetime.\n\nForgetting to move the event back to its event_wqh place then results in\n__remove_wait_queue(&ctx->event_wqh, &ewq->wq); in\nuserfaultfd_event_wait_completion to remove it from a head that has been\nalready freed from the reader stack.\n\nThis could only happen if resolve_userfault_fork failed (for example if\nthere are no file descriptors available to allocate the fork uffd).  If\nit succeeded it was put back correctly.\n\nFurthermore, after find_userfault_evt receives a fork event, the forked\nuserfault context in fork_nctx and uwq->msg.arg.reserved.reserved1 can\nbe released by the fork thread as soon as the event_wqh.lock is\nreleased.  Taking a reference on the fork_nctx before dropping the lock\nprevents an use after free in resolve_userfault_fork().\n\nIf the fork side aborted and it already released everything, we still\ntry to succeed resolve_userfault_fork(), if possible.\n\nFixes: 893e26e61d04eac9 (\"userfaultfd: non-cooperative: Add fork() event\")\nLink: http://lkml.kernel.org/r/20170920180413.26713-1-aarcange@redhat.com\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nReported-by: Mark Rutland <mark.rutland@arm.com>\nTested-by: Mark Rutland <mark.rutland@arm.com>\nCc: Pavel Emelyanov <xemul@virtuozzo.com>\nCc: Mike Rapoport <rppt@linux.vnet.ibm.com>\nCc: \"Dr. David Alan Gilbert\" <dgilbert@redhat.com>\nCc: Mike Kravetz <mike.kravetz@oracle.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2017-10-04T00:54:25Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/384632e67e0829deb8015ee6ad916b180049d252",
        "html_url": "https://github.com/torvalds/linux/commit/384632e67e0829deb8015ee6ad916b180049d252",
        "parents": [
            {
                "commit_id_before": "7d790d2da386a52cfebcf0c898ba927bece9d4ab",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/7d790d2da386a52cfebcf0c898ba927bece9d4ab",
                "html_url_before": "https://github.com/torvalds/linux/commit/7d790d2da386a52cfebcf0c898ba927bece9d4ab"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "fs/userfaultfd.c"
    },
    {
        "index": 2652,
        "cve_id": "CVE-2017-15129",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free vulnerability was found in network namespaces code affecting the Linux kernel before 4.14.11. The function get_net_ns_by_id() in net/core/net_namespace.c does not check for the net::count value after it has found a peer network in netns_ids idr, which could lead to double free and memory corruption. This vulnerability could allow an unprivileged local user to induce kernel memory corruption on the system, leading to a crash. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is thought to be unlikely.",
        "cvss": "8.8",
        "publish_date": "January 9, 2018",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "21b5944350052d2583e82dd59b19a9ba94a007f0",
        "commit_message": "net: Fix double free and memory corruption in get_net_ns_by_id()\n\n(I can trivially verify that that idr_remove in cleanup_net happens\n after the network namespace count has dropped to zero --EWB)\n\nFunction get_net_ns_by_id() does not check for net::count\nafter it has found a peer in netns_ids idr.\n\nIt may dereference a peer, after its count has already been\nfinaly decremented. This leads to double free and memory\ncorruption:\n\nput_net(peer)                                   rtnl_lock()\natomic_dec_and_test(&peer->count) [count=0]     ...\n__put_net(peer)                                 get_net_ns_by_id(net, id)\n  spin_lock(&cleanup_list_lock)\n  list_add(&net->cleanup_list, &cleanup_list)\n  spin_unlock(&cleanup_list_lock)\nqueue_work()                                      peer = idr_find(&net->netns_ids, id)\n  |                                               get_net(peer) [count=1]\n  |                                               ...\n  |                                               (use after final put)\n  v                                               ...\n  cleanup_net()                                   ...\n    spin_lock(&cleanup_list_lock)                 ...\n    list_replace_init(&cleanup_list, ..)          ...\n    spin_unlock(&cleanup_list_lock)               ...\n    ...                                           ...\n    ...                                           put_net(peer)\n    ...                                             atomic_dec_and_test(&peer->count) [count=0]\n    ...                                               spin_lock(&cleanup_list_lock)\n    ...                                               list_add(&net->cleanup_list, &cleanup_list)\n    ...                                               spin_unlock(&cleanup_list_lock)\n    ...                                             queue_work()\n    ...                                           rtnl_unlock()\n    rtnl_lock()                                   ...\n    for_each_net(tmp) {                           ...\n      id = __peernet2id(tmp, peer)                ...\n      spin_lock_irq(&tmp->nsid_lock)              ...\n      idr_remove(&tmp->netns_ids, id)             ...\n      ...                                         ...\n      net_drop_ns()                               ...\n\tnet_free(peer)                            ...\n    }                                             ...\n  |\n  v\n  cleanup_net()\n    ...\n    (Second free of peer)\n\nAlso, put_net() on the right cpu may reorder with left's cpu\nlist_replace_init(&cleanup_list, ..), and then cleanup_list\nwill be corrupted.\n\nSince cleanup_net() is executed in worker thread, while\nput_net(peer) can happen everywhere, there should be\nenough time for concurrent get_net_ns_by_id() to pick\nthe peer up, and the race does not seem to be unlikely.\nThe patch fixes the problem in standard way.\n\n(Also, there is possible problem in peernet2id_alloc(), which requires\ncheck for net::count under nsid_lock and maybe_get_net(peer), but\nin current stable kernel it's used under rtnl_lock() and it has to be\nsafe. Openswitch begun to use peernet2id_alloc(), and possibly it should\nbe fixed too. While this is not in stable kernel yet, so I'll send\na separate message to netdev@ later).\n\nCc: Nicolas Dichtel <nicolas.dichtel@6wind.com>\nSigned-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>\nFixes: 0c7aecd4bde4 \"netns: add rtnl cmd to add and get peer netns ids\"\nReviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>\nReviewed-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>\nReviewed-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2017-12-20T17:42:22Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/21b5944350052d2583e82dd59b19a9ba94a007f0",
        "html_url": "https://github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0",
        "parents": [
            {
                "commit_id_before": "eda9873e19d83c68d0c477f6bc13718fee7a7b3c",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/eda9873e19d83c68d0c477f6bc13718fee7a7b3c",
                "html_url_before": "https://github.com/torvalds/linux/commit/eda9873e19d83c68d0c477f6bc13718fee7a7b3c"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/core/net_namespace.c"
    },
    {
        "index": 2487,
        "cve_id": "CVE-2017-15265",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c.",
        "cvss": "7.0",
        "publish_date": "October 16, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "71105998845fb012937332fe2e806d443c09e026",
        "commit_message": "ALSA: seq: Fix use-after-free at creating a port\n\nThere is a potential race window opened at creating and deleting a\nport via ioctl, as spotted by fuzzing.  snd_seq_create_port() creates\na port object and returns its pointer, but it doesn't take the\nrefcount, thus it can be deleted immediately by another thread.\nMeanwhile, snd_seq_ioctl_create_port() still calls the function\nsnd_seq_system_client_ev_port_start() with the created port object\nthat is being deleted, and this triggers use-after-free like:\n\n BUG: KASAN: use-after-free in snd_seq_ioctl_create_port+0x504/0x630 [snd_seq] at addr ffff8801f2241cb1\n =============================================================================\n BUG kmalloc-512 (Tainted: G    B          ): kasan: bad access detected\n -----------------------------------------------------------------------------\n INFO: Allocated in snd_seq_create_port+0x94/0x9b0 [snd_seq] age=1 cpu=3 pid=4511\n \t___slab_alloc+0x425/0x460\n \t__slab_alloc+0x20/0x40\n  \tkmem_cache_alloc_trace+0x150/0x190\n\tsnd_seq_create_port+0x94/0x9b0 [snd_seq]\n\tsnd_seq_ioctl_create_port+0xd1/0x630 [snd_seq]\n \tsnd_seq_do_ioctl+0x11c/0x190 [snd_seq]\n \tsnd_seq_ioctl+0x40/0x80 [snd_seq]\n \tdo_vfs_ioctl+0x54b/0xda0\n \tSyS_ioctl+0x79/0x90\n \tentry_SYSCALL_64_fastpath+0x16/0x75\n INFO: Freed in port_delete+0x136/0x1a0 [snd_seq] age=1 cpu=2 pid=4717\n \t__slab_free+0x204/0x310\n \tkfree+0x15f/0x180\n \tport_delete+0x136/0x1a0 [snd_seq]\n \tsnd_seq_delete_port+0x235/0x350 [snd_seq]\n \tsnd_seq_ioctl_delete_port+0xc8/0x180 [snd_seq]\n \tsnd_seq_do_ioctl+0x11c/0x190 [snd_seq]\n \tsnd_seq_ioctl+0x40/0x80 [snd_seq]\n \tdo_vfs_ioctl+0x54b/0xda0\n \tSyS_ioctl+0x79/0x90\n \tentry_SYSCALL_64_fastpath+0x16/0x75\n Call Trace:\n  [<ffffffff81b03781>] dump_stack+0x63/0x82\n  [<ffffffff81531b3b>] print_trailer+0xfb/0x160\n  [<ffffffff81536db4>] object_err+0x34/0x40\n  [<ffffffff815392d3>] kasan_report.part.2+0x223/0x520\n  [<ffffffffa07aadf4>] ? snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]\n  [<ffffffff815395fe>] __asan_report_load1_noabort+0x2e/0x30\n  [<ffffffffa07aadf4>] snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]\n  [<ffffffffa07aa8f0>] ? snd_seq_ioctl_delete_port+0x180/0x180 [snd_seq]\n  [<ffffffff8136be50>] ? taskstats_exit+0xbc0/0xbc0\n  [<ffffffffa07abc5c>] snd_seq_do_ioctl+0x11c/0x190 [snd_seq]\n  [<ffffffffa07abd10>] snd_seq_ioctl+0x40/0x80 [snd_seq]\n  [<ffffffff8136d433>] ? acct_account_cputime+0x63/0x80\n  [<ffffffff815b515b>] do_vfs_ioctl+0x54b/0xda0\n  .....\n\nWe may fix this in a few different ways, and in this patch, it's fixed\nsimply by taking the refcount properly at snd_seq_create_port() and\nletting the caller unref the object after use.  Also, there is another\npotential use-after-free by sprintf() call in snd_seq_create_port(),\nand this is moved inside the lock.\n\nThis fix covers CVE-2017-15265.\n\nReported-and-tested-by: Michael23 Yu <ycqzsy@gmail.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2017-10-11T07:58:18Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/71105998845fb012937332fe2e806d443c09e026",
        "html_url": "https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026",
        "parents": [
            {
                "commit_id_before": "124751d5e63c823092060074bd0abaae61aaa9c4",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/124751d5e63c823092060074bd0abaae61aaa9c4",
                "html_url_before": "https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "sound/core/seq/seq_clientmgr.c"
    },
    {
        "index": 8673,
        "cve_id": "CVE-2022-1199",
        "cwe_id": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",
        "cvss": "7.5",
        "publish_date": "August 29, 2022",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac",
        "commit_message": "ax25: Fix NULL pointer dereference in ax25_kill_by_device\n\nWhen two ax25 devices attempted to establish connection, the requester use ax25_create(),\nax25_bind() and ax25_connect() to initiate connection. The receiver use ax25_rcv() to\naccept connection and use ax25_create_cb() in ax25_rcv() to create ax25_cb, but the\nax25_cb->sk is NULL. When the receiver is detaching, a NULL pointer dereference bug\ncaused by sock_hold(sk) in ax25_kill_by_device() will happen. The corresponding\nfail log is shown below:\n\n===============================================================\nBUG: KASAN: null-ptr-deref in ax25_device_event+0xfd/0x290\nCall Trace:\n...\nax25_device_event+0xfd/0x290\nraw_notifier_call_chain+0x5e/0x70\ndev_close_many+0x174/0x220\nunregister_netdevice_many+0x1f7/0xa60\nunregister_netdevice_queue+0x12f/0x170\nunregister_netdev+0x13/0x20\nmkiss_close+0xcd/0x140\ntty_ldisc_release+0xc0/0x220\ntty_release_struct+0x17/0xa0\ntty_release+0x62d/0x670\n...\n\nThis patch add condition check in ax25_kill_by_device(). If s->sk is\nNULL, it will goto if branch to kill device.\n\nFixes: 4e0f718daf97 (\"ax25: improve the incomplete fix to avoid UAF and NPD bugs\")\nReported-by: Thomas Osterried <thomas@osterried.de>\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2022-03-09T12:45:02Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac",
        "html_url": "https://github.com/torvalds/linux/commit/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac",
        "parents": [
            {
                "commit_id_before": "c9ffa3e2bc451816ce0295e40063514fabf2bd36",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c9ffa3e2bc451816ce0295e40063514fabf2bd36",
                "html_url_before": "https://github.com/torvalds/linux/commit/c9ffa3e2bc451816ce0295e40063514fabf2bd36"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/ax25/af_ax25.c"
    },
    {
        "index": 8674,
        "cve_id": "CVE-2022-1199",
        "cwe_id": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",
        "cvss": "7.5",
        "publish_date": "August 29, 2022",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "4e0f718daf97d47cf7dec122da1be970f145c809",
        "commit_message": "ax25: improve the incomplete fix to avoid UAF and NPD bugs\n\nThe previous commit 1ade48d0c27d (\"ax25: NPD bug when detaching\nAX25 device\") introduce lock_sock() into ax25_kill_by_device to\nprevent NPD bug. But the concurrency NPD or UAF bug will occur,\nwhen lock_sock() or release_sock() dereferences the ax25_cb->sock.\n\nThe NULL pointer dereference bug can be shown as below:\n\nax25_kill_by_device()        | ax25_release()\n                             |   ax25_destroy_socket()\n                             |     ax25_cb_del()\n  ...                        |     ...\n                             |     ax25->sk=NULL;\n  lock_sock(s->sk); //(1)    |\n  s->ax25_dev = NULL;        |     ...\n  release_sock(s->sk); //(2) |\n  ...                        |\n\nThe root cause is that the sock is set to null before dereference\nsite (1) or (2). Therefore, this patch extracts the ax25_cb->sock\nin advance, and uses ax25_list_lock to protect it, which can synchronize\nwith ax25_cb_del() and ensure the value of sock is not null before\ndereference sites.\n\nThe concurrency UAF bug can be shown as below:\n\nax25_kill_by_device()        | ax25_release()\n                             |   ax25_destroy_socket()\n  ...                        |   ...\n                             |   sock_put(sk); //FREE\n  lock_sock(s->sk); //(1)    |\n  s->ax25_dev = NULL;        |   ...\n  release_sock(s->sk); //(2) |\n  ...                        |\n\nThe root cause is that the sock is released before dereference\nsite (1) or (2). Therefore, this patch uses sock_hold() to increase\nthe refcount of sock and uses ax25_list_lock to protect it, which\ncan synchronize with ax25_cb_del() in ax25_destroy_socket() and\nensure the sock wil not be released before dereference sites.\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2022-01-28T14:56:47Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/4e0f718daf97d47cf7dec122da1be970f145c809",
        "html_url": "https://github.com/torvalds/linux/commit/4e0f718daf97d47cf7dec122da1be970f145c809",
        "parents": [
            {
                "commit_id_before": "928d6fe996f69330ded6b887baf4534c5fac7988",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/928d6fe996f69330ded6b887baf4534c5fac7988",
                "html_url_before": "https://github.com/torvalds/linux/commit/928d6fe996f69330ded6b887baf4534c5fac7988"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/ax25/af_ax25.c"
    },
    {
        "index": 8196,
        "cve_id": "CVE-2022-1734",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.",
        "cvss": "7.0",
        "publish_date": "May 18, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "d270453a0d9ec10bb8a802a142fb1b3601a83098",
        "commit_message": "nfc: nfcmrvl: main: reorder destructive operations in nfcmrvl_nci_unregister_dev to avoid bugs\n\nThere are destructive operations such as nfcmrvl_fw_dnld_abort and\ngpio_free in nfcmrvl_nci_unregister_dev. The resources such as firmware,\ngpio and so on could be destructed while the upper layer functions such as\nnfcmrvl_fw_dnld_start and nfcmrvl_nci_recv_frame is executing, which leads\nto double-free, use-after-free and null-ptr-deref bugs.\n\nThere are three situations that could lead to double-free bugs.\n\nThe first situation is shown below:\n\n   (Thread 1)                 |      (Thread 2)\nnfcmrvl_fw_dnld_start         |\n ...                          |  nfcmrvl_nci_unregister_dev\n release_firmware()           |   nfcmrvl_fw_dnld_abort\n  kfree(fw) //(1)             |    fw_dnld_over\n                              |     release_firmware\n  ...                         |      kfree(fw) //(2)\n                              |     ...\n\nThe second situation is shown below:\n\n   (Thread 1)                 |      (Thread 2)\nnfcmrvl_fw_dnld_start         |\n ...                          |\n mod_timer                    |\n (wait a time)                |\n fw_dnld_timeout              |  nfcmrvl_nci_unregister_dev\n   fw_dnld_over               |   nfcmrvl_fw_dnld_abort\n    release_firmware          |    fw_dnld_over\n     kfree(fw) //(1)          |     release_firmware\n     ...                      |      kfree(fw) //(2)\n\nThe third situation is shown below:\n\n       (Thread 1)               |       (Thread 2)\nnfcmrvl_nci_recv_frame          |\n if(..->fw_download_in_progress)|\n  nfcmrvl_fw_dnld_recv_frame    |\n   queue_work                   |\n                                |\nfw_dnld_rx_work                 | nfcmrvl_nci_unregister_dev\n fw_dnld_over                   |  nfcmrvl_fw_dnld_abort\n  release_firmware              |   fw_dnld_over\n   kfree(fw) //(1)              |    release_firmware\n                                |     kfree(fw) //(2)\n\nThe firmware struct is deallocated in position (1) and deallocated\nin position (2) again.\n\nThe crash trace triggered by POC is like below:\n\nBUG: KASAN: double-free or invalid-free in fw_dnld_over\nCall Trace:\n  kfree\n  fw_dnld_over\n  nfcmrvl_nci_unregister_dev\n  nci_uart_tty_close\n  tty_ldisc_kill\n  tty_ldisc_hangup\n  __tty_hangup.part.0\n  tty_release\n  ...\n\nWhat's more, there are also use-after-free and null-ptr-deref bugs\nin nfcmrvl_fw_dnld_start. If we deallocate firmware struct, gpio or\nset null to the members of priv->fw_dnld in nfcmrvl_nci_unregister_dev,\nthen, we dereference firmware, gpio or the members of priv->fw_dnld in\nnfcmrvl_fw_dnld_start, the UAF or NPD bugs will happen.\n\nThis patch reorders destructive operations after nci_unregister_device\nin order to synchronize between cleanup routine and firmware download\nroutine.\n\nThe nci_unregister_device is well synchronized. If the device is\ndetaching, the firmware download routine will goto error. If firmware\ndownload routine is executing, nci_unregister_device will wait until\nfirmware download routine is finished.\n\nFixes: 3194c6870158 (\"NFC: nfcmrvl: add firmware download support\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2022-05-01T12:26:05Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/d270453a0d9ec10bb8a802a142fb1b3601a83098",
        "html_url": "https://github.com/torvalds/linux/commit/d270453a0d9ec10bb8a802a142fb1b3601a83098",
        "parents": [
            {
                "commit_id_before": "da5c0f119203ad9728920456a0f52a6d850c01cd",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/da5c0f119203ad9728920456a0f52a6d850c01cd",
                "html_url_before": "https://github.com/torvalds/linux/commit/da5c0f119203ad9728920456a0f52a6d850c01cd"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/nfc/nfcmrvl/main.c"
    },
    {
        "index": 10285,
        "cve_id": "CVE-2022-41858",
        "cwe_id": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the Linux kernel. A NULL pointer dereference may occur while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c. This issue could allow an attacker to crash the system or leak internal kernel information.",
        "cvss": "7.1",
        "publish_date": "January 17, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "ec4eb8a86ade4d22633e1da2a7d85a846b7d1798",
        "commit_message": "drivers: net: slip: fix NPD bug in sl_tx_timeout()\n\nWhen a slip driver is detaching, the slip_close() will act to\ncleanup necessary resources and sl->tty is set to NULL in\nslip_close(). Meanwhile, the packet we transmit is blocked,\nsl_tx_timeout() will be called. Although slip_close() and\nsl_tx_timeout() use sl->lock to synchronize, we don`t judge\nwhether sl->tty equals to NULL in sl_tx_timeout() and the\nnull pointer dereference bug will happen.\n\n   (Thread 1)                 |      (Thread 2)\n                              | slip_close()\n                              |   spin_lock_bh(&sl->lock)\n                              |   ...\n...                           |   sl->tty = NULL //(1)\nsl_tx_timeout()               |   spin_unlock_bh(&sl->lock)\n  spin_lock(&sl->lock);       |\n  ...                         |   ...\n  tty_chars_in_buffer(sl->tty)|\n    if (tty->ops->..) //(2)   |\n    ...                       |   synchronize_rcu()\n\nWe set NULL to sl->tty in position (1) and dereference sl->tty\nin position (2).\n\nThis patch adds check in sl_tx_timeout(). If sl->tty equals to\nNULL, sl_tx_timeout() will goto out.\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nReviewed-by: Jiri Slaby <jirislaby@kernel.org>\nLink: https://lore.kernel.org/r/20220405132206.55291-1-duoming@zju.edu.cn\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
        "commit_date": "2022-04-07T06:00:16Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798",
        "html_url": "https://github.com/torvalds/linux/commit/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798",
        "parents": [
            {
                "commit_id_before": "8e9d0d7a76c556e8b73289555950917db13d2077",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/8e9d0d7a76c556e8b73289555950917db13d2077",
                "html_url_before": "https://github.com/torvalds/linux/commit/8e9d0d7a76c556e8b73289555950917db13d2077"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/net/slip/slip.c"
    },
    {
        "index": 9257,
        "cve_id": "CVE-2022-42703",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "mm/rmap.c in the Linux kernel before 5.19.7 has a use-after-free related to leaf anon_vma double reuse.",
        "cvss": "5.5",
        "publish_date": "October 9, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "2555283eb40df89945557273121e9393ef9b542b",
        "commit_message": "mm/rmap: Fix anon_vma->degree ambiguity leading to double-reuse\n\nanon_vma->degree tracks the combined number of child anon_vmas and VMAs\nthat use the anon_vma as their ->anon_vma.\n\nanon_vma_clone() then assumes that for any anon_vma attached to\nsrc->anon_vma_chain other than src->anon_vma, it is impossible for it to\nbe a leaf node of the VMA tree, meaning that for such VMAs ->degree is\nelevated by 1 because of a child anon_vma, meaning that if ->degree\nequals 1 there are no VMAs that use the anon_vma as their ->anon_vma.\n\nThis assumption is wrong because the ->degree optimization leads to leaf\nnodes being abandoned on anon_vma_clone() - an existing anon_vma is\nreused and no new parent-child relationship is created.  So it is\npossible to reuse an anon_vma for one VMA while it is still tied to\nanother VMA.\n\nThis is an issue because is_mergeable_anon_vma() and its callers assume\nthat if two VMAs have the same ->anon_vma, the list of anon_vmas\nattached to the VMAs is guaranteed to be the same.  When this assumption\nis violated, vma_merge() can merge pages into a VMA that is not attached\nto the corresponding anon_vma, leading to dangling page->mapping\npointers that will be dereferenced during rmap walks.\n\nFix it by separately tracking the number of child anon_vmas and the\nnumber of VMAs using the anon_vma as their ->anon_vma.\n\nFixes: 7a3ef208e662 (\"mm: prevent endless growth of anon_vma hierarchy\")\nCc: stable@kernel.org\nAcked-by: Michal Hocko <mhocko@suse.com>\nAcked-by: Vlastimil Babka <vbabka@suse.cz>\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2022-08-31T22:45:10Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/2555283eb40df89945557273121e9393ef9b542b",
        "html_url": "https://github.com/torvalds/linux/commit/2555283eb40df89945557273121e9393ef9b542b",
        "parents": [
            {
                "commit_id_before": "c5e4d5e99162ba8025d58a3af7ad103f155d2df7",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c5e4d5e99162ba8025d58a3af7ad103f155d2df7",
                "html_url_before": "https://github.com/torvalds/linux/commit/c5e4d5e99162ba8025d58a3af7ad103f155d2df7"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "mm/rmap.c"
    },
    {
        "index": 9917,
        "cve_id": "CVE-2022-47939",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. fs/ksmbd/smb2pdu.c has a use-after-free and OOPS for SMB2_TREE_DISCONNECT.",
        "cvss": "9.8",
        "publish_date": "December 23, 2022",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "cf6531d98190fa2cf92a6d8bbc8af0a4740a223c",
        "commit_message": "ksmbd: fix use-after-free bug in smb2_tree_disconect\n\nsmb2_tree_disconnect() freed the struct ksmbd_tree_connect,\nbut it left the dangling pointer. It can be accessed\nagain under compound requests.\n\nThis bug can lead an oops looking something link:\n\n[ 1685.468014 ] BUG: KASAN: use-after-free in ksmbd_tree_conn_disconnect+0x131/0x160 [ksmbd]\n[ 1685.468068 ] Read of size 4 at addr ffff888102172180 by task kworker/1:2/4807\n...\n[ 1685.468130 ] Call Trace:\n[ 1685.468132 ]  <TASK>\n[ 1685.468135 ]  dump_stack_lvl+0x49/0x5f\n[ 1685.468141 ]  print_report.cold+0x5e/0x5cf\n[ 1685.468145 ]  ? ksmbd_tree_conn_disconnect+0x131/0x160 [ksmbd]\n[ 1685.468157 ]  kasan_report+0xaa/0x120\n[ 1685.468194 ]  ? ksmbd_tree_conn_disconnect+0x131/0x160 [ksmbd]\n[ 1685.468206 ]  __asan_report_load4_noabort+0x14/0x20\n[ 1685.468210 ]  ksmbd_tree_conn_disconnect+0x131/0x160 [ksmbd]\n[ 1685.468222 ]  smb2_tree_disconnect+0x175/0x250 [ksmbd]\n[ 1685.468235 ]  handle_ksmbd_work+0x30e/0x1020 [ksmbd]\n[ 1685.468247 ]  process_one_work+0x778/0x11c0\n[ 1685.468251 ]  ? _raw_spin_lock_irq+0x8e/0xe0\n[ 1685.468289 ]  worker_thread+0x544/0x1180\n[ 1685.468293 ]  ? __cpuidle_text_end+0x4/0x4\n[ 1685.468297 ]  kthread+0x282/0x320\n[ 1685.468301 ]  ? process_one_work+0x11c0/0x11c0\n[ 1685.468305 ]  ? kthread_complete_and_exit+0x30/0x30\n[ 1685.468309 ]  ret_from_fork+0x1f/0x30\n\nFixes: e2f34481b24d (\"cifsd: add server-side procedures for SMB3\")\nCc: stable@vger.kernel.org\nReported-by: zdi-disclosures@trendmicro.com # ZDI-CAN-17816\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>\nReviewed-by: Hyunchul Lee <hyc.lee@gmail.com>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
        "commit_date": "2022-08-01T04:14:32Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/cf6531d98190fa2cf92a6d8bbc8af0a4740a223c",
        "html_url": "https://github.com/torvalds/linux/commit/cf6531d98190fa2cf92a6d8bbc8af0a4740a223c",
        "parents": [
            {
                "commit_id_before": "aa7253c2393f6dcd6a1468b0792f6da76edad917",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/aa7253c2393f6dcd6a1468b0792f6da76edad917",
                "html_url_before": "https://github.com/torvalds/linux/commit/aa7253c2393f6dcd6a1468b0792f6da76edad917"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "fs/ksmbd/smb2pdu.c"
    },
    {
        "index": 10148,
        "cve_id": "CVE-2023-0266",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel.\u00a0SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit\u00a056b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "cvss": "7.8",
        "publish_date": "January 30, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "becf9e5d553c2389d857a3c178ce80fdb34a02e1",
        "commit_message": "ALSA: control: code refactoring for ELEM_READ/ELEM_WRITE operations\n\nALSA control core handles ELEM_READ/ELEM_WRITE requests within lock\nacquisition of a counting semaphore. The lock is acquired in helper\nfunctions in the end of call path before calling implementations of each\ndriver.\n\nioctl(2) with SNDRV_CTL_ELEM_READ\n...\n->snd_ctl_ioctl()\n  ->snd_ctl_elem_read_user()\n    ->snd_ctl_elem_read()\n      ->down_read(controls_rwsem)\n      ->snd_ctl_find_id()\n      ->struct snd_kcontrol.get()\n      ->up_read(controls_rwsem)\n\nioctl(2) with SNDRV_CTL_ELEM_WRITE\n...\n->snd_ctl_ioctl()\n  ->snd_ctl_elem_write_user()\n    ->snd_ctl_elem_write()\n      ->down_read(controls_rwsem)\n      ->snd_ctl_find_id()\n      ->struct snd_kcontrol.put()\n      ->up_read(controls_rwsem)\n\nThis commit moves the lock acquisition to middle of the call graph to\nsimplify the helper functions. As a result:\n\nioctl(2) with SNDRV_CTL_ELEM_READ\n...\n->snd_ctl_ioctl()\n  ->snd_ctl_elem_read_user()\n    ->down_read(controls_rwsem)\n    ->snd_ctl_elem_read()\n      ->snd_ctl_find_id()\n      ->struct snd_kcontrol.get()\n    ->up_read(controls_rwsem)\n\nioctl(2) with SNDRV_CTL_ELEM_WRITE\n...\n->snd_ctl_ioctl()\n  ->snd_ctl_elem_write_user()\n    ->down_read(controls_rwsem)\n    ->snd_ctl_elem_write()\n      ->snd_ctl_find_id()\n      ->struct snd_kcontrol.put()\n    ->up_read(controls_rwsem)\n\nSigned-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2017-08-20T07:39:54Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/becf9e5d553c2389d857a3c178ce80fdb34a02e1",
        "html_url": "https://github.com/torvalds/linux/commit/becf9e5d553c2389d857a3c178ce80fdb34a02e1",
        "parents": [
            {
                "commit_id_before": "7b42cfafdcbf73bd58687cbe3157b9ca4a0fd2e5",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/7b42cfafdcbf73bd58687cbe3157b9ca4a0fd2e5",
                "html_url_before": "https://github.com/torvalds/linux/commit/7b42cfafdcbf73bd58687cbe3157b9ca4a0fd2e5"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "sound/core/control.c"
    },
    {
        "index": 10149,
        "cve_id": "CVE-2023-0266",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel.\u00a0SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit\u00a056b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "cvss": "7.8",
        "publish_date": "January 30, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "56b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "commit_message": "ALSA: pcm: Move rwsem lock inside snd_ctl_elem_read to prevent UAF\n\nTakes rwsem lock inside snd_ctl_elem_read instead of snd_ctl_elem_read_user\nlike it was done for write in commit 1fa4445f9adf1 (\"ALSA: control - introduce\nsnd_ctl_notify_one() helper\"). Doing this way we are also fixing the following\nlocking issue happening in the compat path which can be easily triggered and\nturned into an use-after-free.\n\n64-bits:\nsnd_ctl_ioctl\n  snd_ctl_elem_read_user\n    [takes controls_rwsem]\n    snd_ctl_elem_read [lock properly held, all good]\n    [drops controls_rwsem]\n\n32-bits:\nsnd_ctl_ioctl_compat\n  snd_ctl_elem_write_read_compat\n    ctl_elem_write_read\n      snd_ctl_elem_read [missing lock, not good]\n\nCVE-2023-0266 was assigned for this issue.\n\nCc: stable@kernel.org # 5.13+\nSigned-off-by: Clement Lecigne <clecigne@google.com>\nReviewed-by: Jaroslav Kysela <perex@perex.cz>\nLink: https://lore.kernel.org/r/20230113120745.25464-1-tiwai@suse.de\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2023-01-13T13:15:26Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/56b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "html_url": "https://github.com/torvalds/linux/commit/56b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "parents": [
            {
                "commit_id_before": "92a9c0ad86d47ff4cce899012e355c400f02cfb8",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/92a9c0ad86d47ff4cce899012e355c400f02cfb8",
                "html_url_before": "https://github.com/torvalds/linux/commit/92a9c0ad86d47ff4cce899012e355c400f02cfb8"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "sound/core/control.c"
    },
    {
        "index": 11098,
        "cve_id": "CVE-2023-1118",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
        "cvss": "7.8",
        "publish_date": "March 2, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "29b0589a865b6f66d141d79b2dd1373e4e50fe17",
        "commit_message": "media: rc: Fix use-after-free bugs caused by ene_tx_irqsim()\n\nWhen the ene device is detaching, function ene_remove() will\nbe called. But there is no function to cancel tx_sim_timer\nin ene_remove(), the timer handler ene_tx_irqsim() could race\nwith ene_remove(). As a result, the UAF bugs could happen,\nthe process is shown below.\n\n    (cleanup routine)          |        (timer routine)\n                               | mod_timer(&dev->tx_sim_timer, ..)\nene_remove()                   | (wait a time)\n                               | ene_tx_irqsim()\n                               |   dev->hw_lock //USE\n                               |   ene_tx_sample(dev) //USE\n\nFix by adding del_timer_sync(&dev->tx_sim_timer) in ene_remove(),\nThe tx_sim_timer could stop before ene device is deallocated.\n\nWhat's more, The rc_unregister_device() and del_timer_sync()\nshould be called first in ene_remove() and the deallocated\nfunctions such as free_irq(), release_region() and so on\nshould be called behind them. Because the rc_unregister_device()\nis well synchronized. Otherwise, race conditions may happen. The\nsituations that may lead to race conditions are shown below.\n\nFirstly, the rx receiver is disabled with ene_rx_disable()\nbefore rc_unregister_device() in ene_remove(), which means it\ncan be enabled again if a process opens /dev/lirc0 between\nene_rx_disable() and rc_unregister_device().\n\nSecondly, the irqaction descriptor is freed by free_irq()\nbefore the rc device is unregistered, which means irqaction\ndescriptor may be accessed again after it is deallocated.\n\nThirdly, the timer can call ene_tx_sample() that can write\nto the io ports, which means the io ports could be accessed\nagain after they are deallocated by release_region().\n\nTherefore, the rc_unregister_device() and del_timer_sync()\nshould be called first in ene_remove().\n\nSuggested by: Sean Young <sean@mess.org>\n\nFixes: 9ea53b74df9c (\"V4L/DVB: STAGING: remove lirc_ene0100 driver\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: Sean Young <sean@mess.org>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>",
        "commit_date": "2023-02-08T06:49:22Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/29b0589a865b6f66d141d79b2dd1373e4e50fe17",
        "html_url": "https://github.com/torvalds/linux/commit/29b0589a865b6f66d141d79b2dd1373e4e50fe17",
        "parents": [
            {
                "commit_id_before": "30040818b338b8ebc956ce0ebd198f8d593586a6",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/30040818b338b8ebc956ce0ebd198f8d593586a6",
                "html_url_before": "https://github.com/torvalds/linux/commit/30040818b338b8ebc956ce0ebd198f8d593586a6"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/media/rc/ene_ir.c"
    },
    {
        "index": 11490,
        "cve_id": "CVE-2023-1195",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in reconn_set_ipaddr_from_hostname in fs/cifs/connect.c in the Linux kernel. The issue occurs when it forgets to set the free pointer server->hostname to NULL, leading to an invalid pointer request.",
        "cvss": "5.5",
        "publish_date": "May 18, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "153695d36ead0ccc4d0256953c751cabf673e621",
        "commit_message": "cifs: fix use-after-free caused by invalid pointer `hostname`\n\n`hostname` needs to be set as null-pointer after free in\n`cifs_put_tcp_session` function, or when `cifsd` thread attempts\nto resolve hostname and reconnect the host, the thread would deref\nthe invalid pointer.\n\nHere is one of practical backtrace examples as reference:\n\nTask 477\n---------------------------\n do_mount\n  path_mount\n   do_new_mount\n    vfs_get_tree\n     smb3_get_tree\n      smb3_get_tree_common\n       cifs_smb3_do_mount\n        cifs_mount\n         mount_put_conns\n          cifs_put_tcp_session\n          --> kfree(server->hostname)\n\ncifsd\n---------------------------\n kthread\n  cifs_demultiplex_thread\n   cifs_reconnect\n    reconn_set_ipaddr_from_hostname\n    --> if (!server->hostname)\n    --> if (server->hostname[0] == '\\0')  // !! UAF fault here\n\nCIFS: VFS: cifs_mount failed w/return code = -112\nmount error(112): Host is down\nBUG: KASAN: use-after-free in reconn_set_ipaddr_from_hostname+0x2ba/0x310\nRead of size 1 at addr ffff888108f35380 by task cifsd/480\nCPU: 2 PID: 480 Comm: cifsd Not tainted 6.1.0-rc2-00106-gf705792f89dd-dirty #25\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x68/0x85\n print_report+0x16c/0x4a3\n kasan_report+0x95/0x190\n reconn_set_ipaddr_from_hostname+0x2ba/0x310\n __cifs_reconnect.part.0+0x241/0x800\n cifs_reconnect+0x65f/0xb60\n cifs_demultiplex_thread+0x1570/0x2570\n kthread+0x2c5/0x380\n ret_from_fork+0x22/0x30\n </TASK>\nAllocated by task 477:\n kasan_save_stack+0x1e/0x40\n kasan_set_track+0x21/0x30\n __kasan_kmalloc+0x7e/0x90\n __kmalloc_node_track_caller+0x52/0x1b0\n kstrdup+0x3b/0x70\n cifs_get_tcp_session+0xbc/0x19b0\n mount_get_conns+0xa9/0x10c0\n cifs_mount+0xdf/0x1970\n cifs_smb3_do_mount+0x295/0x1660\n smb3_get_tree+0x352/0x5e0\n vfs_get_tree+0x8e/0x2e0\n path_mount+0xf8c/0x1990\n do_mount+0xee/0x110\n __x64_sys_mount+0x14b/0x1f0\n do_syscall_64+0x3b/0x90\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nFreed by task 477:\n kasan_save_stack+0x1e/0x40\n kasan_set_track+0x21/0x30\n kasan_save_free_info+0x2a/0x50\n __kasan_slab_free+0x10a/0x190\n __kmem_cache_free+0xca/0x3f0\n cifs_put_tcp_session+0x30c/0x450\n cifs_mount+0xf95/0x1970\n cifs_smb3_do_mount+0x295/0x1660\n smb3_get_tree+0x352/0x5e0\n vfs_get_tree+0x8e/0x2e0\n path_mount+0xf8c/0x1990\n do_mount+0xee/0x110\n __x64_sys_mount+0x14b/0x1f0\n do_syscall_64+0x3b/0x90\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nThe buggy address belongs to the object at ffff888108f35380\n which belongs to the cache kmalloc-16 of size 16\nThe buggy address is located 0 bytes inside of\n 16-byte region [ffff888108f35380, ffff888108f35390)\nThe buggy address belongs to the physical page:\npage:00000000333f8e58 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888108f350e0 pfn:0x108f35\nflags: 0x200000000000200(slab|node=0|zone=2)\nraw: 0200000000000200 0000000000000000 dead000000000122 ffff8881000423c0\nraw: ffff888108f350e0 000000008080007a 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\nMemory state around the buggy address:\n ffff888108f35280: fa fb fc fc fa fb fc fc fa fb fc fc fa fb fc fc\n ffff888108f35300: fa fb fc fc fa fb fc fc fa fb fc fc fa fb fc fc\n>ffff888108f35380: fa fb fc fc fa fb fc fc fa fb fc fc fa fb fc fc\n                   ^\n ffff888108f35400: fa fb fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff888108f35480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n\nFixes: 7be3248f3139 (\"cifs: To match file servers, make sure the server hostname matches\")\nSigned-off-by: Zeng Heng <zengheng4@huawei.com>\nReviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
        "commit_date": "2022-10-28T04:59:13Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/153695d36ead0ccc4d0256953c751cabf673e621",
        "html_url": "https://github.com/torvalds/linux/commit/153695d36ead0ccc4d0256953c751cabf673e621",
        "parents": [
            {
                "commit_id_before": "f950c85e782f90702468bba8243cc97a8d0d04b0",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f950c85e782f90702468bba8243cc97a8d0d04b0",
                "html_url_before": "https://github.com/torvalds/linux/commit/f950c85e782f90702468bba8243cc97a8d0d04b0"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "fs/cifs/connect.c"
    },
    {
        "index": 11333,
        "cve_id": "CVE-2023-1855",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in xgene_hwmon_remove in drivers/hwmon/xgene-hwmon.c in the Hardware Monitoring Linux Kernel Driver (xgene-hwmon). This flaw could allow a local attacker to crash the system due to a race problem. This vulnerability could even lead to a kernel information leak problem.",
        "cvss": "6.3",
        "publish_date": "April 5, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "cb090e64cf25602b9adaf32d5dfc9c8bec493cd1",
        "commit_message": "hwmon: (xgene) Fix use after free bug in xgene_hwmon_remove due to race condition\n\nIn xgene_hwmon_probe, &ctx->workq is bound with xgene_hwmon_evt_work.\nThen it will be started.\n\nIf we remove the driver which will call xgene_hwmon_remove to clean up,\nthere may be unfinished work.\n\nThe possible sequence is as follows:\n\nFix it by finishing the work before cleanup in xgene_hwmon_remove.\n\nCPU0                  CPU1\n\n                    |xgene_hwmon_evt_work\nxgene_hwmon_remove   |\nkfifo_free(&ctx->async_msg_fifo);|\n                    |\n                    |kfifo_out_spinlocked\n                    |//use &ctx->async_msg_fifo\nFixes: 2ca492e22cb7 (\"hwmon: (xgene) Fix crash when alarm occurs before driver probe\")\nSigned-off-by: Zheng Wang <zyytlz.wz@163.com>\nLink: https://lore.kernel.org/r/20230310084007.1403388-1-zyytlz.wz@163.com\nSigned-off-by: Guenter Roeck <linux@roeck-us.net>",
        "commit_date": "2023-03-12T18:13:25Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/cb090e64cf25602b9adaf32d5dfc9c8bec493cd1",
        "html_url": "https://github.com/torvalds/linux/commit/cb090e64cf25602b9adaf32d5dfc9c8bec493cd1",
        "parents": [
            {
                "commit_id_before": "48e8186870d9d0902e712d601ccb7098cb220688",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/48e8186870d9d0902e712d601ccb7098cb220688",
                "html_url_before": "https://github.com/torvalds/linux/commit/48e8186870d9d0902e712d601ccb7098cb220688"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/hwmon/xgene-hwmon.c"
    },
    {
        "index": 11625,
        "cve_id": "CVE-2023-3439",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the MCTP protocol in the Linux kernel. The function mctp_unregister() reclaims the device's relevant resource when a netcard detaches. However, a running routine may be unaware of this and cause the use-after-free of the mdev->addrs object, potentially leading to a denial of service.",
        "cvss": "4.7",
        "publish_date": "June 28, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "b561275d633bcd8e0e8055ab86f1a13df75a0269",
        "commit_message": "mctp: defer the kfree of object mdev->addrs\n\nThe function mctp_unregister() reclaims the device's relevant resource\nwhen a netcard detaches. However, a running routine may be unaware of\nthis and cause the use-after-free of the mdev->addrs object.\n\nThe race condition can be demonstrated below\n\n cleanup thread               another thread\n                          |\nunregister_netdev()       |  mctp_sendmsg()\n...                       |    ...\n  mctp_unregister()       |    rt = mctp_route_lookup()\n    ...                   |    mctl_local_output()\n    kfree(mdev->addrs)    |      ...\n                          |      saddr = rt->dev->addrs[0];\n                          |\n\nAn attacker can adopt the (recent provided) mtcpserial driver with pty\nto fake the device detaching and use the userfaultfd to increase the\nrace success chance (in mctp_sendmsg). The KASan report for such a POC\nis shown below:\n\n[   86.051955] ==================================================================\n[   86.051955] BUG: KASAN: use-after-free in mctp_local_output+0x4e9/0xb7d\n[   86.051955] Read of size 1 at addr ffff888005f298c0 by task poc/295\n[   86.051955]\n[   86.051955] Call Trace:\n[   86.051955]  <TASK>\n[   86.051955]  dump_stack_lvl+0x33/0x42\n[   86.051955]  print_report.cold.13+0xb2/0x6b3\n[   86.051955]  ? preempt_schedule_irq+0x57/0x80\n[   86.051955]  ? mctp_local_output+0x4e9/0xb7d\n[   86.051955]  kasan_report+0xa5/0x120\n[   86.051955]  ? mctp_local_output+0x4e9/0xb7d\n[   86.051955]  mctp_local_output+0x4e9/0xb7d\n[   86.051955]  ? mctp_dev_set_key+0x79/0x79\n[   86.051955]  ? copyin+0x38/0x50\n[   86.051955]  ? _copy_from_iter+0x1b6/0xf20\n[   86.051955]  ? sysvec_apic_timer_interrupt+0x97/0xb0\n[   86.051955]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20\n[   86.051955]  ? mctp_local_output+0x1/0xb7d\n[   86.051955]  mctp_sendmsg+0x64d/0xdb0\n[   86.051955]  ? mctp_sk_close+0x20/0x20\n[   86.051955]  ? __fget_light+0x2fd/0x4f0\n[   86.051955]  ? mctp_sk_close+0x20/0x20\n[   86.051955]  sock_sendmsg+0xdd/0x110\n[   86.051955]  __sys_sendto+0x1cc/0x2a0\n[   86.051955]  ? __ia32_sys_getpeername+0xa0/0xa0\n[   86.051955]  ? new_sync_write+0x335/0x550\n[   86.051955]  ? alloc_file+0x22f/0x500\n[   86.051955]  ? __ip_do_redirect+0x820/0x1820\n[   86.051955]  ? vfs_write+0x44d/0x7b0\n[   86.051955]  ? vfs_write+0x44d/0x7b0\n[   86.051955]  ? fput_many+0x15/0x120\n[   86.051955]  ? ksys_write+0x155/0x1b0\n[   86.051955]  ? __ia32_sys_read+0xa0/0xa0\n[   86.051955]  __x64_sys_sendto+0xd8/0x1b0\n[   86.051955]  ? exit_to_user_mode_prepare+0x2f/0x120\n[   86.051955]  ? syscall_exit_to_user_mode+0x12/0x20\n[   86.051955]  do_syscall_64+0x3a/0x80\n[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[   86.051955] RIP: 0033:0x7f82118a56b3\n[   86.051955] RSP: 002b:00007ffdb154b110 EFLAGS: 00000293 ORIG_RAX: 000000000000002c\n[   86.051955] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f82118a56b3\n[   86.051955] RDX: 0000000000000010 RSI: 00007f8211cd4000 RDI: 0000000000000007\n[   86.051955] RBP: 00007ffdb154c1d0 R08: 00007ffdb154b164 R09: 000000000000000c\n[   86.051955] R10: 0000000000000000 R11: 0000000000000293 R12: 000055d779800db0\n[   86.051955] R13: 00007ffdb154c2b0 R14: 0000000000000000 R15: 0000000000000000\n[   86.051955]  </TASK>\n[   86.051955]\n[   86.051955] Allocated by task 295:\n[   86.051955]  kasan_save_stack+0x1c/0x40\n[   86.051955]  __kasan_kmalloc+0x84/0xa0\n[   86.051955]  mctp_rtm_newaddr+0x242/0x610\n[   86.051955]  rtnetlink_rcv_msg+0x2fd/0x8b0\n[   86.051955]  netlink_rcv_skb+0x11c/0x340\n[   86.051955]  netlink_unicast+0x439/0x630\n[   86.051955]  netlink_sendmsg+0x752/0xc00\n[   86.051955]  sock_sendmsg+0xdd/0x110\n[   86.051955]  __sys_sendto+0x1cc/0x2a0\n[   86.051955]  __x64_sys_sendto+0xd8/0x1b0\n[   86.051955]  do_syscall_64+0x3a/0x80\n[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[   86.051955]\n[   86.051955] Freed by task 301:\n[   86.051955]  kasan_save_stack+0x1c/0x40\n[   86.051955]  kasan_set_track+0x21/0x30\n[   86.051955]  kasan_set_free_info+0x20/0x30\n[   86.051955]  __kasan_slab_free+0x104/0x170\n[   86.051955]  kfree+0x8c/0x290\n[   86.051955]  mctp_dev_notify+0x161/0x2c0\n[   86.051955]  raw_notifier_call_chain+0x8b/0xc0\n[   86.051955]  unregister_netdevice_many+0x299/0x1180\n[   86.051955]  unregister_netdevice_queue+0x210/0x2f0\n[   86.051955]  unregister_netdev+0x13/0x20\n[   86.051955]  mctp_serial_close+0x6d/0xa0\n[   86.051955]  tty_ldisc_kill+0x31/0xa0\n[   86.051955]  tty_ldisc_hangup+0x24f/0x560\n[   86.051955]  __tty_hangup.part.28+0x2ce/0x6b0\n[   86.051955]  tty_release+0x327/0xc70\n[   86.051955]  __fput+0x1df/0x8b0\n[   86.051955]  task_work_run+0xca/0x150\n[   86.051955]  exit_to_user_mode_prepare+0x114/0x120\n[   86.051955]  syscall_exit_to_user_mode+0x12/0x20\n[   86.051955]  do_syscall_64+0x46/0x80\n[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[   86.051955]\n[   86.051955] The buggy address belongs to the object at ffff888005f298c0\n[   86.051955]  which belongs to the cache kmalloc-8 of size 8\n[   86.051955] The buggy address is located 0 bytes inside of\n[   86.051955]  8-byte region [ffff888005f298c0, ffff888005f298c8)\n[   86.051955]\n[   86.051955] The buggy address belongs to the physical page:\n[   86.051955] flags: 0x100000000000200(slab|node=0|zone=1)\n[   86.051955] raw: 0100000000000200 dead000000000100 dead000000000122 ffff888005c42280\n[   86.051955] raw: 0000000000000000 0000000080660066 00000001ffffffff 0000000000000000\n[   86.051955] page dumped because: kasan: bad access detected\n[   86.051955]\n[   86.051955] Memory state around the buggy address:\n[   86.051955]  ffff888005f29780: 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00\n[   86.051955]  ffff888005f29800: fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc\n[   86.051955] >ffff888005f29880: fc fc fc fb fc fc fc fc fa fc fc fc fc fa fc fc\n[   86.051955]                                            ^\n[   86.051955]  ffff888005f29900: fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc\n[   86.051955]  ffff888005f29980: fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc\n[   86.051955] ==================================================================\n\nTo this end, just like the commit e04480920d1e (\"Bluetooth: defer\ncleanup of resources in hci_unregister_dev()\")  this patch defers the\ndestructive kfree(mdev->addrs) in mctp_unregister to the mctp_dev_put,\nwhere the refcount of mdev is zero and the entire device is reclaimed.\nThis prevents the use-after-free because the sendmsg thread holds the\nreference of mdev in the mctp_route object.\n\nFixes: 583be982d934 (mctp: Add device handling and netlink interface)\nSigned-off-by: Lin Ma <linma@zju.edu.cn>\nAcked-by: Jeremy Kerr <jk@codeconstruct.com.au>\nLink: https://lore.kernel.org/r/20220422114340.32346-1-linma@zju.edu.cn\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
        "commit_date": "2022-04-26T07:14:47Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/b561275d633bcd8e0e8055ab86f1a13df75a0269",
        "html_url": "https://github.com/torvalds/linux/commit/b561275d633bcd8e0e8055ab86f1a13df75a0269",
        "parents": [
            {
                "commit_id_before": "c3e8d5a40685aed49d736a24f4d2b9e7607771f0",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c3e8d5a40685aed49d736a24f4d2b9e7607771f0",
                "html_url_before": "https://github.com/torvalds/linux/commit/c3e8d5a40685aed49d736a24f4d2b9e7607771f0"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/mctp/device.c"
    },
    {
        "index": 11891,
        "cve_id": "CVE-2023-3863",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.",
        "cvss": "4.1",
        "publish_date": "July 24, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "HIGH",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "NONE",
        "commit_id": "6709d4b7bc2e079241fdef15d1160581c5261c10",
        "commit_message": "net: nfc: Fix use-after-free caused by nfc_llcp_find_local\n\nThis commit fixes several use-after-free that caused by function\nnfc_llcp_find_local(). For example, one UAF can happen when below buggy\ntime window occurs.\n\n// nfc_genl_llc_get_params   | // nfc_unregister_device\n                             |\ndev = nfc_get_device(idx);   | device_lock(...)\nif (!dev)                    | dev->shutting_down = true;\n    return -ENODEV;          | device_unlock(...);\n                             |\ndevice_lock(...);            |   // nfc_llcp_unregister_device\n                             |   nfc_llcp_find_local()\nnfc_llcp_find_local(...);    |\n                             |   local_cleanup()\nif (!local) {                |\n    rc = -ENODEV;            |     // nfc_llcp_local_put\n    goto exit;               |     kref_put(.., local_release)\n}                            |\n                             |       // local_release\n                             |       list_del(&local->list)\n  // nfc_genl_send_params    |       kfree()\n  local->dev->idx !!!UAF!!!  |\n                             |\n\nand the crash trace for the one of the discussed UAF like:\n\nBUG: KASAN: slab-use-after-free in nfc_genl_llc_get_params+0x72f/0x780  net/nfc/netlink.c:1045\nRead of size 8 at addr ffff888105b0e410 by task 20114\n\nCall Trace:\n <TASK>\n __dump_stack  lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x72/0xa0  lib/dump_stack.c:106\n print_address_description  mm/kasan/report.c:319 [inline]\n print_report+0xcc/0x620  mm/kasan/report.c:430\n kasan_report+0xb2/0xe0  mm/kasan/report.c:536\n nfc_genl_send_params  net/nfc/netlink.c:999 [inline]\n nfc_genl_llc_get_params+0x72f/0x780  net/nfc/netlink.c:1045\n genl_family_rcv_msg_doit.isra.0+0x1ee/0x2e0  net/netlink/genetlink.c:968\n genl_family_rcv_msg  net/netlink/genetlink.c:1048 [inline]\n genl_rcv_msg+0x503/0x7d0  net/netlink/genetlink.c:1065\n netlink_rcv_skb+0x161/0x430  net/netlink/af_netlink.c:2548\n genl_rcv+0x28/0x40  net/netlink/genetlink.c:1076\n netlink_unicast_kernel  net/netlink/af_netlink.c:1339 [inline]\n netlink_unicast+0x644/0x900  net/netlink/af_netlink.c:1365\n netlink_sendmsg+0x934/0xe70  net/netlink/af_netlink.c:1913\n sock_sendmsg_nosec  net/socket.c:724 [inline]\n sock_sendmsg+0x1b6/0x200  net/socket.c:747\n ____sys_sendmsg+0x6e9/0x890  net/socket.c:2501\n ___sys_sendmsg+0x110/0x1b0  net/socket.c:2555\n __sys_sendmsg+0xf7/0x1d0  net/socket.c:2584\n do_syscall_x64  arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3f/0x90  arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\nRIP: 0033:0x7f34640a2389\nRSP: 002b:00007f3463415168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007f34641c1f80 RCX: 00007f34640a2389\nRDX: 0000000000000000 RSI: 0000000020000240 RDI: 0000000000000006\nRBP: 00007f34640ed493 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007ffe38449ecf R14: 00007f3463415300 R15: 0000000000022000\n </TASK>\n\nAllocated by task 20116:\n kasan_save_stack+0x22/0x50  mm/kasan/common.c:45\n kasan_set_track+0x25/0x30  mm/kasan/common.c:52\n ____kasan_kmalloc  mm/kasan/common.c:374 [inline]\n __kasan_kmalloc+0x7f/0x90  mm/kasan/common.c:383\n kmalloc  include/linux/slab.h:580 [inline]\n kzalloc  include/linux/slab.h:720 [inline]\n nfc_llcp_register_device+0x49/0xa40  net/nfc/llcp_core.c:1567\n nfc_register_device+0x61/0x260  net/nfc/core.c:1124\n nci_register_device+0x776/0xb20  net/nfc/nci/core.c:1257\n virtual_ncidev_open+0x147/0x230  drivers/nfc/virtual_ncidev.c:148\n misc_open+0x379/0x4a0  drivers/char/misc.c:165\n chrdev_open+0x26c/0x780  fs/char_dev.c:414\n do_dentry_open+0x6c4/0x12a0  fs/open.c:920\n do_open  fs/namei.c:3560 [inline]\n path_openat+0x24fe/0x37e0  fs/namei.c:3715\n do_filp_open+0x1ba/0x410  fs/namei.c:3742\n do_sys_openat2+0x171/0x4c0  fs/open.c:1356\n do_sys_open  fs/open.c:1372 [inline]\n __do_sys_openat  fs/open.c:1388 [inline]\n __se_sys_openat  fs/open.c:1383 [inline]\n __x64_sys_openat+0x143/0x200  fs/open.c:1383\n do_syscall_x64  arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3f/0x90  arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nFreed by task 20115:\n kasan_save_stack+0x22/0x50  mm/kasan/common.c:45\n kasan_set_track+0x25/0x30  mm/kasan/common.c:52\n kasan_save_free_info+0x2e/0x50  mm/kasan/generic.c:521\n ____kasan_slab_free  mm/kasan/common.c:236 [inline]\n ____kasan_slab_free  mm/kasan/common.c:200 [inline]\n __kasan_slab_free+0x10a/0x190  mm/kasan/common.c:244\n kasan_slab_free  include/linux/kasan.h:162 [inline]\n slab_free_hook  mm/slub.c:1781 [inline]\n slab_free_freelist_hook  mm/slub.c:1807 [inline]\n slab_free  mm/slub.c:3787 [inline]\n __kmem_cache_free+0x7a/0x190  mm/slub.c:3800\n local_release  net/nfc/llcp_core.c:174 [inline]\n kref_put  include/linux/kref.h:65 [inline]\n nfc_llcp_local_put  net/nfc/llcp_core.c:182 [inline]\n nfc_llcp_local_put  net/nfc/llcp_core.c:177 [inline]\n nfc_llcp_unregister_device+0x206/0x290  net/nfc/llcp_core.c:1620\n nfc_unregister_device+0x160/0x1d0  net/nfc/core.c:1179\n virtual_ncidev_close+0x52/0xa0  drivers/nfc/virtual_ncidev.c:163\n __fput+0x252/0xa20  fs/file_table.c:321\n task_work_run+0x174/0x270  kernel/task_work.c:179\n resume_user_mode_work  include/linux/resume_user_mode.h:49 [inline]\n exit_to_user_mode_loop  kernel/entry/common.c:171 [inline]\n exit_to_user_mode_prepare+0x108/0x110  kernel/entry/common.c:204\n __syscall_exit_to_user_mode_work  kernel/entry/common.c:286 [inline]\n syscall_exit_to_user_mode+0x21/0x50  kernel/entry/common.c:297\n do_syscall_64+0x4c/0x90  arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nLast potentially related work creation:\n kasan_save_stack+0x22/0x50  mm/kasan/common.c:45\n __kasan_record_aux_stack+0x95/0xb0  mm/kasan/generic.c:491\n kvfree_call_rcu+0x29/0xa80  kernel/rcu/tree.c:3328\n drop_sysctl_table+0x3be/0x4e0  fs/proc/proc_sysctl.c:1735\n unregister_sysctl_table.part.0+0x9c/0x190  fs/proc/proc_sysctl.c:1773\n unregister_sysctl_table+0x24/0x30  fs/proc/proc_sysctl.c:1753\n neigh_sysctl_unregister+0x5f/0x80  net/core/neighbour.c:3895\n addrconf_notify+0x140/0x17b0  net/ipv6/addrconf.c:3684\n notifier_call_chain+0xbe/0x210  kernel/notifier.c:87\n call_netdevice_notifiers_info+0xb5/0x150  net/core/dev.c:1937\n call_netdevice_notifiers_extack  net/core/dev.c:1975 [inline]\n call_netdevice_notifiers  net/core/dev.c:1989 [inline]\n dev_change_name+0x3c3/0x870  net/core/dev.c:1211\n dev_ifsioc+0x800/0xf70  net/core/dev_ioctl.c:376\n dev_ioctl+0x3d9/0xf80  net/core/dev_ioctl.c:542\n sock_do_ioctl+0x160/0x260  net/socket.c:1213\n sock_ioctl+0x3f9/0x670  net/socket.c:1316\n vfs_ioctl  fs/ioctl.c:51 [inline]\n __do_sys_ioctl  fs/ioctl.c:870 [inline]\n __se_sys_ioctl  fs/ioctl.c:856 [inline]\n __x64_sys_ioctl+0x19e/0x210  fs/ioctl.c:856\n do_syscall_x64  arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3f/0x90  arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nThe buggy address belongs to the object at ffff888105b0e400\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 16 bytes inside of\n freed 1024-byte region [ffff888105b0e400, ffff888105b0e800)\n\nThe buggy address belongs to the physical page:\nhead:ffffea000416c200 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0\nflags: 0x200000000010200(slab|head|node=0|zone=2)\nraw: 0200000000010200 ffff8881000430c0 ffffea00044c7010 ffffea0004510e10\nraw: 0000000000000000 00000000000a000a 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff888105b0e300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff888105b0e380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff888105b0e400: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                         ^\n ffff888105b0e480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888105b0e500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\nIn summary, this patch solves those use-after-free by\n\n1. Re-implement the nfc_llcp_find_local(). The current version does not\ngrab the reference when getting the local from the linked list.  For\nexample, the llcp_sock_bind() gets the reference like below:\n\n// llcp_sock_bind()\n\n    local = nfc_llcp_find_local(dev); // A\n    ..... \\\n           | raceable\n    ..... /\n    llcp_sock->local = nfc_llcp_local_get(local); // B\n\nThere is an apparent race window that one can  drop the reference\nand free the local object fetched in (A) before (B) gets the reference.\n\n2. Some callers of the nfc_llcp_find_local() do not grab the reference\nat all. For example, the nfc_genl_llc_{{get/set}_params/sdreq} functions.\nWe add the nfc_llcp_local_put() for them. Moreover, we add the necessary\nerror handling function to put the reference.\n\n3. Add the nfc_llcp_remove_local() helper. The local object is removed\nfrom the linked list in local_release() when all reference is gone. This\npatch removes it when nfc_llcp_unregister_device() is called.\n\nTherefore, every caller of nfc_llcp_find_local() will get a reference\neven when the nfc_llcp_unregister_device() is called. This promises no\nuse-after-free for the local object is ever possible.\n\nFixes: 52feb444a903 (\"NFC: Extend netlink interface for LTO, RW, and MIUX parameters support\")\nFixes: c7aa12252f51 (\"NFC: Take a reference on the LLCP local pointer when creating a socket\")\nSigned-off-by: Lin Ma <linma@zju.edu.cn>\nReviewed-by: Simon Horman <simon.horman@corigine.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2023-06-26T09:57:23Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/6709d4b7bc2e079241fdef15d1160581c5261c10",
        "html_url": "https://github.com/torvalds/linux/commit/6709d4b7bc2e079241fdef15d1160581c5261c10",
        "parents": [
            {
                "commit_id_before": "d1b355438b8325a486f087e506d412c4e852f37b",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/d1b355438b8325a486f087e506d412c4e852f37b",
                "html_url_before": "https://github.com/torvalds/linux/commit/d1b355438b8325a486f087e506d412c4e852f37b"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/nfc/llcp.h"
    },
    {
        "index": 12149,
        "cve_id": "CVE-2023-40283",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in l2cap_sock_release in net/bluetooth/l2cap_sock.c in the Linux kernel before 6.4.10. There is a use-after-free because the children of an sk are mishandled.",
        "cvss": "7.8",
        "publish_date": "August 13, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "1728137b33c00d5a2b5110ed7aafb42e7c32e4a1",
        "commit_message": "Bluetooth: L2CAP: Fix use-after-free in l2cap_sock_ready_cb\n\nl2cap_sock_release(sk) frees sk. However, sk's children are still alive\nand point to the already free'd sk's address.\nTo fix this, l2cap_sock_release(sk) also cleans sk's children.\n\n==================================================================\nBUG: KASAN: use-after-free in l2cap_sock_ready_cb+0xb7/0x100 net/bluetooth/l2cap_sock.c:1650\nRead of size 8 at addr ffff888104617aa8 by task kworker/u3:0/276\n\nCPU: 0 PID: 276 Comm: kworker/u3:0 Not tainted 6.2.0-00001-gef397bd4d5fb-dirty #59\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nWorkqueue: hci2 hci_rx_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x72/0x95 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:306 [inline]\n print_report+0x175/0x478 mm/kasan/report.c:417\n kasan_report+0xb1/0x130 mm/kasan/report.c:517\n l2cap_sock_ready_cb+0xb7/0x100 net/bluetooth/l2cap_sock.c:1650\n l2cap_chan_ready+0x10e/0x1e0 net/bluetooth/l2cap_core.c:1386\n l2cap_config_req+0x753/0x9f0 net/bluetooth/l2cap_core.c:4480\n l2cap_bredr_sig_cmd net/bluetooth/l2cap_core.c:5739 [inline]\n l2cap_sig_channel net/bluetooth/l2cap_core.c:6509 [inline]\n l2cap_recv_frame+0xe2e/0x43c0 net/bluetooth/l2cap_core.c:7788\n l2cap_recv_acldata+0x6ed/0x7e0 net/bluetooth/l2cap_core.c:8506\n hci_acldata_packet net/bluetooth/hci_core.c:3813 [inline]\n hci_rx_work+0x66e/0xbc0 net/bluetooth/hci_core.c:4048\n process_one_work+0x4ea/0x8e0 kernel/workqueue.c:2289\n worker_thread+0x364/0x8e0 kernel/workqueue.c:2436\n kthread+0x1b9/0x200 kernel/kthread.c:376\n ret_from_fork+0x2c/0x50 arch/x86/entry/entry_64.S:308\n </TASK>\n\nAllocated by task 288:\n kasan_save_stack+0x22/0x50 mm/kasan/common.c:45\n kasan_set_track+0x25/0x30 mm/kasan/common.c:52\n ____kasan_kmalloc mm/kasan/common.c:374 [inline]\n __kasan_kmalloc+0x82/0x90 mm/kasan/common.c:383\n kasan_kmalloc include/linux/kasan.h:211 [inline]\n __do_kmalloc_node mm/slab_common.c:968 [inline]\n __kmalloc+0x5a/0x140 mm/slab_common.c:981\n kmalloc include/linux/slab.h:584 [inline]\n sk_prot_alloc+0x113/0x1f0 net/core/sock.c:2040\n sk_alloc+0x36/0x3c0 net/core/sock.c:2093\n l2cap_sock_alloc.constprop.0+0x39/0x1c0 net/bluetooth/l2cap_sock.c:1852\n l2cap_sock_create+0x10d/0x220 net/bluetooth/l2cap_sock.c:1898\n bt_sock_create+0x183/0x290 net/bluetooth/af_bluetooth.c:132\n __sock_create+0x226/0x380 net/socket.c:1518\n sock_create net/socket.c:1569 [inline]\n __sys_socket_create net/socket.c:1606 [inline]\n __sys_socket_create net/socket.c:1591 [inline]\n __sys_socket+0x112/0x200 net/socket.c:1639\n __do_sys_socket net/socket.c:1652 [inline]\n __se_sys_socket net/socket.c:1650 [inline]\n __x64_sys_socket+0x40/0x50 net/socket.c:1650\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3f/0x90 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nFreed by task 288:\n kasan_save_stack+0x22/0x50 mm/kasan/common.c:45\n kasan_set_track+0x25/0x30 mm/kasan/common.c:52\n kasan_save_free_info+0x2e/0x50 mm/kasan/generic.c:523\n ____kasan_slab_free mm/kasan/common.c:236 [inline]\n ____kasan_slab_free mm/kasan/common.c:200 [inline]\n __kasan_slab_free+0x10a/0x190 mm/kasan/common.c:244\n kasan_slab_free include/linux/kasan.h:177 [inline]\n slab_free_hook mm/slub.c:1781 [inline]\n slab_free_freelist_hook mm/slub.c:1807 [inline]\n slab_free mm/slub.c:3787 [inline]\n __kmem_cache_free+0x88/0x1f0 mm/slub.c:3800\n sk_prot_free net/core/sock.c:2076 [inline]\n __sk_destruct+0x347/0x430 net/core/sock.c:2168\n sk_destruct+0x9c/0xb0 net/core/sock.c:2183\n __sk_free+0x82/0x220 net/core/sock.c:2194\n sk_free+0x7c/0xa0 net/core/sock.c:2205\n sock_put include/net/sock.h:1991 [inline]\n l2cap_sock_kill+0x256/0x2b0 net/bluetooth/l2cap_sock.c:1257\n l2cap_sock_release+0x1a7/0x220 net/bluetooth/l2cap_sock.c:1428\n __sock_release+0x80/0x150 net/socket.c:650\n sock_close+0x19/0x30 net/socket.c:1368\n __fput+0x17a/0x5c0 fs/file_table.c:320\n task_work_run+0x132/0x1c0 kernel/task_work.c:179\n resume_user_mode_work include/linux/resume_user_mode.h:49 [inline]\n exit_to_user_mode_loop kernel/entry/common.c:171 [inline]\n exit_to_user_mode_prepare+0x113/0x120 kernel/entry/common.c:203\n __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]\n syscall_exit_to_user_mode+0x21/0x50 kernel/entry/common.c:296\n do_syscall_64+0x4c/0x90 arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nThe buggy address belongs to the object at ffff888104617800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 680 bytes inside of\n 1024-byte region [ffff888104617800, ffff888104617c00)\n\nThe buggy address belongs to the physical page:\npage:00000000dbca6a80 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888104614000 pfn:0x104614\nhead:00000000dbca6a80 order:2 compound_mapcount:0 subpages_mapcount:0 compound_pincount:0\nflags: 0x200000000010200(slab|head|node=0|zone=2)\nraw: 0200000000010200 ffff888100041dc0 ffffea0004212c10 ffffea0004234b10\nraw: ffff888104614000 0000000000080002 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff888104617980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888104617a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff888104617a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                  ^\n ffff888104617b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888104617b80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n==================================================================\n\nAck: This bug is found by FuzzBT with a modified Syzkaller. Other\ncontributors are Ruoyu Wu and Hui Peng.\nSigned-off-by: Sungwoo Kim <iam@sung-woo.kim>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
        "commit_date": "2023-06-29T17:48:35Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1728137b33c00d5a2b5110ed7aafb42e7c32e4a1",
        "html_url": "https://github.com/torvalds/linux/commit/1728137b33c00d5a2b5110ed7aafb42e7c32e4a1",
        "parents": [
            {
                "commit_id_before": "6945795bc81ab7be22750ecfb365056688f2fada",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/6945795bc81ab7be22750ecfb365056688f2fada",
                "html_url_before": "https://github.com/torvalds/linux/commit/6945795bc81ab7be22750ecfb365056688f2fada"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "net/bluetooth/l2cap_sock.c"
    },
    {
        "index": 12133,
        "cve_id": "CVE-2023-4387",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in vmxnet3_rq_alloc_rx_buf in drivers/net/vmxnet3/vmxnet3_drv.c in VMware's vmxnet3 ethernet NIC driver in the Linux Kernel. This issue could allow a local attacker to crash the system due to a double-free while cleaning up vmxnet3_rq_cleanup_all, which could also lead to a kernel information leak problem.",
        "cvss": "7.1",
        "publish_date": "August 16, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "9e7fef9521e73ca8afd7da9e58c14654b02dfad8",
        "commit_message": "net: vmxnet3: fix possible use-after-free bugs in vmxnet3_rq_alloc_rx_buf()\n\nIn vmxnet3_rq_alloc_rx_buf(), when dma_map_single() fails, rbi->skb is\nfreed immediately. Similarly, in another branch, when dma_map_page() fails,\nrbi->page is also freed. In the two cases, vmxnet3_rq_alloc_rx_buf()\nreturns an error to its callers vmxnet3_rq_init() -> vmxnet3_rq_init_all()\n-> vmxnet3_activate_dev(). Then vmxnet3_activate_dev() calls\nvmxnet3_rq_cleanup_all() in error handling code, and rbi->skb or rbi->page\nare freed again in vmxnet3_rq_cleanup_all(), causing use-after-free bugs.\n\nTo fix these possible bugs, rbi->skb and rbi->page should be cleared after\nthey are freed.\n\nThe error log in our fault-injection testing is shown as follows:\n\n[   14.319016] BUG: KASAN: use-after-free in consume_skb+0x2f/0x150\n...\n[   14.321586] Call Trace:\n...\n[   14.325357]  consume_skb+0x2f/0x150\n[   14.325671]  vmxnet3_rq_cleanup_all+0x33a/0x4e0 [vmxnet3]\n[   14.326150]  vmxnet3_activate_dev+0xb9d/0x2ca0 [vmxnet3]\n[   14.326616]  vmxnet3_open+0x387/0x470 [vmxnet3]\n...\n[   14.361675] Allocated by task 351:\n...\n[   14.362688]  __netdev_alloc_skb+0x1b3/0x6f0\n[   14.362960]  vmxnet3_rq_alloc_rx_buf+0x1b0/0x8d0 [vmxnet3]\n[   14.363317]  vmxnet3_activate_dev+0x3e3/0x2ca0 [vmxnet3]\n[   14.363661]  vmxnet3_open+0x387/0x470 [vmxnet3]\n...\n[   14.367309]\n[   14.367412] Freed by task 351:\n...\n[   14.368932]  __dev_kfree_skb_any+0xd2/0xe0\n[   14.369193]  vmxnet3_rq_alloc_rx_buf+0x71e/0x8d0 [vmxnet3]\n[   14.369544]  vmxnet3_activate_dev+0x3e3/0x2ca0 [vmxnet3]\n[   14.369883]  vmxnet3_open+0x387/0x470 [vmxnet3]\n[   14.370174]  __dev_open+0x28a/0x420\n[   14.370399]  __dev_change_flags+0x192/0x590\n[   14.370667]  dev_change_flags+0x7a/0x180\n[   14.370919]  do_setlink+0xb28/0x3570\n[   14.371150]  rtnl_newlink+0x1160/0x1740\n[   14.371399]  rtnetlink_rcv_msg+0x5bf/0xa50\n[   14.371661]  netlink_rcv_skb+0x1cd/0x3e0\n[   14.371913]  netlink_unicast+0x5dc/0x840\n[   14.372169]  netlink_sendmsg+0x856/0xc40\n[   14.372420]  ____sys_sendmsg+0x8a7/0x8d0\n[   14.372673]  __sys_sendmsg+0x1c2/0x270\n[   14.372914]  do_syscall_64+0x41/0x90\n[   14.373145]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n...\n\nFixes: 5738a09d58d5a (\"vmxnet3: fix checks for dma mapping errors\")\nReported-by: TOTE Robot <oslab@tsinghua.edu.cn>\nSigned-off-by: Zixuan Fu <r33s3n6@gmail.com>\nLink: https://lore.kernel.org/r/20220514050656.2636588-1-r33s3n6@gmail.com\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
        "commit_date": "2022-05-17T10:02:27Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/9e7fef9521e73ca8afd7da9e58c14654b02dfad8",
        "html_url": "https://github.com/torvalds/linux/commit/9e7fef9521e73ca8afd7da9e58c14654b02dfad8",
        "parents": [
            {
                "commit_id_before": "4d33ab08c0af140752a46f227a6bf97dab1e17b4",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/4d33ab08c0af140752a46f227a6bf97dab1e17b4",
                "html_url_before": "https://github.com/torvalds/linux/commit/4d33ab08c0af140752a46f227a6bf97dab1e17b4"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": "drivers/net/vmxnet3/vmxnet3_drv.c"
    }
]
