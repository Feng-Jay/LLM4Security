[
    {
        "index": 554,
        "cve_id": "CVE-2014-0131",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the skb_segment function in net/core/skbuff.c in the Linux kernel through 3.13.6 allows attackers to obtain sensitive information from kernel memory by leveraging the absence of a certain orphaning operation.",
        "cvss": "3.1",
        "publish_date": "March 24, 2014",
        "AV": "ADJACENT_NETWORK",
        "AC": "ADJACENT_NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "LOW",
        "I": "NONE",
        "A": "NONE",
        "commit_id": "1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "commit_message": "skbuff: skb_segment: orphan frags before copying\n\nskb_segment copies frags around, so we need\nto copy them carefully to avoid accessing\nuser memory after reporting completion to userspace\nthrough a callback.\n\nskb_segment doesn't normally happen on datapath:\nTSO needs to be disabled - so disabling zero copy\nin this case does not look like a big deal.\n\nSigned-off-by: Michael S. Tsirkin <mst@redhat.com>\nAcked-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2014-03-11T20:26:38Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "html_url": "https://github.com/torvalds/linux/commit/1fd819ecb90cc9b822cd84d3056ddba315d3340f",
        "parents": [
            {
                "commit_id_before": "1a4cedaf65491e66e1e55b8428c89209da729209",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/1a4cedaf65491e66e1e55b8428c89209da729209",
                "html_url_before": "https://github.com/torvalds/linux/commit/1a4cedaf65491e66e1e55b8428c89209da729209"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 611,
        "cve_id": "CVE-2014-0203",
        "cwe_id": [
            "CWE-20",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The __do_follow_link function in fs/namei.c in the Linux kernel before 2.6.33 does not properly handle the last pathname component during use of certain filesystems, which allows local users to cause a denial of service (incorrect free operations and system crash) via an open system call.",
        "cvss": "5.5",
        "publish_date": "June 23, 2014",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "86acdca1b63e6890540fa19495cfc708beff3d8b",
        "commit_message": "fix autofs/afs/etc. magic mountpoint breakage\n\nWe end up trying to kfree() nd.last.name on open(\"/mnt/tmp\", O_CREAT)\nif /mnt/tmp is an autofs direct mount.  The reason is that nd.last_type\nis bogus here; we want LAST_BIND for everything of that kind and we\nget LAST_NORM left over from finding parent directory.\n\nSo make sure that it *is* set properly; set to LAST_BIND before\ndoing ->follow_link() - for normal symlinks it will be changed\nby __vfs_follow_link() and everything else needs it set that way.\n\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "commit_date": "2010-01-14T14:05:25Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/86acdca1b63e6890540fa19495cfc708beff3d8b",
        "html_url": "https://github.com/torvalds/linux/commit/86acdca1b63e6890540fa19495cfc708beff3d8b",
        "parents": [
            {
                "commit_id_before": "004b35063296b6772fa72404a35b498f1e71e87e",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/004b35063296b6772fa72404a35b498f1e71e87e",
                "html_url_before": "https://github.com/torvalds/linux/commit/004b35063296b6772fa72404a35b498f1e71e87e"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 665,
        "cve_id": "CVE-2014-4653",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not ensure possession of a read/write lock, which allows local users to cause a denial of service (use-after-free) and obtain sensitive information from kernel memory by leveraging /dev/snd/controlCX access.",
        "cvss": "5.9",
        "publish_date": "July 2, 2014",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "LOW",
        "I": "LOW",
        "A": "LOW",
        "commit_id": "fd9f26e4eca5d08a27d12c0933fceef76ed9663d",
        "commit_message": "ALSA: control: Don't access controls outside of protected regions\n\nA control that is visible on the card->controls list can be freed at any time.\nThis means we must not access any of its memory while not holding the\ncontrols_rw_lock. Otherwise we risk a use after free access.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2014-06-18T13:13:07Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/fd9f26e4eca5d08a27d12c0933fceef76ed9663d",
        "html_url": "https://github.com/torvalds/linux/commit/fd9f26e4eca5d08a27d12c0933fceef76ed9663d",
        "parents": [
            {
                "commit_id_before": "82262a46627bebb0febcc26664746c25cef08563",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/82262a46627bebb0febcc26664746c25cef08563",
                "html_url_before": "https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 666,
        "cve_id": "CVE-2014-4654",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The snd_ctl_elem_add function in sound/core/control.c in the ALSA control implementation in the Linux kernel before 3.15.2 does not check authorization for SNDRV_CTL_IOCTL_ELEM_REPLACE commands, which allows local users to remove kernel controls and cause a denial of service (use-after-free and system crash) by leveraging /dev/snd/controlCX access for an ioctl call.",
        "cvss": "5.9",
        "publish_date": "July 2, 2014",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "LOW",
        "I": "LOW",
        "A": "LOW",
        "commit_id": "82262a46627bebb0febcc26664746c25cef08563",
        "commit_message": "ALSA: control: Fix replacing user controls\n\nThere are two issues with the current implementation for replacing user\ncontrols. The first is that the code does not check if the control is actually a\nuser control and neither does it check if the control is owned by the process\nthat tries to remove it. That allows userspace applications to remove arbitrary\ncontrols, which can cause a user after free if a for example a driver does not\nexpect a control to be removed from under its feed.\n\nThe second issue is that on one hand when a control is replaced the\nuser_ctl_count limit is not checked and on the other hand the user_ctl_count is\nincreased (even though the number of user controls does not change). This allows\nuserspace, once the user_ctl_count limit as been reached, to repeatedly replace\na control until user_ctl_count overflows. Once that happens new controls can be\nadded effectively bypassing the user_ctl_count limit.\n\nBoth issues can be fixed by instead of open-coding the removal of the control\nthat is to be replaced to use snd_ctl_remove_user_ctl(). This function does\nproper permission checks as well as decrements user_ctl_count after the control\nhas been removed.\n\nNote that by using snd_ctl_remove_user_ctl() the check which returns -EBUSY at\nbeginning of the function if the control already exists is removed. This is not\na problem though since the check is quite useless, because the lock that is\nprotecting the control list is released between the check and before adding the\nnew control to the list, which means that it is possible that a different\ncontrol with the same settings is added to the list after the check. Luckily\nthere is another check that is done while holding the lock in snd_ctl_add(), so\nwe'll rely on that to make sure that the same control is not added twice.\n\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nAcked-by: Jaroslav Kysela <perex@perex.cz>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2014-06-18T13:12:49Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/82262a46627bebb0febcc26664746c25cef08563",
        "html_url": "https://github.com/torvalds/linux/commit/82262a46627bebb0febcc26664746c25cef08563",
        "parents": [
            {
                "commit_id_before": "07f4d9d74a04aa7c72c5dae0ef97565f28f17b92",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92",
                "html_url_before": "https://github.com/torvalds/linux/commit/07f4d9d74a04aa7c72c5dae0ef97565f28f17b92"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1597,
        "cve_id": "CVE-2014-9914",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the ip4_datagram_release_cb function in net/ipv4/datagram.c in the Linux kernel before 3.15.2 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect expectations about locking during multithreaded access to internal data structures for IPv4 UDP sockets.",
        "cvss": "7.8",
        "publish_date": "February 7, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "9709674e68646cee5a24e3000b3558d25412203a",
        "commit_message": "ipv4: fix a race in ip4_datagram_release_cb()\n\nAlexey gave a AddressSanitizer[1] report that finally gave a good hint\nat where was the origin of various problems already reported by Dormando\nin the past [2]\n\nProblem comes from the fact that UDP can have a lockless TX path, and\nconcurrent threads can manipulate sk_dst_cache, while another thread,\nis holding socket lock and calls __sk_dst_set() in\nip4_datagram_release_cb() (this was added in linux-3.8)\n\nIt seems that all we need to do is to use sk_dst_check() and\nsk_dst_set() so that all the writers hold same spinlock\n(sk->sk_dst_lock) to prevent corruptions.\n\nTCP stack do not need this protection, as all sk_dst_cache writers hold\nthe socket lock.\n\n[1]\nhttps://code.google.com/p/address-sanitizer/wiki/AddressSanitizerForKernel\n\nAddressSanitizer: heap-use-after-free in ipv4_dst_check\nRead of size 2 by thread T15453:\n [<ffffffff817daa3a>] ipv4_dst_check+0x1a/0x90 ./net/ipv4/route.c:1116\n [<ffffffff8175b789>] __sk_dst_check+0x89/0xe0 ./net/core/sock.c:531\n [<ffffffff81830a36>] ip4_datagram_release_cb+0x46/0x390 ??:0\n [<ffffffff8175eaea>] release_sock+0x17a/0x230 ./net/core/sock.c:2413\n [<ffffffff81830882>] ip4_datagram_connect+0x462/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\nFreed by thread T15455:\n [<ffffffff8178d9b8>] dst_destroy+0xa8/0x160 ./net/core/dst.c:251\n [<ffffffff8178de25>] dst_release+0x45/0x80 ./net/core/dst.c:280\n [<ffffffff818304c1>] ip4_datagram_connect+0xa1/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\nAllocated by thread T15453:\n [<ffffffff8178d291>] dst_alloc+0x81/0x2b0 ./net/core/dst.c:171\n [<ffffffff817db3b7>] rt_dst_alloc+0x47/0x50 ./net/ipv4/route.c:1406\n [<     inlined    >] __ip_route_output_key+0x3e8/0xf70\n__mkroute_output ./net/ipv4/route.c:1939\n [<ffffffff817dde08>] __ip_route_output_key+0x3e8/0xf70 ./net/ipv4/route.c:2161\n [<ffffffff817deb34>] ip_route_output_flow+0x14/0x30 ./net/ipv4/route.c:2249\n [<ffffffff81830737>] ip4_datagram_connect+0x317/0x5d0 ??:0\n [<ffffffff81846d06>] inet_dgram_connect+0x76/0xd0 ./net/ipv4/af_inet.c:534\n [<ffffffff817580ac>] SYSC_connect+0x15c/0x1c0 ./net/socket.c:1701\n [<ffffffff817596ce>] SyS_connect+0xe/0x10 ./net/socket.c:1682\n [<ffffffff818b0a29>] system_call_fastpath+0x16/0x1b\n./arch/x86/kernel/entry_64.S:629\n\n[2]\n<4>[196727.311203] general protection fault: 0000 [#1] SMP\n<4>[196727.311224] Modules linked in: xt_TEE xt_dscp xt_DSCP macvlan bridge coretemp crc32_pclmul ghash_clmulni_intel gpio_ich microcode ipmi_watchdog ipmi_devintf sb_edac edac_core lpc_ich mfd_core tpm_tis tpm tpm_bios ipmi_si ipmi_msghandler isci igb libsas i2c_algo_bit ixgbe ptp pps_core mdio\n<4>[196727.311333] CPU: 17 PID: 0 Comm: swapper/17 Not tainted 3.10.26 #1\n<4>[196727.311344] Hardware name: Supermicro X9DRi-LN4+/X9DR3-LN4+/X9DRi-LN4+/X9DR3-LN4+, BIOS 3.0 07/05/2013\n<4>[196727.311364] task: ffff885e6f069700 ti: ffff885e6f072000 task.ti: ffff885e6f072000\n<4>[196727.311377] RIP: 0010:[<ffffffff815f8c7f>]  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80\n<4>[196727.311399] RSP: 0018:ffff885effd23a70  EFLAGS: 00010282\n<4>[196727.311409] RAX: dead000000200200 RBX: ffff8854c398ecc0 RCX: 0000000000000040\n<4>[196727.311423] RDX: dead000000100100 RSI: dead000000100100 RDI: dead000000200200\n<4>[196727.311437] RBP: ffff885effd23a80 R08: ffffffff815fd9e0 R09: ffff885d5a590800\n<4>[196727.311451] R10: 0000000000000000 R11: 0000000000000000 R12: 0000000000000000\n<4>[196727.311464] R13: ffffffff81c8c280 R14: 0000000000000000 R15: ffff880e85ee16ce\n<4>[196727.311510] FS:  0000000000000000(0000) GS:ffff885effd20000(0000) knlGS:0000000000000000\n<4>[196727.311554] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033\n<4>[196727.311581] CR2: 00007a46751eb000 CR3: 0000005e65688000 CR4: 00000000000407e0\n<4>[196727.311625] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000\n<4>[196727.311669] DR3: 0000000000000000 DR6: 00000000ffff0ff0 DR7: 0000000000000400\n<4>[196727.311713] Stack:\n<4>[196727.311733]  ffff8854c398ecc0 ffff8854c398ecc0 ffff885effd23ab0 ffffffff815b7f42\n<4>[196727.311784]  ffff88be6595bc00 ffff8854c398ecc0 0000000000000000 ffff8854c398ecc0\n<4>[196727.311834]  ffff885effd23ad0 ffffffff815b86c6 ffff885d5a590800 ffff8816827821c0\n<4>[196727.311885] Call Trace:\n<4>[196727.311907]  <IRQ>\n<4>[196727.311912]  [<ffffffff815b7f42>] dst_destroy+0x32/0xe0\n<4>[196727.311959]  [<ffffffff815b86c6>] dst_release+0x56/0x80\n<4>[196727.311986]  [<ffffffff81620bd5>] tcp_v4_do_rcv+0x2a5/0x4a0\n<4>[196727.312013]  [<ffffffff81622b5a>] tcp_v4_rcv+0x7da/0x820\n<4>[196727.312041]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360\n<4>[196727.312070]  [<ffffffff815de02d>] ? nf_hook_slow+0x7d/0x150\n<4>[196727.312097]  [<ffffffff815fd9e0>] ? ip_rcv_finish+0x360/0x360\n<4>[196727.312125]  [<ffffffff815fda92>] ip_local_deliver_finish+0xb2/0x230\n<4>[196727.312154]  [<ffffffff815fdd9a>] ip_local_deliver+0x4a/0x90\n<4>[196727.312183]  [<ffffffff815fd799>] ip_rcv_finish+0x119/0x360\n<4>[196727.312212]  [<ffffffff815fe00b>] ip_rcv+0x22b/0x340\n<4>[196727.312242]  [<ffffffffa0339680>] ? macvlan_broadcast+0x160/0x160 [macvlan]\n<4>[196727.312275]  [<ffffffff815b0c62>] __netif_receive_skb_core+0x512/0x640\n<4>[196727.312308]  [<ffffffff811427fb>] ? kmem_cache_alloc+0x13b/0x150\n<4>[196727.312338]  [<ffffffff815b0db1>] __netif_receive_skb+0x21/0x70\n<4>[196727.312368]  [<ffffffff815b0fa1>] netif_receive_skb+0x31/0xa0\n<4>[196727.312397]  [<ffffffff815b1ae8>] napi_gro_receive+0xe8/0x140\n<4>[196727.312433]  [<ffffffffa00274f1>] ixgbe_poll+0x551/0x11f0 [ixgbe]\n<4>[196727.312463]  [<ffffffff815fe00b>] ? ip_rcv+0x22b/0x340\n<4>[196727.312491]  [<ffffffff815b1691>] net_rx_action+0x111/0x210\n<4>[196727.312521]  [<ffffffff815b0db1>] ? __netif_receive_skb+0x21/0x70\n<4>[196727.312552]  [<ffffffff810519d0>] __do_softirq+0xd0/0x270\n<4>[196727.312583]  [<ffffffff816cef3c>] call_softirq+0x1c/0x30\n<4>[196727.312613]  [<ffffffff81004205>] do_softirq+0x55/0x90\n<4>[196727.312640]  [<ffffffff81051c85>] irq_exit+0x55/0x60\n<4>[196727.312668]  [<ffffffff816cf5c3>] do_IRQ+0x63/0xe0\n<4>[196727.312696]  [<ffffffff816c5aaa>] common_interrupt+0x6a/0x6a\n<4>[196727.312722]  <EOI>\n<1>[196727.313071] RIP  [<ffffffff815f8c7f>] ipv4_dst_destroy+0x4f/0x80\n<4>[196727.313100]  RSP <ffff885effd23a70>\n<4>[196727.313377] ---[ end trace 64b3f14fae0f2e29 ]---\n<0>[196727.380908] Kernel panic - not syncing: Fatal exception in interrupt\n\nReported-by: Alexey Preobrazhensky <preobr@google.com>\nReported-by: dormando <dormando@rydia.ne>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nFixes: 8141ed9fcedb2 (\"ipv4: Add a socket release callback for datagram sockets\")\nCc: Steffen Klassert <steffen.klassert@secunet.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2014-06-11T22:39:18Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/9709674e68646cee5a24e3000b3558d25412203a",
        "html_url": "https://github.com/torvalds/linux/commit/9709674e68646cee5a24e3000b3558d25412203a",
        "parents": [
            {
                "commit_id_before": "a101ccd141fa777febc510a5c3f3da0c23cd47ce",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/a101ccd141fa777febc510a5c3f3da0c23cd47ce",
                "html_url_before": "https://github.com/torvalds/linux/commit/a101ccd141fa777febc510a5c3f3da0c23cd47ce"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2060,
        "cve_id": "CVE-2014-9940",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The regulator_ena_gpio_free function in drivers/regulator/core.c in the Linux kernel before 3.19 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted application.",
        "cvss": "7.0",
        "publish_date": "May 2, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "commit_message": "regulator: core: Fix regualtor_ena_gpio_free not to access pin after freeing\n\nAfter freeing pin from regulator_ena_gpio_free, loop can access\nthe pin. So this patch fixes not to access pin after freeing.\n\nSigned-off-by: Seung-Woo Kim <sw0312.kim@samsung.com>\nSigned-off-by: Mark Brown <broonie@kernel.org>",
        "commit_date": "2014-12-04T22:45:36Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "html_url": "https://github.com/torvalds/linux/commit/60a2362f769cf549dc466134efe71c8bf9fbaaba",
        "parents": [
            {
                "commit_id_before": "194dbaefa0da24bb60d9df1c99dda807f51fc33f",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/194dbaefa0da24bb60d9df1c99dda807f51fc33f",
                "html_url_before": "https://github.com/torvalds/linux/commit/194dbaefa0da24bb60d9df1c99dda807f51fc33f"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 921,
        "cve_id": "CVE-2015-5706",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the path_openat function in fs/namei.c in the Linux kernel 3.x and 4.x before 4.0.4 allows local users to cause a denial of service or possibly have unspecified other impact via O_TMPFILE filesystem operations that leverage a duplicate cleanup operation.",
        "cvss": "5.3",
        "publish_date": "August 31, 2015",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "LOW",
        "commit_id": "f15133df088ecadd141ea1907f2c96df67c729f0",
        "commit_message": "path_openat(): fix double fput()\n\npath_openat() jumps to the wrong place after do_tmpfile() - it has\nalready done path_cleanup() (as part of path_lookupat() called by\ndo_tmpfile()), so doing that again can lead to double fput().\n\nCc: stable@vger.kernel.org\t# v3.11+\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "commit_date": "2015-05-09T04:12:48Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/f15133df088ecadd141ea1907f2c96df67c729f0",
        "html_url": "https://github.com/torvalds/linux/commit/f15133df088ecadd141ea1907f2c96df67c729f0",
        "parents": [
            {
                "commit_id_before": "766c4cbfacd8634d7580bac6a1b8456e63de3e84",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/766c4cbfacd8634d7580bac6a1b8456e63de3e84",
                "html_url_before": "https://github.com/torvalds/linux/commit/766c4cbfacd8634d7580bac6a1b8456e63de3e84"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1385,
        "cve_id": "CVE-2015-8961",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The __ext4_journal_stop function in fs/ext4/ext4_jbd2.c in the Linux kernel before 4.3.3 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging improper access to a certain error field.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "6934da9238da947628be83635e365df41064b09b",
        "commit_message": "ext4: fix potential use after free in __ext4_journal_stop\n\nThere is a use-after-free possibility in __ext4_journal_stop() in the\ncase that we free the handle in the first jbd2_journal_stop() because\nwe're referencing handle->h_err afterwards. This was introduced in\n9705acd63b125dee8b15c705216d7186daea4625 and it is wrong. Fix it by\nstoring the handle->h_err value beforehand and avoid referencing\npotentially freed handle.\n\nFixes: 9705acd63b125dee8b15c705216d7186daea4625\nSigned-off-by: Lukas Czerner <lczerner@redhat.com>\nReviewed-by: Andreas Dilger <adilger@dilger.ca>\nCc: stable@vger.kernel.org",
        "commit_date": "2015-10-18T02:57:06Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/6934da9238da947628be83635e365df41064b09b",
        "html_url": "https://github.com/torvalds/linux/commit/6934da9238da947628be83635e365df41064b09b",
        "parents": [
            {
                "commit_id_before": "33d14975e5ac469963d5d63856b61698ad0bff07",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/33d14975e5ac469963d5d63856b61698ad0bff07",
                "html_url_before": "https://github.com/torvalds/linux/commit/33d14975e5ac469963d5d63856b61698ad0bff07"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1384,
        "cve_id": "CVE-2015-8963",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in kernel/events/core.c in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging incorrect handling of an swevent data structure during a CPU unplug operation.",
        "cvss": "7.0",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "12ca6ad2e3a896256f086497a7c7406a547ee373",
        "commit_message": "perf: Fix race in swevent hash\n\nThere's a race on CPU unplug where we free the swevent hash array\nwhile it can still have events on. This will result in a\nuse-after-free which is BAD.\n\nSimply do not free the hash array on unplug. This leaves the thing\naround and no use-after-free takes place.\n\nWhen the last swevent dies, we do a for_each_possible_cpu() iteration\nanyway to clean these up, at which time we'll free it, so no leakage\nwill occur.\n\nReported-by: Sasha Levin <sasha.levin@oracle.com>\nTested-by: Sasha Levin <sasha.levin@oracle.com>\nSigned-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>\nCc: Arnaldo Carvalho de Melo <acme@redhat.com>\nCc: Frederic Weisbecker <fweisbec@gmail.com>\nCc: Jiri Olsa <jolsa@redhat.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Stephane Eranian <eranian@google.com>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: Vince Weaver <vincent.weaver@maine.edu>\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "commit_date": "2016-01-06T09:52:39Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/12ca6ad2e3a896256f086497a7c7406a547ee373",
        "html_url": "https://github.com/torvalds/linux/commit/12ca6ad2e3a896256f086497a7c7406a547ee373",
        "parents": [
            {
                "commit_id_before": "c127449944659543e5e2423002f08f0af98dba5c",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c127449944659543e5e2423002f08f0af98dba5c",
                "html_url_before": "https://github.com/torvalds/linux/commit/c127449944659543e5e2423002f08f0af98dba5c"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1408,
        "cve_id": "CVE-2016-10088",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The sg implementation in the Linux kernel through 4.9 does not properly restrict write operations in situations where the KERNEL_DS option is set, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device, related to block/bsg.c and drivers/scsi/sg.c.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2016-9576.",
        "cvss": "7.0",
        "publish_date": "December 30, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "128394eff343fc6d2f32172f03e24829539c5835",
        "commit_message": "sg_write()/bsg_write() is not fit to be called under KERNEL_DS\n\nBoth damn things interpret userland pointers embedded into the payload;\nworse, they are actually traversing those.  Leaving aside the bad\nAPI design, this is very much _not_ safe to call with KERNEL_DS.\nBail out early if that happens.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "commit_date": "2016-12-23T04:03:42Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/128394eff343fc6d2f32172f03e24829539c5835",
        "html_url": "https://github.com/torvalds/linux/commit/128394eff343fc6d2f32172f03e24829539c5835",
        "parents": [
            {
                "commit_id_before": "f698cccbc89e33cda4795a375e47daaa3689485e",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f698cccbc89e33cda4795a375e47daaa3689485e",
                "html_url_before": "https://github.com/torvalds/linux/commit/f698cccbc89e33cda4795a375e47daaa3689485e"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1615,
        "cve_id": "CVE-2016-10150",
        "cwe_id": [
            "CWE-264",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the kvm_ioctl_create_device function in virt/kvm/kvm_main.c in the Linux kernel before 4.8.13 allows host OS users to cause a denial of service (host OS crash) or possibly gain privileges via crafted ioctl calls on the /dev/kvm device.",
        "cvss": "9.8",
        "publish_date": "February 6, 2017",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "commit_message": "KVM: use after free in kvm_ioctl_create_device()\n\nWe should move the ops->destroy(dev) after the list_del(&dev->vm_node)\nso that we don't use \"dev\" after freeing it.\n\nFixes: a28ebea2adc4 (\"KVM: Protect device ops->create and list_add with kvm->lock\")\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nReviewed-by: David Hildenbrand <david@redhat.com>\nSigned-off-by: Radim Kr\u010dm\u00e1\u0159 <rkrcmar@redhat.com>",
        "commit_date": "2016-12-01T15:10:50Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "html_url": "https://github.com/torvalds/linux/commit/a0f1d21c1ccb1da66629627a74059dd7f5ac9c61",
        "parents": [
            {
                "commit_id_before": "0f4828a1da3342be81e812b28fbcf29261146d25",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/0f4828a1da3342be81e812b28fbcf29261146d25",
                "html_url_before": "https://github.com/torvalds/linux/commit/0f4828a1da3342be81e812b28fbcf29261146d25"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1819,
        "cve_id": "CVE-2016-10200",
        "cwe_id": [
            "CWE-362",
            "CWE-264",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the L2TPv3 IP Encapsulation feature in the Linux kernel before 4.8.14 allows local users to gain privileges or cause a denial of service (use-after-free) by making multiple bind system calls without properly ascertaining whether a socket has the SOCK_ZAPPED status, related to net/l2tp/l2tp_ip.c and net/l2tp/l2tp_ip6.c.",
        "cvss": "7.0",
        "publish_date": "March 7, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "32c231164b762dddefa13af5a0101032c70b50ef",
        "commit_message": "l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()\n\nLock socket before checking the SOCK_ZAPPED flag in l2tp_ip6_bind().\nWithout lock, a concurrent call could modify the socket flags between\nthe sock_flag(sk, SOCK_ZAPPED) test and the lock_sock() call. This way,\na socket could be inserted twice in l2tp_ip6_bind_table. Releasing it\nwould then leave a stale pointer there, generating use-after-free\nerrors when walking through the list or modifying adjacent entries.\n\nBUG: KASAN: use-after-free in l2tp_ip6_close+0x22e/0x290 at addr ffff8800081b0ed8\nWrite of size 8 by task syz-executor/10987\nCPU: 0 PID: 10987 Comm: syz-executor Not tainted 4.8.0+ #39\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS rel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014\n ffff880031d97838 ffffffff829f835b ffff88001b5a1640 ffff8800081b0ec0\n ffff8800081b15a0 ffff8800081b6d20 ffff880031d97860 ffffffff8174d3cc\n ffff880031d978f0 ffff8800081b0e80 ffff88001b5a1640 ffff880031d978e0\nCall Trace:\n [<ffffffff829f835b>] dump_stack+0xb3/0x118 lib/dump_stack.c:15\n [<ffffffff8174d3cc>] kasan_object_err+0x1c/0x70 mm/kasan/report.c:156\n [<     inline     >] print_address_description mm/kasan/report.c:194\n [<ffffffff8174d666>] kasan_report_error+0x1f6/0x4d0 mm/kasan/report.c:283\n [<     inline     >] kasan_report mm/kasan/report.c:303\n [<ffffffff8174db7e>] __asan_report_store8_noabort+0x3e/0x40 mm/kasan/report.c:329\n [<     inline     >] __write_once_size ./include/linux/compiler.h:249\n [<     inline     >] __hlist_del ./include/linux/list.h:622\n [<     inline     >] hlist_del_init ./include/linux/list.h:637\n [<ffffffff8579047e>] l2tp_ip6_close+0x22e/0x290 net/l2tp/l2tp_ip6.c:239\n [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415\n [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422\n [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570\n [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017\n [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208\n [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244\n [<ffffffff813774f9>] task_work_run+0xf9/0x170\n [<ffffffff81324aae>] do_exit+0x85e/0x2a00\n [<ffffffff81326dc8>] do_group_exit+0x108/0x330\n [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307\n [<ffffffff811b49af>] do_signal+0x7f/0x18f0\n [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156\n [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190\n [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259\n [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6\nObject at ffff8800081b0ec0, in cache L2TP/IPv6 size: 1448\nAllocated:\nPID = 10987\n [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20\n [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0\n [ 1116.897025] [<ffffffff8174c9ad>] kasan_kmalloc+0xad/0xe0\n [ 1116.897025] [<ffffffff8174cee2>] kasan_slab_alloc+0x12/0x20\n [ 1116.897025] [<     inline     >] slab_post_alloc_hook mm/slab.h:417\n [ 1116.897025] [<     inline     >] slab_alloc_node mm/slub.c:2708\n [ 1116.897025] [<     inline     >] slab_alloc mm/slub.c:2716\n [ 1116.897025] [<ffffffff817476a8>] kmem_cache_alloc+0xc8/0x2b0 mm/slub.c:2721\n [ 1116.897025] [<ffffffff84c4f6a9>] sk_prot_alloc+0x69/0x2b0 net/core/sock.c:1326\n [ 1116.897025] [<ffffffff84c58ac8>] sk_alloc+0x38/0xae0 net/core/sock.c:1388\n [ 1116.897025] [<ffffffff851ddf67>] inet6_create+0x2d7/0x1000 net/ipv6/af_inet6.c:182\n [ 1116.897025] [<ffffffff84c4af7b>] __sock_create+0x37b/0x640 net/socket.c:1153\n [ 1116.897025] [<     inline     >] sock_create net/socket.c:1193\n [ 1116.897025] [<     inline     >] SYSC_socket net/socket.c:1223\n [ 1116.897025] [<ffffffff84c4b46f>] SyS_socket+0xef/0x1b0 net/socket.c:1203\n [ 1116.897025] [<ffffffff85e4d685>] entry_SYSCALL_64_fastpath+0x23/0xc6\nFreed:\nPID = 10987\n [ 1116.897025] [<ffffffff811ddcb6>] save_stack_trace+0x16/0x20\n [ 1116.897025] [<ffffffff8174c736>] save_stack+0x46/0xd0\n [ 1116.897025] [<ffffffff8174cf61>] kasan_slab_free+0x71/0xb0\n [ 1116.897025] [<     inline     >] slab_free_hook mm/slub.c:1352\n [ 1116.897025] [<     inline     >] slab_free_freelist_hook mm/slub.c:1374\n [ 1116.897025] [<     inline     >] slab_free mm/slub.c:2951\n [ 1116.897025] [<ffffffff81748b28>] kmem_cache_free+0xc8/0x330 mm/slub.c:2973\n [ 1116.897025] [<     inline     >] sk_prot_free net/core/sock.c:1369\n [ 1116.897025] [<ffffffff84c541eb>] __sk_destruct+0x32b/0x4f0 net/core/sock.c:1444\n [ 1116.897025] [<ffffffff84c5aca4>] sk_destruct+0x44/0x80 net/core/sock.c:1452\n [ 1116.897025] [<ffffffff84c5ad33>] __sk_free+0x53/0x220 net/core/sock.c:1460\n [ 1116.897025] [<ffffffff84c5af23>] sk_free+0x23/0x30 net/core/sock.c:1471\n [ 1116.897025] [<ffffffff84c5cb6c>] sk_common_release+0x28c/0x3e0 ./include/net/sock.h:1589\n [ 1116.897025] [<ffffffff8579044e>] l2tp_ip6_close+0x1fe/0x290 net/l2tp/l2tp_ip6.c:243\n [ 1116.897025] [<ffffffff850b2dfd>] inet_release+0xed/0x1c0 net/ipv4/af_inet.c:415\n [ 1116.897025] [<ffffffff851dc5a0>] inet6_release+0x50/0x70 net/ipv6/af_inet6.c:422\n [ 1116.897025] [<ffffffff84c4581d>] sock_release+0x8d/0x1d0 net/socket.c:570\n [ 1116.897025] [<ffffffff84c45976>] sock_close+0x16/0x20 net/socket.c:1017\n [ 1116.897025] [<ffffffff817a108c>] __fput+0x28c/0x780 fs/file_table.c:208\n [ 1116.897025] [<ffffffff817a1605>] ____fput+0x15/0x20 fs/file_table.c:244\n [ 1116.897025] [<ffffffff813774f9>] task_work_run+0xf9/0x170\n [ 1116.897025] [<ffffffff81324aae>] do_exit+0x85e/0x2a00\n [ 1116.897025] [<ffffffff81326dc8>] do_group_exit+0x108/0x330\n [ 1116.897025] [<ffffffff81348cf7>] get_signal+0x617/0x17a0 kernel/signal.c:2307\n [ 1116.897025] [<ffffffff811b49af>] do_signal+0x7f/0x18f0\n [ 1116.897025] [<ffffffff810039bf>] exit_to_usermode_loop+0xbf/0x150 arch/x86/entry/common.c:156\n [ 1116.897025] [<     inline     >] prepare_exit_to_usermode arch/x86/entry/common.c:190\n [ 1116.897025] [<ffffffff81006060>] syscall_return_slowpath+0x1a0/0x1e0 arch/x86/entry/common.c:259\n [ 1116.897025] [<ffffffff85e4d726>] entry_SYSCALL_64_fastpath+0xc4/0xc6\nMemory state around the buggy address:\n ffff8800081b0d80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff8800081b0e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff8800081b0e80: fc fc fc fc fc fc fc fc fb fb fb fb fb fb fb fb\n                                                    ^\n ffff8800081b0f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8800081b0f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\n==================================================================\n\nThe same issue exists with l2tp_ip_bind() and l2tp_ip_bind_table.\n\nFixes: c51ce49735c1 (\"l2tp: fix oops in L2TP IP sockets for connect() AF_UNSPEC case\")\nReported-by: Baozeng Ding <sploving1@gmail.com>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Baozeng Ding <sploving1@gmail.com>\nSigned-off-by: Guillaume Nault <g.nault@alphalink.fr>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2016-11-20T03:09:21Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/32c231164b762dddefa13af5a0101032c70b50ef",
        "html_url": "https://github.com/torvalds/linux/commit/32c231164b762dddefa13af5a0101032c70b50ef",
        "parents": [
            {
                "commit_id_before": "adda306744ec64c7bcd6c230a6bc060fb77bd7c3",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/adda306744ec64c7bcd6c230a6bc060fb77bd7c3",
                "html_url_before": "https://github.com/torvalds/linux/commit/adda306744ec64c7bcd6c230a6bc060fb77bd7c3"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1258,
        "cve_id": "CVE-2016-3841",
        "cwe_id": [
            "CWE-264",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The IPv6 stack in the Linux kernel before 4.3.3 mishandles options data, which allows local users to gain privileges or cause a denial of service (use-after-free and system crash) via a crafted sendmsg system call.",
        "cvss": "7.3",
        "publish_date": "August 6, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "45f6fad84cc305103b28d73482b344d7f5b76f39",
        "commit_message": "ipv6: add complete rcu protection around np->opt\n\nThis patch addresses multiple problems :\n\nUDP/RAW sendmsg() need to get a stable struct ipv6_txoptions\nwhile socket is not locked : Other threads can change np->opt\nconcurrently. Dmitry posted a syzkaller\n(http://github.com/google/syzkaller) program desmonstrating\nuse-after-free.\n\nStarting with TCP/DCCP lockless listeners, tcp_v6_syn_recv_sock()\nand dccp_v6_request_recv_sock() also need to use RCU protection\nto dereference np->opt once (before calling ipv6_dup_options())\n\nThis patch adds full RCU protection to np->opt\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Hannes Frederic Sowa <hannes@stressinduktion.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2015-12-03T04:37:16Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/45f6fad84cc305103b28d73482b344d7f5b76f39",
        "html_url": "https://github.com/torvalds/linux/commit/45f6fad84cc305103b28d73482b344d7f5b76f39",
        "parents": [
            {
                "commit_id_before": "01b3f52157ff5a47d6d8d796f396a4b34a53c61d",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/01b3f52157ff5a47d6d8d796f396a4b34a53c61d",
                "html_url_before": "https://github.com/torvalds/linux/commit/01b3f52157ff5a47d6d8d796f396a4b34a53c61d"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1117,
        "cve_id": "CVE-2016-4805",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in drivers/net/ppp/ppp_generic.c in the Linux kernel before 4.5.2 allows local users to cause a denial of service (memory corruption and system crash, or spinlock) or possibly have unspecified other impact by removing a network namespace, related to the ppp_register_net_channel and ppp_unregister_channel functions.",
        "cvss": "7.8",
        "publish_date": "May 23, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "commit_message": "ppp: take reference on channels netns\n\nLet channels hold a reference on their network namespace.\nSome channel types, like ppp_async and ppp_synctty, can have their\nuserspace controller running in a different namespace. Therefore they\ncan't rely on them to preclude their netns from being removed from\nunder them.\n\n==================================================================\nBUG: KASAN: use-after-free in ppp_unregister_channel+0x372/0x3a0 at\naddr ffff880064e217e0\nRead of size 8 by task syz-executor/11581\n=============================================================================\nBUG net_namespace (Not tainted): kasan: bad access detected\n-----------------------------------------------------------------------------\n\nDisabling lock debugging due to kernel taint\nINFO: Allocated in copy_net_ns+0x6b/0x1a0 age=92569 cpu=3 pid=6906\n[<      none      >] ___slab_alloc+0x4c7/0x500 kernel/mm/slub.c:2440\n[<      none      >] __slab_alloc+0x4c/0x90 kernel/mm/slub.c:2469\n[<     inline     >] slab_alloc_node kernel/mm/slub.c:2532\n[<     inline     >] slab_alloc kernel/mm/slub.c:2574\n[<      none      >] kmem_cache_alloc+0x23a/0x2b0 kernel/mm/slub.c:2579\n[<     inline     >] kmem_cache_zalloc kernel/include/linux/slab.h:597\n[<     inline     >] net_alloc kernel/net/core/net_namespace.c:325\n[<      none      >] copy_net_ns+0x6b/0x1a0 kernel/net/core/net_namespace.c:360\n[<      none      >] create_new_namespaces+0x2f6/0x610 kernel/kernel/nsproxy.c:95\n[<      none      >] copy_namespaces+0x297/0x320 kernel/kernel/nsproxy.c:150\n[<      none      >] copy_process.part.35+0x1bf4/0x5760 kernel/kernel/fork.c:1451\n[<     inline     >] copy_process kernel/kernel/fork.c:1274\n[<      none      >] _do_fork+0x1bc/0xcb0 kernel/kernel/fork.c:1723\n[<     inline     >] SYSC_clone kernel/kernel/fork.c:1832\n[<      none      >] SyS_clone+0x37/0x50 kernel/kernel/fork.c:1826\n[<      none      >] entry_SYSCALL_64_fastpath+0x16/0x7a kernel/arch/x86/entry/entry_64.S:185\n\nINFO: Freed in net_drop_ns+0x67/0x80 age=575 cpu=2 pid=2631\n[<      none      >] __slab_free+0x1fc/0x320 kernel/mm/slub.c:2650\n[<     inline     >] slab_free kernel/mm/slub.c:2805\n[<      none      >] kmem_cache_free+0x2a0/0x330 kernel/mm/slub.c:2814\n[<     inline     >] net_free kernel/net/core/net_namespace.c:341\n[<      none      >] net_drop_ns+0x67/0x80 kernel/net/core/net_namespace.c:348\n[<      none      >] cleanup_net+0x4e5/0x600 kernel/net/core/net_namespace.c:448\n[<      none      >] process_one_work+0x794/0x1440 kernel/kernel/workqueue.c:2036\n[<      none      >] worker_thread+0xdb/0xfc0 kernel/kernel/workqueue.c:2170\n[<      none      >] kthread+0x23f/0x2d0 kernel/drivers/block/aoe/aoecmd.c:1303\n[<      none      >] ret_from_fork+0x3f/0x70 kernel/arch/x86/entry/entry_64.S:468\nINFO: Slab 0xffffea0001938800 objects=3 used=0 fp=0xffff880064e20000\nflags=0x5fffc0000004080\nINFO: Object 0xffff880064e20000 @offset=0 fp=0xffff880064e24200\n\nCPU: 1 PID: 11581 Comm: syz-executor Tainted: G    B           4.4.0+\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\nrel-1.8.2-0-g33fbe13 by qemu-project.org 04/01/2014\n 00000000ffffffff ffff8800662c7790 ffffffff8292049d ffff88003e36a300\n ffff880064e20000 ffff880064e20000 ffff8800662c77c0 ffffffff816f2054\n ffff88003e36a300 ffffea0001938800 ffff880064e20000 0000000000000000\nCall Trace:\n [<     inline     >] __dump_stack kernel/lib/dump_stack.c:15\n [<ffffffff8292049d>] dump_stack+0x6f/0xa2 kernel/lib/dump_stack.c:50\n [<ffffffff816f2054>] print_trailer+0xf4/0x150 kernel/mm/slub.c:654\n [<ffffffff816f875f>] object_err+0x2f/0x40 kernel/mm/slub.c:661\n [<     inline     >] print_address_description kernel/mm/kasan/report.c:138\n [<ffffffff816fb0c5>] kasan_report_error+0x215/0x530 kernel/mm/kasan/report.c:236\n [<     inline     >] kasan_report kernel/mm/kasan/report.c:259\n [<ffffffff816fb4de>] __asan_report_load8_noabort+0x3e/0x40 kernel/mm/kasan/report.c:280\n [<     inline     >] ? ppp_pernet kernel/include/linux/compiler.h:218\n [<ffffffff83ad71b2>] ? ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392\n [<     inline     >] ppp_pernet kernel/include/linux/compiler.h:218\n [<ffffffff83ad71b2>] ppp_unregister_channel+0x372/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392\n [<     inline     >] ? ppp_pernet kernel/drivers/net/ppp/ppp_generic.c:293\n [<ffffffff83ad6f26>] ? ppp_unregister_channel+0xe6/0x3a0 kernel/drivers/net/ppp/ppp_generic.c:2392\n [<ffffffff83ae18f3>] ppp_asynctty_close+0xa3/0x130 kernel/drivers/net/ppp/ppp_async.c:241\n [<ffffffff83ae1850>] ? async_lcp_peek+0x5b0/0x5b0 kernel/drivers/net/ppp/ppp_async.c:1000\n [<ffffffff82c33239>] tty_ldisc_close.isra.1+0x99/0xe0 kernel/drivers/tty/tty_ldisc.c:478\n [<ffffffff82c332c0>] tty_ldisc_kill+0x40/0x170 kernel/drivers/tty/tty_ldisc.c:744\n [<ffffffff82c34943>] tty_ldisc_release+0x1b3/0x260 kernel/drivers/tty/tty_ldisc.c:772\n [<ffffffff82c1ef21>] tty_release+0xac1/0x13e0 kernel/drivers/tty/tty_io.c:1901\n [<ffffffff82c1e460>] ? release_tty+0x320/0x320 kernel/drivers/tty/tty_io.c:1688\n [<ffffffff8174de36>] __fput+0x236/0x780 kernel/fs/file_table.c:208\n [<ffffffff8174e405>] ____fput+0x15/0x20 kernel/fs/file_table.c:244\n [<ffffffff813595ab>] task_work_run+0x16b/0x200 kernel/kernel/task_work.c:115\n [<     inline     >] exit_task_work kernel/include/linux/task_work.h:21\n [<ffffffff81307105>] do_exit+0x8b5/0x2c60 kernel/kernel/exit.c:750\n [<ffffffff813fdd20>] ? debug_check_no_locks_freed+0x290/0x290 kernel/kernel/locking/lockdep.c:4123\n [<ffffffff81306850>] ? mm_update_next_owner+0x6f0/0x6f0 kernel/kernel/exit.c:357\n [<ffffffff813215e6>] ? __dequeue_signal+0x136/0x470 kernel/kernel/signal.c:550\n [<ffffffff8132067b>] ? recalc_sigpending_tsk+0x13b/0x180 kernel/kernel/signal.c:145\n [<ffffffff81309628>] do_group_exit+0x108/0x330 kernel/kernel/exit.c:880\n [<ffffffff8132b9d4>] get_signal+0x5e4/0x14f0 kernel/kernel/signal.c:2307\n [<     inline     >] ? kretprobe_table_lock kernel/kernel/kprobes.c:1113\n [<ffffffff8151d355>] ? kprobe_flush_task+0xb5/0x450 kernel/kernel/kprobes.c:1158\n [<ffffffff8115f7d3>] do_signal+0x83/0x1c90 kernel/arch/x86/kernel/signal.c:712\n [<ffffffff8151d2a0>] ? recycle_rp_inst+0x310/0x310 kernel/include/linux/list.h:655\n [<ffffffff8115f750>] ? setup_sigcontext+0x780/0x780 kernel/arch/x86/kernel/signal.c:165\n [<ffffffff81380864>] ? finish_task_switch+0x424/0x5f0 kernel/kernel/sched/core.c:2692\n [<     inline     >] ? finish_lock_switch kernel/kernel/sched/sched.h:1099\n [<ffffffff81380560>] ? finish_task_switch+0x120/0x5f0 kernel/kernel/sched/core.c:2678\n [<     inline     >] ? context_switch kernel/kernel/sched/core.c:2807\n [<ffffffff85d794e9>] ? __schedule+0x919/0x1bd0 kernel/kernel/sched/core.c:3283\n [<ffffffff81003901>] exit_to_usermode_loop+0xf1/0x1a0 kernel/arch/x86/entry/common.c:247\n [<     inline     >] prepare_exit_to_usermode kernel/arch/x86/entry/common.c:282\n [<ffffffff810062ef>] syscall_return_slowpath+0x19f/0x210 kernel/arch/x86/entry/common.c:344\n [<ffffffff85d88022>] int_ret_from_sys_call+0x25/0x9f kernel/arch/x86/entry/entry_64.S:281\nMemory state around the buggy address:\n ffff880064e21680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff880064e21700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff880064e21780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                                       ^\n ffff880064e21800: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff880064e21880: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n==================================================================\n\nFixes: 273ec51dd7ce (\"net: ppp_generic - introduce net-namespace functionality v2\")\nReported-by: Baozeng Ding <sploving1@gmail.com>\nSigned-off-by: Guillaume Nault <g.nault@alphalink.fr>\nReviewed-by: Cyrill Gorcunov <gorcunov@openvz.org>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2016-03-23T18:35:31Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "html_url": "https://github.com/torvalds/linux/commit/1f461dcdd296eecedaffffc6bae2bfa90bd7eb89",
        "parents": [
            {
                "commit_id_before": "5197f3499c470ccc4b247db66ff883e597e3adda",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/5197f3499c470ccc4b247db66ff883e597e3adda",
                "html_url_before": "https://github.com/torvalds/linux/commit/5197f3499c470ccc4b247db66ff883e597e3adda"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1334,
        "cve_id": "CVE-2016-6828",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The tcp_check_send_head function in include/net/tcp.h in the Linux kernel before 4.7.5 does not properly maintain certain SACK state after a failed data copy, which allows local users to cause a denial of service (tcp_xmit_retransmit_queue use-after-free and system crash) via a crafted SACK option.",
        "cvss": "5.5",
        "publish_date": "October 16, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "bb1fceca22492109be12640d49f5ea5a544c6bb4",
        "commit_message": "tcp: fix use after free in tcp_xmit_retransmit_queue()\n\nWhen tcp_sendmsg() allocates a fresh and empty skb, it puts it at the\ntail of the write queue using tcp_add_write_queue_tail()\n\nThen it attempts to copy user data into this fresh skb.\n\nIf the copy fails, we undo the work and remove the fresh skb.\n\nUnfortunately, this undo lacks the change done to tp->highest_sack and\nwe can leave a dangling pointer (to a freed skb)\n\nLater, tcp_xmit_retransmit_queue() can dereference this pointer and\naccess freed memory. For regular kernels where memory is not unmapped,\nthis might cause SACK bugs because tcp_highest_sack_seq() is buggy,\nreturning garbage instead of tp->snd_nxt, but with various debug\nfeatures like CONFIG_DEBUG_PAGEALLOC, this can crash the kernel.\n\nThis bug was found by Marco Grassi thanks to syzkaller.\n\nFixes: 6859d49475d4 (\"[TCP]: Abstract tp->highest_sack accessing & point to next skb\")\nReported-by: Marco Grassi <marco.gra@gmail.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Ilpo J\u00e4rvinen <ilpo.jarvinen@helsinki.fi>\nCc: Yuchung Cheng <ycheng@google.com>\nCc: Neal Cardwell <ncardwell@google.com>\nAcked-by: Neal Cardwell <ncardwell@google.com>\nReviewed-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2016-08-19T06:22:57Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/bb1fceca22492109be12640d49f5ea5a544c6bb4",
        "html_url": "https://github.com/torvalds/linux/commit/bb1fceca22492109be12640d49f5ea5a544c6bb4",
        "parents": [
            {
                "commit_id_before": "e0d8b2908696d30583ae5764e33332e71cbbccc9",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/e0d8b2908696d30583ae5764e33332e71cbbccc9",
                "html_url_before": "https://github.com/torvalds/linux/commit/e0d8b2908696d30583ae5764e33332e71cbbccc9"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1377,
        "cve_id": "CVE-2016-7910",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the disk_seqf_stop function in block/genhd.c in the Linux kernel before 4.7.1 allows local users to gain privileges by leveraging the execution of a certain stop operation even if the corresponding start operation had failed.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "77da160530dd1dc94f6ae15a981f24e5f0021e84",
        "commit_message": "block: fix use-after-free in seq file\n\nI got a KASAN report of use-after-free:\n\n    ==================================================================\n    BUG: KASAN: use-after-free in klist_iter_exit+0x61/0x70 at addr ffff8800b6581508\n    Read of size 8 by task trinity-c1/315\n    =============================================================================\n    BUG kmalloc-32 (Not tainted): kasan: bad access detected\n    -----------------------------------------------------------------------------\n\n    Disabling lock debugging due to kernel taint\n    INFO: Allocated in disk_seqf_start+0x66/0x110 age=144 cpu=1 pid=315\n            ___slab_alloc+0x4f1/0x520\n            __slab_alloc.isra.58+0x56/0x80\n            kmem_cache_alloc_trace+0x260/0x2a0\n            disk_seqf_start+0x66/0x110\n            traverse+0x176/0x860\n            seq_read+0x7e3/0x11a0\n            proc_reg_read+0xbc/0x180\n            do_loop_readv_writev+0x134/0x210\n            do_readv_writev+0x565/0x660\n            vfs_readv+0x67/0xa0\n            do_preadv+0x126/0x170\n            SyS_preadv+0xc/0x10\n            do_syscall_64+0x1a1/0x460\n            return_from_SYSCALL_64+0x0/0x6a\n    INFO: Freed in disk_seqf_stop+0x42/0x50 age=160 cpu=1 pid=315\n            __slab_free+0x17a/0x2c0\n            kfree+0x20a/0x220\n            disk_seqf_stop+0x42/0x50\n            traverse+0x3b5/0x860\n            seq_read+0x7e3/0x11a0\n            proc_reg_read+0xbc/0x180\n            do_loop_readv_writev+0x134/0x210\n            do_readv_writev+0x565/0x660\n            vfs_readv+0x67/0xa0\n            do_preadv+0x126/0x170\n            SyS_preadv+0xc/0x10\n            do_syscall_64+0x1a1/0x460\n            return_from_SYSCALL_64+0x0/0x6a\n\n    CPU: 1 PID: 315 Comm: trinity-c1 Tainted: G    B           4.7.0+ #62\n    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Ubuntu-1.8.2-1ubuntu1 04/01/2014\n     ffffea0002d96000 ffff880119b9f918 ffffffff81d6ce81 ffff88011a804480\n     ffff8800b6581500 ffff880119b9f948 ffffffff8146c7bd ffff88011a804480\n     ffffea0002d96000 ffff8800b6581500 fffffffffffffff4 ffff880119b9f970\n    Call Trace:\n     [<ffffffff81d6ce81>] dump_stack+0x65/0x84\n     [<ffffffff8146c7bd>] print_trailer+0x10d/0x1a0\n     [<ffffffff814704ff>] object_err+0x2f/0x40\n     [<ffffffff814754d1>] kasan_report_error+0x221/0x520\n     [<ffffffff8147590e>] __asan_report_load8_noabort+0x3e/0x40\n     [<ffffffff83888161>] klist_iter_exit+0x61/0x70\n     [<ffffffff82404389>] class_dev_iter_exit+0x9/0x10\n     [<ffffffff81d2e8ea>] disk_seqf_stop+0x3a/0x50\n     [<ffffffff8151f812>] seq_read+0x4b2/0x11a0\n     [<ffffffff815f8fdc>] proc_reg_read+0xbc/0x180\n     [<ffffffff814b24e4>] do_loop_readv_writev+0x134/0x210\n     [<ffffffff814b4c45>] do_readv_writev+0x565/0x660\n     [<ffffffff814b8a17>] vfs_readv+0x67/0xa0\n     [<ffffffff814b8de6>] do_preadv+0x126/0x170\n     [<ffffffff814b92ec>] SyS_preadv+0xc/0x10\n\nThis problem can occur in the following situation:\n\nopen()\n - pread()\n    - .seq_start()\n       - iter = kmalloc() // succeeds\n       - seqf->private = iter\n    - .seq_stop()\n       - kfree(seqf->private)\n - pread()\n    - .seq_start()\n       - iter = kmalloc() // fails\n    - .seq_stop()\n       - class_dev_iter_exit(seqf->private) // boom! old pointer\n\nAs the comment in disk_seqf_stop() says, stop is called even if start\nfailed, so we need to reinitialise the private pointer to NULL when seq\niteration stops.\n\nAn alternative would be to set the private pointer to NULL when the\nkmalloc() in disk_seqf_start() fails.\n\nCc: stable@vger.kernel.org\nSigned-off-by: Vegard Nossum <vegard.nossum@oracle.com>\nAcked-by: Tejun Heo <tj@kernel.org>\nSigned-off-by: Jens Axboe <axboe@fb.com>",
        "commit_date": "2016-08-04T20:19:16Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/77da160530dd1dc94f6ae15a981f24e5f0021e84",
        "html_url": "https://github.com/torvalds/linux/commit/77da160530dd1dc94f6ae15a981f24e5f0021e84",
        "parents": [
            {
                "commit_id_before": "1aee6b9a7d947d42ed84baa4cf461e9d943b80f0",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/1aee6b9a7d947d42ed84baa4cf461e9d943b80f0",
                "html_url_before": "https://github.com/torvalds/linux/commit/1aee6b9a7d947d42ed84baa4cf461e9d943b80f0"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1382,
        "cve_id": "CVE-2016-7911",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the get_task_ioprio function in block/ioprio.c in the Linux kernel before 4.6.6 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted ioprio_get system call.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "8ba8682107ee2ca3347354e018865d8e1967c5f4",
        "commit_message": "block: fix use-after-free in sys_ioprio_get()\n\nget_task_ioprio() accesses the task->io_context without holding the task\nlock and thus can race with exit_io_context(), leading to a\nuse-after-free. The reproducer below hits this within a few seconds on\nmy 4-core QEMU VM:\n\n#define _GNU_SOURCE\n#include <assert.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/wait.h>\n\nint main(int argc, char **argv)\n{\n\tpid_t pid, child;\n\tlong nproc, i;\n\n\t/* ioprio_set(IOPRIO_WHO_PROCESS, 0, IOPRIO_PRIO_VALUE(IOPRIO_CLASS_IDLE, 0)); */\n\tsyscall(SYS_ioprio_set, 1, 0, 0x6000);\n\n\tnproc = sysconf(_SC_NPROCESSORS_ONLN);\n\n\tfor (i = 0; i < nproc; i++) {\n\t\tpid = fork();\n\t\tassert(pid != -1);\n\t\tif (pid == 0) {\n\t\t\tfor (;;) {\n\t\t\t\tpid = fork();\n\t\t\t\tassert(pid != -1);\n\t\t\t\tif (pid == 0) {\n\t\t\t\t\t_exit(0);\n\t\t\t\t} else {\n\t\t\t\t\tchild = wait(NULL);\n\t\t\t\t\tassert(child == pid);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpid = fork();\n\t\tassert(pid != -1);\n\t\tif (pid == 0) {\n\t\t\tfor (;;) {\n\t\t\t\t/* ioprio_get(IOPRIO_WHO_PGRP, 0); */\n\t\t\t\tsyscall(SYS_ioprio_get, 2, 0);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (;;) {\n\t\t/* ioprio_get(IOPRIO_WHO_PGRP, 0); */\n\t\tsyscall(SYS_ioprio_get, 2, 0);\n\t}\n\n\treturn 0;\n}\n\nThis gets us KASAN dumps like this:\n\n[   35.526914] ==================================================================\n[   35.530009] BUG: KASAN: out-of-bounds in get_task_ioprio+0x7b/0x90 at addr ffff880066f34e6c\n[   35.530009] Read of size 2 by task ioprio-gpf/363\n[   35.530009] =============================================================================\n[   35.530009] BUG blkdev_ioc (Not tainted): kasan: bad access detected\n[   35.530009] -----------------------------------------------------------------------------\n\n[   35.530009] Disabling lock debugging due to kernel taint\n[   35.530009] INFO: Allocated in create_task_io_context+0x2b/0x370 age=0 cpu=0 pid=360\n[   35.530009] \t___slab_alloc+0x55d/0x5a0\n[   35.530009] \t__slab_alloc.isra.20+0x2b/0x40\n[   35.530009] \tkmem_cache_alloc_node+0x84/0x200\n[   35.530009] \tcreate_task_io_context+0x2b/0x370\n[   35.530009] \tget_task_io_context+0x92/0xb0\n[   35.530009] \tcopy_process.part.8+0x5029/0x5660\n[   35.530009] \t_do_fork+0x155/0x7e0\n[   35.530009] \tSyS_clone+0x19/0x20\n[   35.530009] \tdo_syscall_64+0x195/0x3a0\n[   35.530009] \treturn_from_SYSCALL_64+0x0/0x6a\n[   35.530009] INFO: Freed in put_io_context+0xe7/0x120 age=0 cpu=0 pid=1060\n[   35.530009] \t__slab_free+0x27b/0x3d0\n[   35.530009] \tkmem_cache_free+0x1fb/0x220\n[   35.530009] \tput_io_context+0xe7/0x120\n[   35.530009] \tput_io_context_active+0x238/0x380\n[   35.530009] \texit_io_context+0x66/0x80\n[   35.530009] \tdo_exit+0x158e/0x2b90\n[   35.530009] \tdo_group_exit+0xe5/0x2b0\n[   35.530009] \tSyS_exit_group+0x1d/0x20\n[   35.530009] \tentry_SYSCALL_64_fastpath+0x1a/0xa4\n[   35.530009] INFO: Slab 0xffffea00019bcd00 objects=20 used=4 fp=0xffff880066f34ff0 flags=0x1fffe0000004080\n[   35.530009] INFO: Object 0xffff880066f34e58 @offset=3672 fp=0x0000000000000001\n[   35.530009] ==================================================================\n\nFix it by grabbing the task lock while we poke at the io_context.\n\nCc: stable@vger.kernel.org\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Omar Sandoval <osandov@fb.com>\nSigned-off-by: Jens Axboe <axboe@fb.com>",
        "commit_date": "2016-07-01T14:39:24Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/8ba8682107ee2ca3347354e018865d8e1967c5f4",
        "html_url": "https://github.com/torvalds/linux/commit/8ba8682107ee2ca3347354e018865d8e1967c5f4",
        "parents": [
            {
                "commit_id_before": "74524955556096a0b2a821a49b4d0abebad3ee16",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/74524955556096a0b2a821a49b4d0abebad3ee16",
                "html_url_before": "https://github.com/torvalds/linux/commit/74524955556096a0b2a821a49b4d0abebad3ee16"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1383,
        "cve_id": "CVE-2016-7912",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in the ffs_user_copy_worker function in drivers/usb/gadget/function/f_fs.c in the Linux kernel before 4.5.3 allows local users to gain privileges by accessing an I/O data structure after a certain callback call.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "38740a5b87d53ceb89eb2c970150f6e94e00373a",
        "commit_message": "usb: gadget: f_fs: Fix use-after-free\n\nWhen using asynchronous read or write operations on the USB endpoints the\nissuer of the IO request is notified by calling the ki_complete() callback\nof the submitted kiocb when the URB has been completed.\n\nCalling this ki_complete() callback will free kiocb. Make sure that the\nstructure is no longer accessed beyond that point, otherwise undefined\nbehaviour might occur.\n\nFixes: 2e4c7553cd6f (\"usb: gadget: f_fs: add aio support\")\nCc: <stable@vger.kernel.org> # v3.15+\nSigned-off-by: Lars-Peter Clausen <lars@metafoo.de>\nSigned-off-by: Felipe Balbi <felipe.balbi@linux.intel.com>",
        "commit_date": "2016-04-20T07:38:06Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/38740a5b87d53ceb89eb2c970150f6e94e00373a",
        "html_url": "https://github.com/torvalds/linux/commit/38740a5b87d53ceb89eb2c970150f6e94e00373a",
        "parents": [
            {
                "commit_id_before": "9772b47a4c2916d645c551228b6085ea24acbe5d",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/9772b47a4c2916d645c551228b6085ea24acbe5d",
                "html_url_before": "https://github.com/torvalds/linux/commit/9772b47a4c2916d645c551228b6085ea24acbe5d"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1376,
        "cve_id": "CVE-2016-7913",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The xc2028_set_config function in drivers/media/tuners/tuner-xc2028.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) via vectors involving omission of the firmware name from a certain data structure.",
        "cvss": "7.8",
        "publish_date": "November 15, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "8dfbcc4351a0b6d2f2d77f367552f48ffefafe18",
        "commit_message": "[media] xc2028: avoid use after free\n\nIf struct xc2028_config is passed without a firmware name,\nthe following trouble may happen:\n\n[11009.907205] xc2028 5-0061: type set to XCeive xc2028/xc3028 tuner\n[11009.907491] ==================================================================\n[11009.907750] BUG: KASAN: use-after-free in strcmp+0x96/0xb0 at addr ffff8803bd78ab40\n[11009.907992] Read of size 1 by task modprobe/28992\n[11009.907994] =============================================================================\n[11009.907997] BUG kmalloc-16 (Tainted: G        W      ): kasan: bad access detected\n[11009.907999] -----------------------------------------------------------------------------\n\n[11009.908008] INFO: Allocated in xhci_urb_enqueue+0x214/0x14c0 [xhci_hcd] age=0 cpu=3 pid=28992\n[11009.908012] \t___slab_alloc+0x581/0x5b0\n[11009.908014] \t__slab_alloc+0x51/0x90\n[11009.908017] \t__kmalloc+0x27b/0x350\n[11009.908022] \txhci_urb_enqueue+0x214/0x14c0 [xhci_hcd]\n[11009.908026] \tusb_hcd_submit_urb+0x1e8/0x1c60\n[11009.908029] \tusb_submit_urb+0xb0e/0x1200\n[11009.908032] \tusb_serial_generic_write_start+0xb6/0x4c0\n[11009.908035] \tusb_serial_generic_write+0x92/0xc0\n[11009.908039] \tusb_console_write+0x38a/0x560\n[11009.908045] \tcall_console_drivers.constprop.14+0x1ee/0x2c0\n[11009.908051] \tconsole_unlock+0x40d/0x900\n[11009.908056] \tvprintk_emit+0x4b4/0x830\n[11009.908061] \tvprintk_default+0x1f/0x30\n[11009.908064] \tprintk+0x99/0xb5\n[11009.908067] \tkasan_report_error+0x10a/0x550\n[11009.908070] \t__asan_report_load1_noabort+0x43/0x50\n[11009.908074] INFO: Freed in xc2028_set_config+0x90/0x630 [tuner_xc2028] age=1 cpu=3 pid=28992\n[11009.908077] \t__slab_free+0x2ec/0x460\n[11009.908080] \tkfree+0x266/0x280\n[11009.908083] \txc2028_set_config+0x90/0x630 [tuner_xc2028]\n[11009.908086] \txc2028_attach+0x310/0x8a0 [tuner_xc2028]\n[11009.908090] \tem28xx_attach_xc3028.constprop.7+0x1f9/0x30d [em28xx_dvb]\n[11009.908094] \tem28xx_dvb_init.part.3+0x8e4/0x5cf4 [em28xx_dvb]\n[11009.908098] \tem28xx_dvb_init+0x81/0x8a [em28xx_dvb]\n[11009.908101] \tem28xx_register_extension+0xd9/0x190 [em28xx]\n[11009.908105] \tem28xx_dvb_register+0x10/0x1000 [em28xx_dvb]\n[11009.908108] \tdo_one_initcall+0x141/0x300\n[11009.908111] \tdo_init_module+0x1d0/0x5ad\n[11009.908114] \tload_module+0x6666/0x9ba0\n[11009.908117] \tSyS_finit_module+0x108/0x130\n[11009.908120] \tentry_SYSCALL_64_fastpath+0x16/0x76\n[11009.908123] INFO: Slab 0xffffea000ef5e280 objects=25 used=25 fp=0x          (null) flags=0x2ffff8000004080\n[11009.908126] INFO: Object 0xffff8803bd78ab40 @offset=2880 fp=0x0000000000000001\n\n[11009.908130] Bytes b4 ffff8803bd78ab30: 01 00 00 00 2a 07 00 00 9d 28 00 00 01 00 00 00  ....*....(......\n[11009.908133] Object ffff8803bd78ab40: 01 00 00 00 00 00 00 00 b0 1d c3 6a 00 88 ff ff  ...........j....\n[11009.908137] CPU: 3 PID: 28992 Comm: modprobe Tainted: G    B   W       4.5.0-rc1+ #43\n[11009.908140] Hardware name:                  /NUC5i7RYB, BIOS RYBDWi35.86A.0350.2015.0812.1722 08/12/2015\n[11009.908142]  ffff8803bd78a000 ffff8802c273f1b8 ffffffff81932007 ffff8803c6407a80\n[11009.908148]  ffff8802c273f1e8 ffffffff81556759 ffff8803c6407a80 ffffea000ef5e280\n[11009.908153]  ffff8803bd78ab40 dffffc0000000000 ffff8802c273f210 ffffffff8155ccb4\n[11009.908158] Call Trace:\n[11009.908162]  [<ffffffff81932007>] dump_stack+0x4b/0x64\n[11009.908165]  [<ffffffff81556759>] print_trailer+0xf9/0x150\n[11009.908168]  [<ffffffff8155ccb4>] object_err+0x34/0x40\n[11009.908171]  [<ffffffff8155f260>] kasan_report_error+0x230/0x550\n[11009.908175]  [<ffffffff81237d71>] ? trace_hardirqs_off_caller+0x21/0x290\n[11009.908179]  [<ffffffff8155e926>] ? kasan_unpoison_shadow+0x36/0x50\n[11009.908182]  [<ffffffff8155f5c3>] __asan_report_load1_noabort+0x43/0x50\n[11009.908185]  [<ffffffff8155ea00>] ? __asan_register_globals+0x50/0xa0\n[11009.908189]  [<ffffffff8194cea6>] ? strcmp+0x96/0xb0\n[11009.908192]  [<ffffffff8194cea6>] strcmp+0x96/0xb0\n[11009.908196]  [<ffffffffa13ba4ac>] xc2028_set_config+0x15c/0x630 [tuner_xc2028]\n[11009.908200]  [<ffffffffa13bac90>] xc2028_attach+0x310/0x8a0 [tuner_xc2028]\n[11009.908203]  [<ffffffff8155ea78>] ? memset+0x28/0x30\n[11009.908206]  [<ffffffffa13ba980>] ? xc2028_set_config+0x630/0x630 [tuner_xc2028]\n[11009.908211]  [<ffffffffa157a59a>] em28xx_attach_xc3028.constprop.7+0x1f9/0x30d [em28xx_dvb]\n[11009.908215]  [<ffffffffa157aa2a>] ? em28xx_dvb_init.part.3+0x37c/0x5cf4 [em28xx_dvb]\n[11009.908219]  [<ffffffffa157a3a1>] ? hauppauge_hvr930c_init+0x487/0x487 [em28xx_dvb]\n[11009.908222]  [<ffffffffa01795ac>] ? lgdt330x_attach+0x1cc/0x370 [lgdt330x]\n[11009.908226]  [<ffffffffa01793e0>] ? i2c_read_demod_bytes.isra.2+0x210/0x210 [lgdt330x]\n[11009.908230]  [<ffffffff812e87d0>] ? ref_module.part.15+0x10/0x10\n[11009.908233]  [<ffffffff812e56e0>] ? module_assert_mutex_or_preempt+0x80/0x80\n[11009.908238]  [<ffffffffa157af92>] em28xx_dvb_init.part.3+0x8e4/0x5cf4 [em28xx_dvb]\n[11009.908242]  [<ffffffffa157a6ae>] ? em28xx_attach_xc3028.constprop.7+0x30d/0x30d [em28xx_dvb]\n[11009.908245]  [<ffffffff8195222d>] ? string+0x14d/0x1f0\n[11009.908249]  [<ffffffff8195381f>] ? symbol_string+0xff/0x1a0\n[11009.908253]  [<ffffffff81953720>] ? uuid_string+0x6f0/0x6f0\n[11009.908257]  [<ffffffff811a775e>] ? __kernel_text_address+0x7e/0xa0\n[11009.908260]  [<ffffffff8104b02f>] ? print_context_stack+0x7f/0xf0\n[11009.908264]  [<ffffffff812e9846>] ? __module_address+0xb6/0x360\n[11009.908268]  [<ffffffff8137fdc9>] ? is_ftrace_trampoline+0x99/0xe0\n[11009.908271]  [<ffffffff811a775e>] ? __kernel_text_address+0x7e/0xa0\n[11009.908275]  [<ffffffff81240a70>] ? debug_check_no_locks_freed+0x290/0x290\n[11009.908278]  [<ffffffff8104a24b>] ? dump_trace+0x11b/0x300\n[11009.908282]  [<ffffffffa13e8143>] ? em28xx_register_extension+0x23/0x190 [em28xx]\n[11009.908285]  [<ffffffff81237d71>] ? trace_hardirqs_off_caller+0x21/0x290\n[11009.908289]  [<ffffffff8123ff56>] ? trace_hardirqs_on_caller+0x16/0x590\n[11009.908292]  [<ffffffff812404dd>] ? trace_hardirqs_on+0xd/0x10\n[11009.908296]  [<ffffffffa13e8143>] ? em28xx_register_extension+0x23/0x190 [em28xx]\n[11009.908299]  [<ffffffff822dcbb0>] ? mutex_trylock+0x400/0x400\n[11009.908302]  [<ffffffff810021a1>] ? do_one_initcall+0x131/0x300\n[11009.908306]  [<ffffffff81296dc7>] ? call_rcu_sched+0x17/0x20\n[11009.908309]  [<ffffffff8159e708>] ? put_object+0x48/0x70\n[11009.908314]  [<ffffffffa1579f11>] em28xx_dvb_init+0x81/0x8a [em28xx_dvb]\n[11009.908317]  [<ffffffffa13e81f9>] em28xx_register_extension+0xd9/0x190 [em28xx]\n[11009.908320]  [<ffffffffa0150000>] ? 0xffffffffa0150000\n[11009.908324]  [<ffffffffa0150010>] em28xx_dvb_register+0x10/0x1000 [em28xx_dvb]\n[11009.908327]  [<ffffffff810021b1>] do_one_initcall+0x141/0x300\n[11009.908330]  [<ffffffff81002070>] ? try_to_run_init_process+0x40/0x40\n[11009.908333]  [<ffffffff8123ff56>] ? trace_hardirqs_on_caller+0x16/0x590\n[11009.908337]  [<ffffffff8155e926>] ? kasan_unpoison_shadow+0x36/0x50\n[11009.908340]  [<ffffffff8155e926>] ? kasan_unpoison_shadow+0x36/0x50\n[11009.908343]  [<ffffffff8155e926>] ? kasan_unpoison_shadow+0x36/0x50\n[11009.908346]  [<ffffffff8155ea37>] ? __asan_register_globals+0x87/0xa0\n[11009.908350]  [<ffffffff8144da7b>] do_init_module+0x1d0/0x5ad\n[11009.908353]  [<ffffffff812f2626>] load_module+0x6666/0x9ba0\n[11009.908356]  [<ffffffff812e9c90>] ? symbol_put_addr+0x50/0x50\n[11009.908361]  [<ffffffffa1580037>] ? em28xx_dvb_init.part.3+0x5989/0x5cf4 [em28xx_dvb]\n[11009.908366]  [<ffffffff812ebfc0>] ? module_frob_arch_sections+0x20/0x20\n[11009.908369]  [<ffffffff815bc940>] ? open_exec+0x50/0x50\n[11009.908374]  [<ffffffff811671bb>] ? ns_capable+0x5b/0xd0\n[11009.908377]  [<ffffffff812f5e58>] SyS_finit_module+0x108/0x130\n[11009.908379]  [<ffffffff812f5d50>] ? SyS_init_module+0x1f0/0x1f0\n[11009.908383]  [<ffffffff81004044>] ? lockdep_sys_exit_thunk+0x12/0x14\n[11009.908394]  [<ffffffff822e6936>] entry_SYSCALL_64_fastpath+0x16/0x76\n[11009.908396] Memory state around the buggy address:\n[11009.908398]  ffff8803bd78aa00: 00 00 fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[11009.908401]  ffff8803bd78aa80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[11009.908403] >ffff8803bd78ab00: fc fc fc fc fc fc fc fc 00 00 fc fc fc fc fc fc\n[11009.908405]                                            ^\n[11009.908407]  ffff8803bd78ab80: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[11009.908409]  ffff8803bd78ac00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n[11009.908411] ==================================================================\n\nIn order to avoid it, let's set the cached value of the firmware\nname to NULL after freeing it. While here, return an error if\nthe memory allocation fails.\n\nSigned-off-by: Mauro Carvalho Chehab <mchehab@osg.samsung.com>",
        "commit_date": "2016-02-01T09:16:18Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/8dfbcc4351a0b6d2f2d77f367552f48ffefafe18",
        "html_url": "https://github.com/torvalds/linux/commit/8dfbcc4351a0b6d2f2d77f367552f48ffefafe18",
        "parents": [
            {
                "commit_id_before": "d83a96a53dd2c36948be37b64a85a761b942ddfd",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/d83a96a53dd2c36948be37b64a85a761b942ddfd",
                "html_url_before": "https://github.com/torvalds/linux/commit/d83a96a53dd2c36948be37b64a85a761b942ddfd"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1454,
        "cve_id": "CVE-2016-8655",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in net/packet/af_packet.c in the Linux kernel through 4.8.12 allows local users to gain privileges or cause a denial of service (use-after-free) by leveraging the CAP_NET_RAW capability to change a socket version, related to the packet_set_ring and packet_setsockopt functions.",
        "cvss": "7.8",
        "publish_date": "December 8, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "84ac7260236a49c79eede91617700174c2c19b0c",
        "commit_message": "packet: fix race condition in packet_set_ring\n\nWhen packet_set_ring creates a ring buffer it will initialize a\nstruct timer_list if the packet version is TPACKET_V3. This value\ncan then be raced by a different thread calling setsockopt to\nset the version to TPACKET_V1 before packet_set_ring has finished.\n\nThis leads to a use-after-free on a function pointer in the\nstruct timer_list when the socket is closed as the previously\ninitialized timer will not be deleted.\n\nThe bug is fixed by taking lock_sock(sk) in packet_setsockopt when\nchanging the packet version while also taking the lock at the start\nof packet_set_ring.\n\nFixes: f6fb8f100b80 (\"af-packet: TPACKET_V3 flexible buffer implementation.\")\nSigned-off-by: Philip Pettersson <philip.pettersson@gmail.com>\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2016-12-02T17:16:49Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/84ac7260236a49c79eede91617700174c2c19b0c",
        "html_url": "https://github.com/torvalds/linux/commit/84ac7260236a49c79eede91617700174c2c19b0c",
        "parents": [
            {
                "commit_id_before": "2219d5ed77e8bdc2ef1f0b79f34d2cc0be802b25",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/2219d5ed77e8bdc2ef1f0b79f34d2cc0be802b25",
                "html_url_before": "https://github.com/torvalds/linux/commit/2219d5ed77e8bdc2ef1f0b79f34d2cc0be802b25"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1452,
        "cve_id": "CVE-2016-9120",
        "cwe_id": [
            "CWE-264",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the ion_ioctl function in drivers/staging/android/ion/ion.c in the Linux kernel before 4.6 allows local users to gain privileges or cause a denial of service (use-after-free) by calling ION_IOC_FREE on two CPUs at the same time.",
        "cvss": "7.8",
        "publish_date": "December 8, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "9590232bb4f4cc824f3425a6e1349afbe6d6d2b7",
        "commit_message": "staging/android/ion : fix a race condition in the ion driver\n\nThere is a use-after-free problem in the ion driver.\nThis is caused by a race condition in the ion_ioctl()\nfunction.\n\nA handle has ref count of 1 and two tasks on different\ncpus calls ION_IOC_FREE simultaneously.\n\ncpu 0                                   cpu 1\n-------------------------------------------------------\nion_handle_get_by_id()\n(ref == 2)\n                            ion_handle_get_by_id()\n                            (ref == 3)\n\nion_free()\n(ref == 2)\n\nion_handle_put()\n(ref == 1)\n\n                            ion_free()\n                            (ref == 0 so ion_handle_destroy() is\n                            called\n                            and the handle is freed.)\n\n                            ion_handle_put() is called and it\n                            decreases the slub's next free pointer\n\nThe problem is detected as an unaligned access in the\nspin lock functions since it uses load exclusive\n instruction. In some cases it corrupts the slub's\nfree pointer which causes a mis-aligned access to the\nnext free pointer.(kmalloc returns a pointer like\nffffc0745b4580aa). And it causes lots of other\nhard-to-debug problems.\n\nThis symptom is caused since the first member in the\nion_handle structure is the reference count and the\nion driver decrements the reference after it has been\nfreed.\n\nTo fix this problem client->lock mutex is extended\nto protect all the codes that uses the handle.\n\nSigned-off-by: Eun Taik Lee <eun.taik.lee@samsung.com>\nReviewed-by: Laura Abbott <labbott@redhat.com>\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "commit_date": "2016-03-12T06:09:09Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7",
        "html_url": "https://github.com/torvalds/linux/commit/9590232bb4f4cc824f3425a6e1349afbe6d6d2b7",
        "parents": [
            {
                "commit_id_before": "5a20df724f712e9daa9fd41b430ff63ecd203e85",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/5a20df724f712e9daa9fd41b430ff63ecd203e85",
                "html_url_before": "https://github.com/torvalds/linux/commit/5a20df724f712e9daa9fd41b430ff63ecd203e85"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1420,
        "cve_id": "CVE-2016-9576",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The blk_rq_map_user_iov function in block/blk-map.c in the Linux kernel before 4.8.14 does not properly restrict the type of iterator, which allows local users to read or write to arbitrary kernel memory locations or cause a denial of service (use-after-free) by leveraging access to a /dev/sg device.",
        "cvss": "7.8",
        "publish_date": "December 28, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "a0ac402cfcdc904f9772e1762b3fda112dcc56a0",
        "commit_message": "Don't feed anything but regular iovec's to blk_rq_map_user_iov\n\nIn theory we could map other things, but there's a reason that function\nis called \"user_iov\".  Using anything else (like splice can do) just\nconfuses it.\n\nReported-and-tested-by: Johannes Thumshirn <jthumshirn@suse.de>\nCc: Al Viro <viro@ZenIV.linux.org.uk>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2016-12-07T16:23:35Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/a0ac402cfcdc904f9772e1762b3fda112dcc56a0",
        "html_url": "https://github.com/torvalds/linux/commit/a0ac402cfcdc904f9772e1762b3fda112dcc56a0",
        "parents": [
            {
                "commit_id_before": "bc3913a5378cd0ddefd1dfec6917cc12eb23a946",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/bc3913a5378cd0ddefd1dfec6917cc12eb23a946",
                "html_url_before": "https://github.com/torvalds/linux/commit/bc3913a5378cd0ddefd1dfec6917cc12eb23a946"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1423,
        "cve_id": "CVE-2016-9794",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the snd_pcm_period_elapsed function in sound/core/pcm_lib.c in the ALSA subsystem in the Linux kernel before 4.7 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a crafted SNDRV_PCM_TRIGGER_START command.",
        "cvss": "7.8",
        "publish_date": "December 28, 2016",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4",
        "commit_message": "ALSA: pcm : Call kill_fasync() in stream lock\n\nCurrently kill_fasync() is called outside the stream lock in\nsnd_pcm_period_elapsed().  This is potentially racy, since the stream\nmay get released even during the irq handler is running.  Although\nsnd_pcm_release_substream() calls snd_pcm_drop(), this doesn't\nguarantee that the irq handler finishes, thus the kill_fasync() call\noutside the stream spin lock may be invoked after the substream is\ndetached, as recently reported by KASAN.\n\nAs a quick workaround, move kill_fasync() call inside the stream\nlock.  The fasync is rarely used interface, so this shouldn't have a\nbig impact from the performance POV.\n\nIdeally, we should implement some sync mechanism for the proper finish\nof stream and irq handler.  But this oneliner should suffice for most\ncases, so far.\n\nReported-by: Baozeng Ding <sploving1@gmail.com>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2016-04-14T16:02:37Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4",
        "html_url": "https://github.com/torvalds/linux/commit/3aa02cb664c5fb1042958c8d1aa8c35055a2ebc4",
        "parents": [
            {
                "commit_id_before": "fa44b7ec9bc4115513e59f31da1167166bd6346a",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/fa44b7ec9bc4115513e59f31da1167166bd6346a",
                "html_url_before": "https://github.com/torvalds/linux/commit/fa44b7ec9bc4115513e59f31da1167166bd6346a"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2209,
        "cve_id": "CVE-2017-10661",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in fs/timerfd.c in the Linux kernel before 4.10.15 allows local users to gain privileges or cause a denial of service (list corruption or use-after-free) via simultaneous file-descriptor operations that leverage improper might_cancel queueing.",
        "cvss": "7.0",
        "publish_date": "August 19, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "1e38da300e1e395a15048b0af1e5305bd91402f6",
        "commit_message": "timerfd: Protect the might cancel mechanism proper\n\nThe handling of the might_cancel queueing is not properly protected, so\nparallel operations on the file descriptor can race with each other and\nlead to list corruptions or use after free.\n\nProtect the context for these operations with a seperate lock.\n\nThe wait queue lock cannot be reused for this because that would create a\nlock inversion scenario vs. the cancel lock. Replacing might_cancel with an\natomic (atomic_t or atomic bit) does not help either because it still can\nrace vs. the actual list operation.\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>\nCc: \"linux-fsdevel@vger.kernel.org\"\nCc: syzkaller <syzkaller@googlegroups.com>\nCc: Al Viro <viro@zeniv.linux.org.uk>\nCc: linux-fsdevel@vger.kernel.org\nLink: http://lkml.kernel.org/r/alpine.DEB.2.20.1701311521430.3457@nanos\nSigned-off-by: Thomas Gleixner <tglx@linutronix.de>",
        "commit_date": "2017-02-10T10:15:09Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1e38da300e1e395a15048b0af1e5305bd91402f6",
        "html_url": "https://github.com/torvalds/linux/commit/1e38da300e1e395a15048b0af1e5305bd91402f6",
        "parents": [
            {
                "commit_id_before": "7551b02b94ad1daee3a79d667dc3c46d08328f87",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/7551b02b94ad1daee3a79d667dc3c46d08328f87",
                "html_url_before": "https://github.com/torvalds/linux/commit/7551b02b94ad1daee3a79d667dc3c46d08328f87"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2150,
        "cve_id": "CVE-2017-11176",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The mq_notify function in the Linux kernel through 4.11.9 does not set the sock pointer to NULL upon entry into the retry logic. During a user-space close of a Netlink socket, it allows attackers to cause a denial of service (use-after-free) or possibly have unspecified other impact.",
        "cvss": "7.8",
        "publish_date": "July 11, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "f991af3daabaecff34684fd51fac80319d1baad1",
        "commit_message": "mqueue: fix a use-after-free in sys_mq_notify()\n\nThe retry logic for netlink_attachskb() inside sys_mq_notify()\nis nasty and vulnerable:\n\n1) The sock refcnt is already released when retry is needed\n2) The fd is controllable by user-space because we already\n   release the file refcnt\n\nso we when retry but the fd has been just closed by user-space\nduring this small window, we end up calling netlink_detachskb()\non the error path which releases the sock again, later when\nthe user-space closes this socket a use-after-free could be\ntriggered.\n\nSetting 'sock' to NULL here should be sufficient to fix it.\n\nReported-by: GeneBlue <geneblue.mail@gmail.com>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Manfred Spraul <manfred@colorfullife.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2017-07-09T21:37:19Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/f991af3daabaecff34684fd51fac80319d1baad1",
        "html_url": "https://github.com/torvalds/linux/commit/f991af3daabaecff34684fd51fac80319d1baad1",
        "parents": [
            {
                "commit_id_before": "2b976203417cf033079e0be30cae5f41d88e385e",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/2b976203417cf033079e0be30cae5f41d88e385e",
                "html_url_before": "https://github.com/torvalds/linux/commit/2b976203417cf033079e0be30cae5f41d88e385e"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2535,
        "cve_id": "CVE-2017-15115",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The sctp_do_peeloff function in net/sctp/socket.c in the Linux kernel before 4.14 does not check whether the intended netns is used in a peel-off action, which allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls.",
        "cvss": "7.8",
        "publish_date": "November 15, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "df80cd9b28b9ebaa284a41df611dbf3a2d05ca74",
        "commit_message": "sctp: do not peel off an assoc from one netns to another one\n\nNow when peeling off an association to the sock in another netns, all\ntransports in this assoc are not to be rehashed and keep use the old\nkey in hashtable.\n\nAs a transport uses sk->net as the hash key to insert into hashtable,\nit would miss removing these transports from hashtable due to the new\nnetns when closing the sock and all transports are being freeed, then\nlater an use-after-free issue could be caused when looking up an asoc\nand dereferencing those transports.\n\nThis is a very old issue since very beginning, ChunYu found it with\nsyzkaller fuzz testing with this series:\n\n  socket$inet6_sctp()\n  bind$inet6()\n  sendto$inet6()\n  unshare(0x40000000)\n  getsockopt$inet_sctp6_SCTP_GET_ASSOC_ID_LIST()\n  getsockopt$inet_sctp6_SCTP_SOCKOPT_PEELOFF()\n\nThis patch is to block this call when peeling one assoc off from one\nnetns to another one, so that the netns of all transport would not\ngo out-sync with the key in hashtable.\n\nNote that this patch didn't fix it by rehashing transports, as it's\ndifficult to handle the situation when the tuple is already in use\nin the new netns. Besides, no one would like to peel off one assoc\nto another netns, considering ipaddrs, ifaces, etc. are usually\ndifferent.\n\nReported-by: ChunYu Wang <chunwang@redhat.com>\nSigned-off-by: Xin Long <lucien.xin@gmail.com>\nAcked-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>\nAcked-by: Neil Horman <nhorman@tuxdriver.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2017-10-19T12:16:07Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74",
        "html_url": "https://github.com/torvalds/linux/commit/df80cd9b28b9ebaa284a41df611dbf3a2d05ca74",
        "parents": [
            {
                "commit_id_before": "4bbb5083484016d4448739237aa1e6a9577ebb43",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/4bbb5083484016d4448739237aa1e6a9577ebb43",
                "html_url_before": "https://github.com/torvalds/linux/commit/4bbb5083484016d4448739237aa1e6a9577ebb43"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2644,
        "cve_id": "CVE-2017-15126",
        "cwe_id": [
            "CWE-119",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in fs/userfaultfd.c in the Linux kernel before 4.13.6. The issue is related to the handling of fork failure when dealing with event messages. Failure to fork correctly can lead to a situation where a fork event will be removed from an already freed list of events with userfaultfd_ctx_put().",
        "cvss": "5.5",
        "publish_date": "January 14, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "NONE",
        "commit_id": "384632e67e0829deb8015ee6ad916b180049d252",
        "commit_message": "userfaultfd: non-cooperative: fix fork use after free\n\nWhen reading the event from the uffd, we put it on a temporary\nfork_event list to detect if we can still access it after releasing and\nretaking the event_wqh.lock.\n\nIf fork aborts and removes the event from the fork_event all is fine as\nlong as we're still in the userfault read context and fork_event head is\nstill alive.\n\nWe've to put the event allocated in the fork kernel stack, back from\nfork_event list-head to the event_wqh head, before returning from\nuserfaultfd_ctx_read, because the fork_event head lifetime is limited to\nthe userfaultfd_ctx_read stack lifetime.\n\nForgetting to move the event back to its event_wqh place then results in\n__remove_wait_queue(&ctx->event_wqh, &ewq->wq); in\nuserfaultfd_event_wait_completion to remove it from a head that has been\nalready freed from the reader stack.\n\nThis could only happen if resolve_userfault_fork failed (for example if\nthere are no file descriptors available to allocate the fork uffd).  If\nit succeeded it was put back correctly.\n\nFurthermore, after find_userfault_evt receives a fork event, the forked\nuserfault context in fork_nctx and uwq->msg.arg.reserved.reserved1 can\nbe released by the fork thread as soon as the event_wqh.lock is\nreleased.  Taking a reference on the fork_nctx before dropping the lock\nprevents an use after free in resolve_userfault_fork().\n\nIf the fork side aborted and it already released everything, we still\ntry to succeed resolve_userfault_fork(), if possible.\n\nFixes: 893e26e61d04eac9 (\"userfaultfd: non-cooperative: Add fork() event\")\nLink: http://lkml.kernel.org/r/20170920180413.26713-1-aarcange@redhat.com\nSigned-off-by: Andrea Arcangeli <aarcange@redhat.com>\nReported-by: Mark Rutland <mark.rutland@arm.com>\nTested-by: Mark Rutland <mark.rutland@arm.com>\nCc: Pavel Emelyanov <xemul@virtuozzo.com>\nCc: Mike Rapoport <rppt@linux.vnet.ibm.com>\nCc: \"Dr. David Alan Gilbert\" <dgilbert@redhat.com>\nCc: Mike Kravetz <mike.kravetz@oracle.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2017-10-04T00:54:25Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/384632e67e0829deb8015ee6ad916b180049d252",
        "html_url": "https://github.com/torvalds/linux/commit/384632e67e0829deb8015ee6ad916b180049d252",
        "parents": [
            {
                "commit_id_before": "7d790d2da386a52cfebcf0c898ba927bece9d4ab",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/7d790d2da386a52cfebcf0c898ba927bece9d4ab",
                "html_url_before": "https://github.com/torvalds/linux/commit/7d790d2da386a52cfebcf0c898ba927bece9d4ab"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2652,
        "cve_id": "CVE-2017-15129",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free vulnerability was found in network namespaces code affecting the Linux kernel before 4.14.11. The function get_net_ns_by_id() in net/core/net_namespace.c does not check for the net::count value after it has found a peer network in netns_ids idr, which could lead to double free and memory corruption. This vulnerability could allow an unprivileged local user to induce kernel memory corruption on the system, leading to a crash. Due to the nature of the flaw, privilege escalation cannot be fully ruled out, although it is thought to be unlikely.",
        "cvss": "8.8",
        "publish_date": "January 9, 2018",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "21b5944350052d2583e82dd59b19a9ba94a007f0",
        "commit_message": "net: Fix double free and memory corruption in get_net_ns_by_id()\n\n(I can trivially verify that that idr_remove in cleanup_net happens\n after the network namespace count has dropped to zero --EWB)\n\nFunction get_net_ns_by_id() does not check for net::count\nafter it has found a peer in netns_ids idr.\n\nIt may dereference a peer, after its count has already been\nfinaly decremented. This leads to double free and memory\ncorruption:\n\nput_net(peer)                                   rtnl_lock()\natomic_dec_and_test(&peer->count) [count=0]     ...\n__put_net(peer)                                 get_net_ns_by_id(net, id)\n  spin_lock(&cleanup_list_lock)\n  list_add(&net->cleanup_list, &cleanup_list)\n  spin_unlock(&cleanup_list_lock)\nqueue_work()                                      peer = idr_find(&net->netns_ids, id)\n  |                                               get_net(peer) [count=1]\n  |                                               ...\n  |                                               (use after final put)\n  v                                               ...\n  cleanup_net()                                   ...\n    spin_lock(&cleanup_list_lock)                 ...\n    list_replace_init(&cleanup_list, ..)          ...\n    spin_unlock(&cleanup_list_lock)               ...\n    ...                                           ...\n    ...                                           put_net(peer)\n    ...                                             atomic_dec_and_test(&peer->count) [count=0]\n    ...                                               spin_lock(&cleanup_list_lock)\n    ...                                               list_add(&net->cleanup_list, &cleanup_list)\n    ...                                               spin_unlock(&cleanup_list_lock)\n    ...                                             queue_work()\n    ...                                           rtnl_unlock()\n    rtnl_lock()                                   ...\n    for_each_net(tmp) {                           ...\n      id = __peernet2id(tmp, peer)                ...\n      spin_lock_irq(&tmp->nsid_lock)              ...\n      idr_remove(&tmp->netns_ids, id)             ...\n      ...                                         ...\n      net_drop_ns()                               ...\n\tnet_free(peer)                            ...\n    }                                             ...\n  |\n  v\n  cleanup_net()\n    ...\n    (Second free of peer)\n\nAlso, put_net() on the right cpu may reorder with left's cpu\nlist_replace_init(&cleanup_list, ..), and then cleanup_list\nwill be corrupted.\n\nSince cleanup_net() is executed in worker thread, while\nput_net(peer) can happen everywhere, there should be\nenough time for concurrent get_net_ns_by_id() to pick\nthe peer up, and the race does not seem to be unlikely.\nThe patch fixes the problem in standard way.\n\n(Also, there is possible problem in peernet2id_alloc(), which requires\ncheck for net::count under nsid_lock and maybe_get_net(peer), but\nin current stable kernel it's used under rtnl_lock() and it has to be\nsafe. Openswitch begun to use peernet2id_alloc(), and possibly it should\nbe fixed too. While this is not in stable kernel yet, so I'll send\na separate message to netdev@ later).\n\nCc: Nicolas Dichtel <nicolas.dichtel@6wind.com>\nSigned-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>\nFixes: 0c7aecd4bde4 \"netns: add rtnl cmd to add and get peer netns ids\"\nReviewed-by: Andrey Ryabinin <aryabinin@virtuozzo.com>\nReviewed-by: \"Eric W. Biederman\" <ebiederm@xmission.com>\nSigned-off-by: Eric W. Biederman <ebiederm@xmission.com>\nReviewed-by: Eric Dumazet <edumazet@google.com>\nAcked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2017-12-20T17:42:22Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/21b5944350052d2583e82dd59b19a9ba94a007f0",
        "html_url": "https://github.com/torvalds/linux/commit/21b5944350052d2583e82dd59b19a9ba94a007f0",
        "parents": [
            {
                "commit_id_before": "eda9873e19d83c68d0c477f6bc13718fee7a7b3c",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/eda9873e19d83c68d0c477f6bc13718fee7a7b3c",
                "html_url_before": "https://github.com/torvalds/linux/commit/eda9873e19d83c68d0c477f6bc13718fee7a7b3c"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2487,
        "cve_id": "CVE-2017-15265",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in the ALSA subsystem in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted /dev/snd/seq ioctl calls, related to sound/core/seq/seq_clientmgr.c and sound/core/seq/seq_ports.c.",
        "cvss": "7.0",
        "publish_date": "October 16, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "71105998845fb012937332fe2e806d443c09e026",
        "commit_message": "ALSA: seq: Fix use-after-free at creating a port\n\nThere is a potential race window opened at creating and deleting a\nport via ioctl, as spotted by fuzzing.  snd_seq_create_port() creates\na port object and returns its pointer, but it doesn't take the\nrefcount, thus it can be deleted immediately by another thread.\nMeanwhile, snd_seq_ioctl_create_port() still calls the function\nsnd_seq_system_client_ev_port_start() with the created port object\nthat is being deleted, and this triggers use-after-free like:\n\n BUG: KASAN: use-after-free in snd_seq_ioctl_create_port+0x504/0x630 [snd_seq] at addr ffff8801f2241cb1\n =============================================================================\n BUG kmalloc-512 (Tainted: G    B          ): kasan: bad access detected\n -----------------------------------------------------------------------------\n INFO: Allocated in snd_seq_create_port+0x94/0x9b0 [snd_seq] age=1 cpu=3 pid=4511\n \t___slab_alloc+0x425/0x460\n \t__slab_alloc+0x20/0x40\n  \tkmem_cache_alloc_trace+0x150/0x190\n\tsnd_seq_create_port+0x94/0x9b0 [snd_seq]\n\tsnd_seq_ioctl_create_port+0xd1/0x630 [snd_seq]\n \tsnd_seq_do_ioctl+0x11c/0x190 [snd_seq]\n \tsnd_seq_ioctl+0x40/0x80 [snd_seq]\n \tdo_vfs_ioctl+0x54b/0xda0\n \tSyS_ioctl+0x79/0x90\n \tentry_SYSCALL_64_fastpath+0x16/0x75\n INFO: Freed in port_delete+0x136/0x1a0 [snd_seq] age=1 cpu=2 pid=4717\n \t__slab_free+0x204/0x310\n \tkfree+0x15f/0x180\n \tport_delete+0x136/0x1a0 [snd_seq]\n \tsnd_seq_delete_port+0x235/0x350 [snd_seq]\n \tsnd_seq_ioctl_delete_port+0xc8/0x180 [snd_seq]\n \tsnd_seq_do_ioctl+0x11c/0x190 [snd_seq]\n \tsnd_seq_ioctl+0x40/0x80 [snd_seq]\n \tdo_vfs_ioctl+0x54b/0xda0\n \tSyS_ioctl+0x79/0x90\n \tentry_SYSCALL_64_fastpath+0x16/0x75\n Call Trace:\n  [<ffffffff81b03781>] dump_stack+0x63/0x82\n  [<ffffffff81531b3b>] print_trailer+0xfb/0x160\n  [<ffffffff81536db4>] object_err+0x34/0x40\n  [<ffffffff815392d3>] kasan_report.part.2+0x223/0x520\n  [<ffffffffa07aadf4>] ? snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]\n  [<ffffffff815395fe>] __asan_report_load1_noabort+0x2e/0x30\n  [<ffffffffa07aadf4>] snd_seq_ioctl_create_port+0x504/0x630 [snd_seq]\n  [<ffffffffa07aa8f0>] ? snd_seq_ioctl_delete_port+0x180/0x180 [snd_seq]\n  [<ffffffff8136be50>] ? taskstats_exit+0xbc0/0xbc0\n  [<ffffffffa07abc5c>] snd_seq_do_ioctl+0x11c/0x190 [snd_seq]\n  [<ffffffffa07abd10>] snd_seq_ioctl+0x40/0x80 [snd_seq]\n  [<ffffffff8136d433>] ? acct_account_cputime+0x63/0x80\n  [<ffffffff815b515b>] do_vfs_ioctl+0x54b/0xda0\n  .....\n\nWe may fix this in a few different ways, and in this patch, it's fixed\nsimply by taking the refcount properly at snd_seq_create_port() and\nletting the caller unref the object after use.  Also, there is another\npotential use-after-free by sprintf() call in snd_seq_create_port(),\nand this is moved inside the lock.\n\nThis fix covers CVE-2017-15265.\n\nReported-and-tested-by: Michael23 Yu <ycqzsy@gmail.com>\nSuggested-by: Linus Torvalds <torvalds@linux-foundation.org>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2017-10-11T07:58:18Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/71105998845fb012937332fe2e806d443c09e026",
        "html_url": "https://github.com/torvalds/linux/commit/71105998845fb012937332fe2e806d443c09e026",
        "parents": [
            {
                "commit_id_before": "124751d5e63c823092060074bd0abaae61aaa9c4",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/124751d5e63c823092060074bd0abaae61aaa9c4",
                "html_url_before": "https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2567,
        "cve_id": "CVE-2017-16525",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup.",
        "cvss": "6.6",
        "publish_date": "November 3, 2017",
        "AV": "PHYSICAL",
        "AC": "PHYSICAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "bd998c2e0df0469707503023d50d46cf0b10c787",
        "commit_message": "USB: serial: console: fix use-after-free on disconnect\n\nA clean-up patch removing two redundant NULL-checks from the console\ndisconnect handler inadvertently also removed a third check. This could\nlead to the struct usb_serial being prematurely freed by the console\ncode when a driver accepts but does not register any ports for an\ninterface which also lacks endpoint descriptors.\n\nFixes: 0e517c93dc02 (\"USB: serial: console: clean up sanity checks\")\nCc: stable <stable@vger.kernel.org>     # 4.11\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nAcked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Johan Hovold <johan@kernel.org>",
        "commit_date": "2017-10-09T10:33:04Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/bd998c2e0df0469707503023d50d46cf0b10c787",
        "html_url": "https://github.com/torvalds/linux/commit/bd998c2e0df0469707503023d50d46cf0b10c787",
        "parents": [
            {
                "commit_id_before": "f5d9644c5fca7d8e8972268598bb516a7eae17f9",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f5d9644c5fca7d8e8972268598bb516a7eae17f9",
                "html_url_before": "https://github.com/torvalds/linux/commit/f5d9644c5fca7d8e8972268598bb516a7eae17f9"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2568,
        "cve_id": "CVE-2017-16525",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The usb_serial_console_disconnect function in drivers/usb/serial/console.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device, related to disconnection and failed setup.",
        "cvss": "6.6",
        "publish_date": "November 3, 2017",
        "AV": "PHYSICAL",
        "AC": "PHYSICAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "299d7572e46f98534033a9e65973f13ad1ce9047",
        "commit_message": "USB: serial: console: fix use-after-free after failed setup\n\nMake sure to reset the USB-console port pointer when console setup fails\nin order to avoid having the struct usb_serial be prematurely freed by\nthe console code when the device is later disconnected.\n\nFixes: 73e487fdb75f (\"[PATCH] USB console: fix disconnection issues\")\nCc: stable <stable@vger.kernel.org>\t# 2.6.18\nAcked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>\nSigned-off-by: Johan Hovold <johan@kernel.org>",
        "commit_date": "2017-10-09T10:33:31Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/299d7572e46f98534033a9e65973f13ad1ce9047",
        "html_url": "https://github.com/torvalds/linux/commit/299d7572e46f98534033a9e65973f13ad1ce9047",
        "parents": [
            {
                "commit_id_before": "bd998c2e0df0469707503023d50d46cf0b10c787",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/bd998c2e0df0469707503023d50d46cf0b10c787",
                "html_url_before": "https://github.com/torvalds/linux/commit/bd998c2e0df0469707503023d50d46cf0b10c787"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2561,
        "cve_id": "CVE-2017-16527",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "sound/usb/mixer.c in the Linux kernel before 4.13.8 allows local users to cause a denial of service (snd_usb_mixer_interrupt use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device.",
        "cvss": "6.6",
        "publish_date": "November 3, 2017",
        "AV": "PHYSICAL",
        "AC": "PHYSICAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "124751d5e63c823092060074bd0abaae61aaa9c4",
        "commit_message": "ALSA: usb-audio: Kill stray URB at exiting\n\nUSB-audio driver may leave a stray URB for the mixer interrupt when it\nexits by some error during probe.  This leads to a use-after-free\nerror as spotted by syzkaller like:\n  ==================================================================\n  BUG: KASAN: use-after-free in snd_usb_mixer_interrupt+0x604/0x6f0\n  Call Trace:\n   <IRQ>\n   __dump_stack lib/dump_stack.c:16\n   dump_stack+0x292/0x395 lib/dump_stack.c:52\n   print_address_description+0x78/0x280 mm/kasan/report.c:252\n   kasan_report_error mm/kasan/report.c:351\n   kasan_report+0x23d/0x350 mm/kasan/report.c:409\n   __asan_report_load8_noabort+0x19/0x20 mm/kasan/report.c:430\n   snd_usb_mixer_interrupt+0x604/0x6f0 sound/usb/mixer.c:2490\n   __usb_hcd_giveback_urb+0x2e0/0x650 drivers/usb/core/hcd.c:1779\n   ....\n\n  Allocated by task 1484:\n   save_stack_trace+0x1b/0x20 arch/x86/kernel/stacktrace.c:59\n   save_stack+0x43/0xd0 mm/kasan/kasan.c:447\n   set_track mm/kasan/kasan.c:459\n   kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551\n   kmem_cache_alloc_trace+0x11e/0x2d0 mm/slub.c:2772\n   kmalloc ./include/linux/slab.h:493\n   kzalloc ./include/linux/slab.h:666\n   snd_usb_create_mixer+0x145/0x1010 sound/usb/mixer.c:2540\n   create_standard_mixer_quirk+0x58/0x80 sound/usb/quirks.c:516\n   snd_usb_create_quirk+0x92/0x100 sound/usb/quirks.c:560\n   create_composite_quirk+0x1c4/0x3e0 sound/usb/quirks.c:59\n   snd_usb_create_quirk+0x92/0x100 sound/usb/quirks.c:560\n   usb_audio_probe+0x1040/0x2c10 sound/usb/card.c:618\n   ....\n\n  Freed by task 1484:\n   save_stack_trace+0x1b/0x20 arch/x86/kernel/stacktrace.c:59\n   save_stack+0x43/0xd0 mm/kasan/kasan.c:447\n   set_track mm/kasan/kasan.c:459\n   kasan_slab_free+0x72/0xc0 mm/kasan/kasan.c:524\n   slab_free_hook mm/slub.c:1390\n   slab_free_freelist_hook mm/slub.c:1412\n   slab_free mm/slub.c:2988\n   kfree+0xf6/0x2f0 mm/slub.c:3919\n   snd_usb_mixer_free+0x11a/0x160 sound/usb/mixer.c:2244\n   snd_usb_mixer_dev_free+0x36/0x50 sound/usb/mixer.c:2250\n   __snd_device_free+0x1ff/0x380 sound/core/device.c:91\n   snd_device_free_all+0x8f/0xe0 sound/core/device.c:244\n   snd_card_do_free sound/core/init.c:461\n   release_card_device+0x47/0x170 sound/core/init.c:181\n   device_release+0x13f/0x210 drivers/base/core.c:814\n   ....\n\nActually such a URB is killed properly at disconnection when the\ndevice gets probed successfully, and what we need is to apply it for\nthe error-path, too.\n\nIn this patch, we apply snd_usb_mixer_disconnect() at releasing.\nAlso introduce a new flag, disconnected, to struct usb_mixer_interface\nfor not performing the disconnection procedure twice.\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2017-10-10T12:17:09Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/124751d5e63c823092060074bd0abaae61aaa9c4",
        "html_url": "https://github.com/torvalds/linux/commit/124751d5e63c823092060074bd0abaae61aaa9c4",
        "parents": [
            {
                "commit_id_before": "c95072b3d88fac4be295815f2b67df366c0c297f",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c95072b3d88fac4be295815f2b67df366c0c297f",
                "html_url_before": "https://github.com/torvalds/linux/commit/c95072b3d88fac4be295815f2b67df366c0c297f"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2565,
        "cve_id": "CVE-2017-16528",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "sound/core/seq_device.c in the Linux kernel before 4.13.4 allows local users to cause a denial of service (snd_rawmidi_dev_seq_free use-after-free and system crash) or possibly have unspecified other impact via a crafted USB device.",
        "cvss": "6.6",
        "publish_date": "November 3, 2017",
        "AV": "PHYSICAL",
        "AC": "PHYSICAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57",
        "commit_message": "ALSA: seq: Cancel pending autoload work at unbinding device\n\nALSA sequencer core has a mechanism to load the enumerated devices\nautomatically, and it's performed in an off-load work.  This seems\ncausing some race when a sequencer is removed while the pending\nautoload work is running.  As syzkaller spotted, it may lead to some\nuse-after-free:\n  BUG: KASAN: use-after-free in snd_rawmidi_dev_seq_free+0x69/0x70\n  sound/core/rawmidi.c:1617\n  Write of size 8 at addr ffff88006c611d90 by task kworker/2:1/567\n\n  CPU: 2 PID: 567 Comm: kworker/2:1 Not tainted 4.13.0+ #29\n  Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n  Workqueue: events autoload_drivers\n  Call Trace:\n   __dump_stack lib/dump_stack.c:16 [inline]\n   dump_stack+0x192/0x22c lib/dump_stack.c:52\n   print_address_description+0x78/0x280 mm/kasan/report.c:252\n   kasan_report_error mm/kasan/report.c:351 [inline]\n   kasan_report+0x230/0x340 mm/kasan/report.c:409\n   __asan_report_store8_noabort+0x1c/0x20 mm/kasan/report.c:435\n   snd_rawmidi_dev_seq_free+0x69/0x70 sound/core/rawmidi.c:1617\n   snd_seq_dev_release+0x4f/0x70 sound/core/seq_device.c:192\n   device_release+0x13f/0x210 drivers/base/core.c:814\n   kobject_cleanup lib/kobject.c:648 [inline]\n   kobject_release lib/kobject.c:677 [inline]\n   kref_put include/linux/kref.h:70 [inline]\n   kobject_put+0x145/0x240 lib/kobject.c:694\n   put_device+0x25/0x30 drivers/base/core.c:1799\n   klist_devices_put+0x36/0x40 drivers/base/bus.c:827\n   klist_next+0x264/0x4a0 lib/klist.c:403\n   next_device drivers/base/bus.c:270 [inline]\n   bus_for_each_dev+0x17e/0x210 drivers/base/bus.c:312\n   autoload_drivers+0x3b/0x50 sound/core/seq_device.c:117\n   process_one_work+0x9fb/0x1570 kernel/workqueue.c:2097\n   worker_thread+0x1e4/0x1350 kernel/workqueue.c:2231\n   kthread+0x324/0x3f0 kernel/kthread.c:231\n   ret_from_fork+0x25/0x30 arch/x86/entry/entry_64.S:425\n\nThe fix is simply to assure canceling the autoload work at removing\nthe device.\n\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nTested-by: Andrey Konovalov <andreyknvl@google.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2017-09-12T10:41:20Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57",
        "html_url": "https://github.com/torvalds/linux/commit/fc27fe7e8deef2f37cba3f2be2d52b6ca5eb9d57",
        "parents": [
            {
                "commit_id_before": "f16e666b9b7e07237ca0669df9b89ccf8dfc102c",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f16e666b9b7e07237ca0669df9b89ccf8dfc102c",
                "html_url_before": "https://github.com/torvalds/linux/commit/f16e666b9b7e07237ca0669df9b89ccf8dfc102c"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2515,
        "cve_id": "CVE-2017-16939",
        "cwe_id": [
            "CWE-264",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The XFRM dump policy implementation in net/xfrm/xfrm_user.c in the Linux kernel before 4.13.11 allows local users to gain privileges or cause a denial of service (use-after-free) via a crafted SO_RCVBUF setsockopt system call in conjunction with XFRM_MSG_GETPOLICY Netlink messages.",
        "cvss": "7.8",
        "publish_date": "November 24, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "1137b5e2529a8f5ca8ee709288ecba3e68044df2",
        "commit_message": "ipsec: Fix aborted xfrm policy dump crash\n\nAn independent security researcher, Mohamed Ghannam, has reported\nthis vulnerability to Beyond Security's SecuriTeam Secure Disclosure\nprogram.\n\nThe xfrm_dump_policy_done function expects xfrm_dump_policy to\nhave been called at least once or it will crash.  This can be\ntriggered if a dump fails because the target socket's receive\nbuffer is full.\n\nThis patch fixes it by using the cb->start mechanism to ensure that\nthe initialisation is always done regardless of the buffer situation.\n\nFixes: 12a169e7d8f4 (\"ipsec: Put dumpers on the dump list\")\nSigned-off-by: Herbert Xu <herbert@gondor.apana.org.au>\nSigned-off-by: Steffen Klassert <steffen.klassert@secunet.com>",
        "commit_date": "2017-10-23T07:35:48Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1137b5e2529a8f5ca8ee709288ecba3e68044df2",
        "html_url": "https://github.com/torvalds/linux/commit/1137b5e2529a8f5ca8ee709288ecba3e68044df2",
        "parents": [
            {
                "commit_id_before": "10a7ef33679073d13bf1dd05e3f1b7912f999543",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/10a7ef33679073d13bf1dd05e3f1b7912f999543",
                "html_url_before": "https://github.com/torvalds/linux/commit/10a7ef33679073d13bf1dd05e3f1b7912f999543"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2507,
        "cve_id": "CVE-2017-17052",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The mm_init function in kernel/fork.c in the Linux kernel before 4.12.10 does not clear the ->exe_file member of a new process's mm_struct, allowing a local attacker to achieve a use-after-free or possibly have unspecified other impact by running a specially crafted program.",
        "cvss": "7.8",
        "publish_date": "November 28, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "2b7e8665b4ff51c034c55df3cff76518d1a9ee3a",
        "commit_message": "fork: fix incorrect fput of ->exe_file causing use-after-free\n\nCommit 7c051267931a (\"mm, fork: make dup_mmap wait for mmap_sem for\nwrite killable\") made it possible to kill a forking task while it is\nwaiting to acquire its ->mmap_sem for write, in dup_mmap().\n\nHowever, it was overlooked that this introduced an new error path before\na reference is taken on the mm_struct's ->exe_file.  Since the\n->exe_file of the new mm_struct was already set to the old ->exe_file by\nthe memcpy() in dup_mm(), it was possible for the mmput() in the error\npath of dup_mm() to drop a reference to ->exe_file which was never\ntaken.\n\nThis caused the struct file to later be freed prematurely.\n\nFix it by updating mm_init() to NULL out the ->exe_file, in the same\nplace it clears other things like the list of mmaps.\n\nThis bug was found by syzkaller.  It can be reproduced using the\nfollowing C program:\n\n    #define _GNU_SOURCE\n    #include <pthread.h>\n    #include <stdlib.h>\n    #include <sys/mman.h>\n    #include <sys/syscall.h>\n    #include <sys/wait.h>\n    #include <unistd.h>\n\n    static void *mmap_thread(void *_arg)\n    {\n        for (;;) {\n            mmap(NULL, 0x1000000, PROT_READ,\n                 MAP_POPULATE|MAP_ANONYMOUS|MAP_PRIVATE, -1, 0);\n        }\n    }\n\n    static void *fork_thread(void *_arg)\n    {\n        usleep(rand() % 10000);\n        fork();\n    }\n\n    int main(void)\n    {\n        fork();\n        fork();\n        fork();\n        for (;;) {\n            if (fork() == 0) {\n                pthread_t t;\n\n                pthread_create(&t, NULL, mmap_thread, NULL);\n                pthread_create(&t, NULL, fork_thread, NULL);\n                usleep(rand() % 10000);\n                syscall(__NR_exit_group, 0);\n            }\n            wait(NULL);\n        }\n    }\n\nNo special kernel config options are needed.  It usually causes a NULL\npointer dereference in __remove_shared_vm_struct() during exit, or in\ndup_mmap() (which is usually inlined into copy_process()) during fork.\nBoth are due to a vm_area_struct's ->vm_file being used after it's\nalready been freed.\n\nGoogle Bug Id: 64772007\n\nLink: http://lkml.kernel.org/r/20170823211408.31198-1-ebiggers3@gmail.com\nFixes: 7c051267931a (\"mm, fork: make dup_mmap wait for mmap_sem for write killable\")\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nTested-by: Mark Rutland <mark.rutland@arm.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nCc: Dmitry Vyukov <dvyukov@google.com>\nCc: Ingo Molnar <mingo@kernel.org>\nCc: Konstantin Khlebnikov <koct9i@gmail.com>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Vlastimil Babka <vbabka@suse.cz>\nCc: <stable@vger.kernel.org>\t[v4.7+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2017-08-25T23:12:46Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a",
        "html_url": "https://github.com/torvalds/linux/commit/2b7e8665b4ff51c034c55df3cff76518d1a9ee3a",
        "parents": [
            {
                "commit_id_before": "263630e8d176d87308481ebdcd78ef9426739c6b",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/263630e8d176d87308481ebdcd78ef9426739c6b",
                "html_url_before": "https://github.com/torvalds/linux/commit/263630e8d176d87308481ebdcd78ef9426739c6b"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2506,
        "cve_id": "CVE-2017-17053",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The init_new_context function in arch/x86/include/asm/mmu_context.h in the Linux kernel before 4.12.10 does not correctly handle errors from LDT table allocation when forking a new process, allowing a local attacker to achieve a use-after-free or possibly have unspecified other impact by running a specially crafted program. This vulnerability only affected kernels built with CONFIG_MODIFY_LDT_SYSCALL=y.",
        "cvss": "7.0",
        "publish_date": "November 28, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "ccd5b3235180eef3cfec337df1c8554ab151b5cc",
        "commit_message": "x86/mm: Fix use-after-free of ldt_struct\n\nThe following commit:\n\n  39a0526fb3f7 (\"x86/mm: Factor out LDT init from context init\")\n\nrenamed init_new_context() to init_new_context_ldt() and added a new\ninit_new_context() which calls init_new_context_ldt().  However, the\nerror code of init_new_context_ldt() was ignored.  Consequently, if a\nmemory allocation in alloc_ldt_struct() failed during a fork(), the\n->context.ldt of the new task remained the same as that of the old task\n(due to the memcpy() in dup_mm()).  ldt_struct's are not intended to be\nshared, so a use-after-free occurred after one task exited.\n\nFix the bug by making init_new_context() pass through the error code of\ninit_new_context_ldt().\n\nThis bug was found by syzkaller, which encountered the following splat:\n\n    BUG: KASAN: use-after-free in free_ldt_struct.part.2+0x10a/0x150 arch/x86/kernel/ldt.c:116\n    Read of size 4 at addr ffff88006d2cb7c8 by task kworker/u9:0/3710\n\n    CPU: 1 PID: 3710 Comm: kworker/u9:0 Not tainted 4.13.0-rc4-next-20170811 #2\n    Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS Bochs 01/01/2011\n    Call Trace:\n     __dump_stack lib/dump_stack.c:16 [inline]\n     dump_stack+0x194/0x257 lib/dump_stack.c:52\n     print_address_description+0x73/0x250 mm/kasan/report.c:252\n     kasan_report_error mm/kasan/report.c:351 [inline]\n     kasan_report+0x24e/0x340 mm/kasan/report.c:409\n     __asan_report_load4_noabort+0x14/0x20 mm/kasan/report.c:429\n     free_ldt_struct.part.2+0x10a/0x150 arch/x86/kernel/ldt.c:116\n     free_ldt_struct arch/x86/kernel/ldt.c:173 [inline]\n     destroy_context_ldt+0x60/0x80 arch/x86/kernel/ldt.c:171\n     destroy_context arch/x86/include/asm/mmu_context.h:157 [inline]\n     __mmdrop+0xe9/0x530 kernel/fork.c:889\n     mmdrop include/linux/sched/mm.h:42 [inline]\n     exec_mmap fs/exec.c:1061 [inline]\n     flush_old_exec+0x173c/0x1ff0 fs/exec.c:1291\n     load_elf_binary+0x81f/0x4ba0 fs/binfmt_elf.c:855\n     search_binary_handler+0x142/0x6b0 fs/exec.c:1652\n     exec_binprm fs/exec.c:1694 [inline]\n     do_execveat_common.isra.33+0x1746/0x22e0 fs/exec.c:1816\n     do_execve+0x31/0x40 fs/exec.c:1860\n     call_usermodehelper_exec_async+0x457/0x8f0 kernel/umh.c:100\n     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:431\n\n    Allocated by task 3700:\n     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59\n     save_stack+0x43/0xd0 mm/kasan/kasan.c:447\n     set_track mm/kasan/kasan.c:459 [inline]\n     kasan_kmalloc+0xad/0xe0 mm/kasan/kasan.c:551\n     kmem_cache_alloc_trace+0x136/0x750 mm/slab.c:3627\n     kmalloc include/linux/slab.h:493 [inline]\n     alloc_ldt_struct+0x52/0x140 arch/x86/kernel/ldt.c:67\n     write_ldt+0x7b7/0xab0 arch/x86/kernel/ldt.c:277\n     sys_modify_ldt+0x1ef/0x240 arch/x86/kernel/ldt.c:307\n     entry_SYSCALL_64_fastpath+0x1f/0xbe\n\n    Freed by task 3700:\n     save_stack_trace+0x16/0x20 arch/x86/kernel/stacktrace.c:59\n     save_stack+0x43/0xd0 mm/kasan/kasan.c:447\n     set_track mm/kasan/kasan.c:459 [inline]\n     kasan_slab_free+0x71/0xc0 mm/kasan/kasan.c:524\n     __cache_free mm/slab.c:3503 [inline]\n     kfree+0xca/0x250 mm/slab.c:3820\n     free_ldt_struct.part.2+0xdd/0x150 arch/x86/kernel/ldt.c:121\n     free_ldt_struct arch/x86/kernel/ldt.c:173 [inline]\n     destroy_context_ldt+0x60/0x80 arch/x86/kernel/ldt.c:171\n     destroy_context arch/x86/include/asm/mmu_context.h:157 [inline]\n     __mmdrop+0xe9/0x530 kernel/fork.c:889\n     mmdrop include/linux/sched/mm.h:42 [inline]\n     __mmput kernel/fork.c:916 [inline]\n     mmput+0x541/0x6e0 kernel/fork.c:927\n     copy_process.part.36+0x22e1/0x4af0 kernel/fork.c:1931\n     copy_process kernel/fork.c:1546 [inline]\n     _do_fork+0x1ef/0xfb0 kernel/fork.c:2025\n     SYSC_clone kernel/fork.c:2135 [inline]\n     SyS_clone+0x37/0x50 kernel/fork.c:2129\n     do_syscall_64+0x26c/0x8c0 arch/x86/entry/common.c:287\n     return_from_SYSCALL_64+0x0/0x7a\n\nHere is a C reproducer:\n\n    #include <asm/ldt.h>\n    #include <pthread.h>\n    #include <signal.h>\n    #include <stdlib.h>\n    #include <sys/syscall.h>\n    #include <sys/wait.h>\n    #include <unistd.h>\n\n    static void *fork_thread(void *_arg)\n    {\n        fork();\n    }\n\n    int main(void)\n    {\n        struct user_desc desc = { .entry_number = 8191 };\n\n        syscall(__NR_modify_ldt, 1, &desc, sizeof(desc));\n\n        for (;;) {\n            if (fork() == 0) {\n                pthread_t t;\n\n                srand(getpid());\n                pthread_create(&t, NULL, fork_thread, NULL);\n                usleep(rand() % 10000);\n                syscall(__NR_exit_group, 0);\n            }\n            wait(NULL);\n        }\n    }\n\nNote: the reproducer takes advantage of the fact that alloc_ldt_struct()\nmay use vmalloc() to allocate a large ->entries array, and after\ncommit:\n\n  5d17a73a2ebe (\"vmalloc: back off when the current task is killed\")\n\nit is possible for userspace to fail a task's vmalloc() by\nsending a fatal signal, e.g. via exit_group().  It would be more\ndifficult to reproduce this bug on kernels without that commit.\n\nThis bug only affected kernels with CONFIG_MODIFY_LDT_SYSCALL=y.\n\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nAcked-by: Dave Hansen <dave.hansen@linux.intel.com>\nCc: <stable@vger.kernel.org> [v4.6+]\nCc: Andrew Morton <akpm@linux-foundation.org>\nCc: Andy Lutomirski <luto@amacapital.net>\nCc: Borislav Petkov <bp@alien8.de>\nCc: Brian Gerst <brgerst@gmail.com>\nCc: Christoph Hellwig <hch@lst.de>\nCc: Denys Vlasenko <dvlasenk@redhat.com>\nCc: Dmitry Vyukov <dvyukov@google.com>\nCc: Linus Torvalds <torvalds@linux-foundation.org>\nCc: Michal Hocko <mhocko@suse.com>\nCc: Peter Zijlstra <peterz@infradead.org>\nCc: Rik van Riel <riel@redhat.com>\nCc: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>\nCc: Thomas Gleixner <tglx@linutronix.de>\nCc: linux-mm@kvack.org\nFixes: 39a0526fb3f7 (\"x86/mm: Factor out LDT init from context init\")\nLink: http://lkml.kernel.org/r/20170824175029.76040-1-ebiggers3@gmail.com\nSigned-off-by: Ingo Molnar <mingo@kernel.org>",
        "commit_date": "2017-08-25T07:55:52Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/ccd5b3235180eef3cfec337df1c8554ab151b5cc",
        "html_url": "https://github.com/torvalds/linux/commit/ccd5b3235180eef3cfec337df1c8554ab151b5cc",
        "parents": [
            {
                "commit_id_before": "deecd4d71b12626db48544faa66bb897e2cafd07",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/deecd4d71b12626db48544faa66bb897e2cafd07",
                "html_url_before": "https://github.com/torvalds/linux/commit/deecd4d71b12626db48544faa66bb897e2cafd07"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2670,
        "cve_id": "CVE-2017-18017",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The tcpmss_mangle_packet function in net/netfilter/xt_TCPMSS.c in the Linux kernel before 4.11, and 4.9.x before 4.9.36, allows remote attackers to cause a denial of service (use-after-free and memory corruption) or possibly have unspecified other impact by leveraging the presence of xt_TCPMSS in an iptables action.",
        "cvss": "9.8",
        "publish_date": "January 3, 2018",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "2638fd0f92d4397884fd991d8f4925cb3f081901",
        "commit_message": "netfilter: xt_TCPMSS: add more sanity tests on tcph->doff\n\nDenys provided an awesome KASAN report pointing to an use\nafter free in xt_TCPMSS\n\nI have provided three patches to fix this issue, either in xt_TCPMSS or\nin xt_tcpudp.c. It seems xt_TCPMSS patch has the smallest possible\nimpact.\n\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nReported-by: Denys Fedoryshchenko <nuclearcat@nuclearcat.com>\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "commit_date": "2017-04-08T20:24:19Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/2638fd0f92d4397884fd991d8f4925cb3f081901",
        "html_url": "https://github.com/torvalds/linux/commit/2638fd0f92d4397884fd991d8f4925cb3f081901",
        "parents": [
            {
                "commit_id_before": "0b9aefea860063bb39e36bd7fe6c7087fed0ba87",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/0b9aefea860063bb39e36bd7fe6c7087fed0ba87",
                "html_url_before": "https://github.com/torvalds/linux/commit/0b9aefea860063bb39e36bd7fe6c7087fed0ba87"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2676,
        "cve_id": "CVE-2017-18202",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The __oom_reap_task_mm function in mm/oom_kill.c in the Linux kernel before 4.14.4 mishandles gather operations, which allows attackers to cause a denial of service (TLB entry leak or use-after-free) or possibly have unspecified other impact by triggering a copy_to_user call within a certain time window.",
        "cvss": "5.5",
        "publish_date": "February 27, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "687cb0884a714ff484d038e9190edc874edcf146",
        "commit_message": "mm, oom_reaper: gather each vma to prevent leaking TLB entry\n\ntlb_gather_mmu(&tlb, mm, 0, -1) means gathering the whole virtual memory\nspace.  In this case, tlb->fullmm is true.  Some archs like arm64\ndoesn't flush TLB when tlb->fullmm is true:\n\n  commit 5a7862e83000 (\"arm64: tlbflush: avoid flushing when fullmm == 1\").\n\nWhich causes leaking of tlb entries.\n\nWill clarifies his patch:\n \"Basically, we tag each address space with an ASID (PCID on x86) which\n  is resident in the TLB. This means we can elide TLB invalidation when\n  pulling down a full mm because we won't ever assign that ASID to\n  another mm without doing TLB invalidation elsewhere (which actually\n  just nukes the whole TLB).\n\n  I think that means that we could potentially not fault on a kernel\n  uaccess, because we could hit in the TLB\"\n\nThere could be a window between complete_signal() sending IPI to other\ncores and all threads sharing this mm are really kicked off from cores.\nIn this window, the oom reaper may calls tlb_flush_mmu_tlbonly() to\nflush TLB then frees pages.  However, due to the above problem, the TLB\nentries are not really flushed on arm64.  Other threads are possible to\naccess these pages through TLB entries.  Moreover, a copy_to_user() can\nalso write to these pages without generating page fault, causes\nuse-after-free bugs.\n\nThis patch gathers each vma instead of gathering full vm space.  In this\ncase tlb->fullmm is not true.  The behavior of oom reaper become similar\nto munmapping before do_exit, which should be safe for all archs.\n\nLink: http://lkml.kernel.org/r/20171107095453.179940-1-wangnan0@huawei.com\nFixes: aac453635549 (\"mm, oom: introduce oom reaper\")\nSigned-off-by: Wang Nan <wangnan0@huawei.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nAcked-by: David Rientjes <rientjes@google.com>\nCc: Minchan Kim <minchan@kernel.org>\nCc: Will Deacon <will.deacon@arm.com>\nCc: Bob Liu <liubo95@huawei.com>\nCc: Ingo Molnar <mingo@kernel.org>\nCc: Roman Gushchin <guro@fb.com>\nCc: Konstantin Khlebnikov <khlebnikov@yandex-team.ru>\nCc: Andrea Arcangeli <aarcange@redhat.com>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2017-11-30T02:40:42Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/687cb0884a714ff484d038e9190edc874edcf146",
        "html_url": "https://github.com/torvalds/linux/commit/687cb0884a714ff484d038e9190edc874edcf146",
        "parents": [
            {
                "commit_id_before": "4b81cb2ff69c8a8e297a147d2eb4d9b5e8d7c435",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/4b81cb2ff69c8a8e297a147d2eb4d9b5e8d7c435",
                "html_url_before": "https://github.com/torvalds/linux/commit/4b81cb2ff69c8a8e297a147d2eb4d9b5e8d7c435"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2788,
        "cve_id": "CVE-2017-18218",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "In drivers/net/ethernet/hisilicon/hns/hns_enet.c in the Linux kernel before 4.13, local users can cause a denial of service (use-after-free and BUG) or possibly have unspecified other impact by leveraging differences in skb handling between hns_nic_net_xmit_hw and hns_nic_net_xmit.",
        "cvss": "7.8",
        "publish_date": "March 5, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2",
        "commit_message": "net: hns: Fix a skb used after free bug\n\nskb maybe freed in hns_nic_net_xmit_hw() and return NETDEV_TX_OK,\nwhich cause hns_nic_net_xmit to use a freed skb.\n\nBUG: KASAN: use-after-free in hns_nic_net_xmit_hw+0x62c/0x940...\n\t[17659.112635]      alloc_debug_processing+0x18c/0x1a0\n\t[17659.117208]      __slab_alloc+0x52c/0x560\n\t[17659.120909]      kmem_cache_alloc_node+0xac/0x2c0\n\t[17659.125309]      __alloc_skb+0x6c/0x260\n\t[17659.128837]      tcp_send_ack+0x8c/0x280\n\t[17659.132449]      __tcp_ack_snd_check+0x9c/0xf0\n\t[17659.136587]      tcp_rcv_established+0x5a4/0xa70\n\t[17659.140899]      tcp_v4_do_rcv+0x27c/0x620\n\t[17659.144687]      tcp_prequeue_process+0x108/0x170\n\t[17659.149085]      tcp_recvmsg+0x940/0x1020\n\t[17659.152787]      inet_recvmsg+0x124/0x180\n\t[17659.156488]      sock_recvmsg+0x64/0x80\n\t[17659.160012]      SyS_recvfrom+0xd8/0x180\n\t[17659.163626]      __sys_trace_return+0x0/0x4\n\t[17659.167506] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=23 cpu=1 pid=13\n\t[17659.174000]      free_debug_processing+0x1d4/0x2c0\n\t[17659.178486]      __slab_free+0x240/0x390\n\t[17659.182100]      kmem_cache_free+0x24c/0x270\n\t[17659.186062]      kfree_skbmem+0xa0/0xb0\n\t[17659.189587]      __kfree_skb+0x28/0x40\n\t[17659.193025]      napi_gro_receive+0x168/0x1c0\n\t[17659.197074]      hns_nic_rx_up_pro+0x58/0x90\n\t[17659.201038]      hns_nic_rx_poll_one+0x518/0xbc0\n\t[17659.205352]      hns_nic_common_poll+0x94/0x140\n\t[17659.209576]      net_rx_action+0x458/0x5e0\n\t[17659.213363]      __do_softirq+0x1b8/0x480\n\t[17659.217062]      run_ksoftirqd+0x64/0x80\n\t[17659.220679]      smpboot_thread_fn+0x224/0x310\n\t[17659.224821]      kthread+0x150/0x170\n\t[17659.228084]      ret_from_fork+0x10/0x40\n\n\tBUG: KASAN: use-after-free in hns_nic_net_xmit+0x8c/0xc0...\n\t[17751.080490]      __slab_alloc+0x52c/0x560\n\t[17751.084188]      kmem_cache_alloc+0x244/0x280\n\t[17751.088238]      __build_skb+0x40/0x150\n\t[17751.091764]      build_skb+0x28/0x100\n\t[17751.095115]      __alloc_rx_skb+0x94/0x150\n\t[17751.098900]      __napi_alloc_skb+0x34/0x90\n\t[17751.102776]      hns_nic_rx_poll_one+0x180/0xbc0\n\t[17751.107097]      hns_nic_common_poll+0x94/0x140\n\t[17751.111333]      net_rx_action+0x458/0x5e0\n\t[17751.115123]      __do_softirq+0x1b8/0x480\n\t[17751.118823]      run_ksoftirqd+0x64/0x80\n\t[17751.122437]      smpboot_thread_fn+0x224/0x310\n\t[17751.126575]      kthread+0x150/0x170\n\t[17751.129838]      ret_from_fork+0x10/0x40\n\t[17751.133454] INFO: Freed in kfree_skbmem+0xa0/0xb0 age=19 cpu=7 pid=43\n\t[17751.139951]      free_debug_processing+0x1d4/0x2c0\n\t[17751.144436]      __slab_free+0x240/0x390\n\t[17751.148051]      kmem_cache_free+0x24c/0x270\n\t[17751.152014]      kfree_skbmem+0xa0/0xb0\n\t[17751.155543]      __kfree_skb+0x28/0x40\n\t[17751.159022]      napi_gro_receive+0x168/0x1c0\n\t[17751.163074]      hns_nic_rx_up_pro+0x58/0x90\n\t[17751.167041]      hns_nic_rx_poll_one+0x518/0xbc0\n\t[17751.171358]      hns_nic_common_poll+0x94/0x140\n\t[17751.175585]      net_rx_action+0x458/0x5e0\n\t[17751.179373]      __do_softirq+0x1b8/0x480\n\t[17751.183076]      run_ksoftirqd+0x64/0x80\n\t[17751.186691]      smpboot_thread_fn+0x224/0x310\n\t[17751.190826]      kthread+0x150/0x170\n\t[17751.194093]      ret_from_fork+0x10/0x40\n\nFixes: 13ac695e7ea1 (\"net:hns: Add support of Hip06 SoC to the Hislicon Network Subsystem\")\nSigned-off-by: Yunsheng Lin <linyunsheng@huawei.com>\nSigned-off-by: lipeng <lipeng321@huawei.com>\nReported-by: Jun He <hjat2005@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2017-07-08T10:05:21Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2",
        "html_url": "https://github.com/torvalds/linux/commit/27463ad99f738ed93c7c8b3e2e5bc8c4853a2ff2",
        "parents": [
            {
                "commit_id_before": "ebe8d359c90d6e237527f4d0544b62bdcc0ff286",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/ebe8d359c90d6e237527f4d0544b62bdcc0ff286",
                "html_url_before": "https://github.com/torvalds/linux/commit/ebe8d359c90d6e237527f4d0544b62bdcc0ff286"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1503,
        "cve_id": "CVE-2017-2584",
        "cwe_id": [
            "CWE-200",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "arch/x86/kvm/emulate.c in the Linux kernel through 4.9.3 allows local users to obtain sensitive information from kernel memory or cause a denial of service (use-after-free) via a crafted application that leverages instruction emulation for fxrstor, fxsave, sgdt, and sidt.",
        "cvss": "7.1",
        "publish_date": "January 14, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "129a72a0d3c8e139a04512325384fe5ac119e74d",
        "commit_message": "KVM: x86: Introduce segmented_write_std\n\nIntroduces segemented_write_std.\n\nSwitches from emulated reads/writes to standard read/writes in fxsave,\nfxrstor, sgdt, and sidt.  This fixes CVE-2017-2584, a longstanding\nkernel memory leak.\n\nSince commit 283c95d0e389 (\"KVM: x86: emulate FXSAVE and FXRSTOR\",\n2016-11-09), which is luckily not yet in any final release, this would\nalso be an exploitable kernel memory *write*!\n\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nCc: stable@vger.kernel.org\nFixes: 96051572c819194c37a8367624b285be10297eca\nFixes: 283c95d0e3891b64087706b344a4b545d04a6e62\nSuggested-by: Paolo Bonzini <pbonzini@redhat.com>\nSigned-off-by: Steve Rutherford <srutherford@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "commit_date": "2017-01-12T13:34:58Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/129a72a0d3c8e139a04512325384fe5ac119e74d",
        "html_url": "https://github.com/torvalds/linux/commit/129a72a0d3c8e139a04512325384fe5ac119e74d",
        "parents": [
            {
                "commit_id_before": "cef84c302fe051744b983a92764d3fcca933415d",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/cef84c302fe051744b983a92764d3fcca933415d",
                "html_url_before": "https://github.com/torvalds/linux/commit/cef84c302fe051744b983a92764d3fcca933415d"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1859,
        "cve_id": "CVE-2017-6346",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in net/packet/af_packet.c in the Linux kernel before 4.9.13 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a multithreaded application that makes PACKET_FANOUT setsockopt system calls.",
        "cvss": "7.0",
        "publish_date": "March 1, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "d199fab63c11998a602205f7ee7ff7c05c97164b",
        "commit_message": "packet: fix races in fanout_add()\n\nMultiple threads can call fanout_add() at the same time.\n\nWe need to grab fanout_mutex earlier to avoid races that could\nlead to one thread freeing po->rollover that was set by another thread.\n\nDo the same in fanout_release(), for peace of mind, and to help us\nfinding lockdep issues earlier.\n\nFixes: dc99f600698d (\"packet: Add fanout support.\")\nFixes: 0648ab70afe6 (\"packet: rollover prepare: per-socket state\")\nSigned-off-by: Eric Dumazet <edumazet@google.com>\nCc: Willem de Bruijn <willemb@google.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2017-02-14T20:05:12Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/d199fab63c11998a602205f7ee7ff7c05c97164b",
        "html_url": "https://github.com/torvalds/linux/commit/d199fab63c11998a602205f7ee7ff7c05c97164b",
        "parents": [
            {
                "commit_id_before": "f39f0d1e1e93145a0e91d9a7a639c42fd037ecc3",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f39f0d1e1e93145a0e91d9a7a639c42fd037ecc3",
                "html_url_before": "https://github.com/torvalds/linux/commit/f39f0d1e1e93145a0e91d9a7a639c42fd037ecc3"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1804,
        "cve_id": "CVE-2017-6874",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Race condition in kernel/ucount.c in the Linux kernel through 4.10.2 allows local users to cause a denial of service (use-after-free and system crash) or possibly have unspecified other impact via crafted system calls that leverage certain decrement behavior that causes incorrect interaction between put_ucounts and get_ucounts.",
        "cvss": "7.0",
        "publish_date": "March 14, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "040757f738e13caaa9c5078bca79aa97e11dde88",
        "commit_message": "ucount: Remove the atomicity from ucount->count\n\nAlways increment/decrement ucount->count under the ucounts_lock.  The\nincrements are there already and moving the decrements there means the\nlocking logic of the code is simpler.  This simplification in the\nlocking logic fixes a race between put_ucounts and get_ucounts that\ncould result in a use-after-free because the count could go zero then\nbe found by get_ucounts and then be freed by put_ucounts.\n\nA bug presumably this one was found by a combination of syzkaller and\nKASAN.  JongWhan Kim reported the syzkaller failure and Dmitry Vyukov\nspotted the race in the code.\n\nCc: stable@vger.kernel.org\nFixes: f6b2db1a3e8d (\"userns: Make the count of user namespaces per user\")\nReported-by: JongHwan Kim <zzoru007@gmail.com>\nReported-by: Dmitry Vyukov <dvyukov@google.com>\nReviewed-by: Andrei Vagin <avagin@gmail.com>\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "commit_date": "2017-03-06T21:26:37Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/040757f738e13caaa9c5078bca79aa97e11dde88",
        "html_url": "https://github.com/torvalds/linux/commit/040757f738e13caaa9c5078bca79aa97e11dde88",
        "parents": [
            {
                "commit_id_before": "c1ae3cfa0e89fa1a7ecc4c99031f5e9ae99d9201",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c1ae3cfa0e89fa1a7ecc4c99031f5e9ae99d9201",
                "html_url_before": "https://github.com/torvalds/linux/commit/c1ae3cfa0e89fa1a7ecc4c99031f5e9ae99d9201"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 1621,
        "cve_id": "CVE-2017-7374",
        "cwe_id": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use-after-free vulnerability in fs/crypto/ in the Linux kernel before 4.10.7 allows local users to cause a denial of service (NULL pointer dereference) or possibly gain privileges by revoking keyring keys being used for ext4, f2fs, or ubifs encryption, causing cryptographic transform objects to be freed prematurely.",
        "cvss": "7.8",
        "publish_date": "March 31, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
        "commit_message": "fscrypt: remove broken support for detecting keyring key revocation\n\nFilesystem encryption ostensibly supported revoking a keyring key that\nhad been used to \"unlock\" encrypted files, causing those files to become\n\"locked\" again.  This was, however, buggy for several reasons, the most\nsevere of which was that when key revocation happened to be detected for\nan inode, its fscrypt_info was immediately freed, even while other\nthreads could be using it for encryption or decryption concurrently.\nThis could be exploited to crash the kernel or worse.\n\nThis patch fixes the use-after-free by removing the code which detects\nthe keyring key having been revoked, invalidated, or expired.  Instead,\nan encrypted inode that is \"unlocked\" now simply remains unlocked until\nit is evicted from memory.  Note that this is no worse than the case for\nblock device-level encryption, e.g. dm-crypt, and it still remains\npossible for a privileged user to evict unused pages, inodes, and\ndentries by running 'sync; echo 3 > /proc/sys/vm/drop_caches', or by\nsimply unmounting the filesystem.  In fact, one of those actions was\nalready needed anyway for key revocation to work even somewhat sanely.\nThis change is not expected to break any applications.\n\nIn the future I'd like to implement a real API for fscrypt key\nrevocation that interacts sanely with ongoing filesystem operations ---\nwaiting for existing operations to complete and blocking new operations,\nand invalidating and sanitizing key material and plaintext from the VFS\ncaches.  But this is a hard problem, and for now this bug must be fixed.\n\nThis bug affected almost all versions of ext4, f2fs, and ubifs\nencryption, and it was potentially reachable in any kernel configured\nwith encryption support (CONFIG_EXT4_ENCRYPTION=y,\nCONFIG_EXT4_FS_ENCRYPTION=y, CONFIG_F2FS_FS_ENCRYPTION=y, or\nCONFIG_UBIFS_FS_ENCRYPTION=y).  Note that older kernels did not use the\nshared fs/crypto/ code, but due to the potential security implications\nof this bug, it may still be worthwhile to backport this fix to them.\n\nFixes: b7236e21d55f (\"ext4 crypto: reorganize how we store keys in the inode\")\nCc: stable@vger.kernel.org # v4.2+\nSigned-off-by: Eric Biggers <ebiggers@google.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nAcked-by: Michael Halcrow <mhalcrow@google.com>",
        "commit_date": "2017-03-15T17:12:05Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
        "html_url": "https://github.com/torvalds/linux/commit/1b53cf9815bb4744958d41f3795d5d5a1d365e2d",
        "parents": [
            {
                "commit_id_before": "cab7076a185e1e27f6879325e4da762424c3f1c9",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/cab7076a185e1e27f6879325e4da762424c3f1c9",
                "html_url_before": "https://github.com/torvalds/linux/commit/cab7076a185e1e27f6879325e4da762424c3f1c9"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2054,
        "cve_id": "CVE-2017-7487",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The ipxitf_ioctl function in net/ipx/af_ipx.c in the Linux kernel through 4.11.1 mishandles reference counts, which allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via a failed SIOCGIFADDR ioctl call for an IPX interface.",
        "cvss": "7.8",
        "publish_date": "May 14, 2017",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "ee0d8d8482345ff97a75a7d747efc309f13b0d80",
        "commit_message": "ipx: call ipxitf_put() in ioctl error path\n\nWe should call ipxitf_put() if the copy_to_user() fails.\n\nReported-by: \u674e\u5f3a <liqiang6-s@360.cn>\nSigned-off-by: Dan Carpenter <dan.carpenter@oracle.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2017-05-02T19:34:53Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/ee0d8d8482345ff97a75a7d747efc309f13b0d80",
        "html_url": "https://github.com/torvalds/linux/commit/ee0d8d8482345ff97a75a7d747efc309f13b0d80",
        "parents": [
            {
                "commit_id_before": "9da3242e6a83b6f315aa9c394c939da8e4ad7774",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/9da3242e6a83b6f315aa9c394c939da8e4ad7774",
                "html_url_before": "https://github.com/torvalds/linux/commit/9da3242e6a83b6f315aa9c394c939da8e4ad7774"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2893,
        "cve_id": "CVE-2018-10675",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The do_get_mempolicy function in mm/mempolicy.c in the Linux kernel before 4.12.9 allows local users to cause a denial of service (use-after-free) or possibly have unspecified other impact via crafted system calls.",
        "cvss": "7.8",
        "publish_date": "May 2, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "73223e4e2e3867ebf033a5a8eb2e5df0158ccc99",
        "commit_message": "mm/mempolicy: fix use after free when calling get_mempolicy\n\nI hit a use after free issue when executing trinity and repoduced it\nwith KASAN enabled.  The related call trace is as follows.\n\n  BUG: KASan: use after free in SyS_get_mempolicy+0x3c8/0x960 at addr ffff8801f582d766\n  Read of size 2 by task syz-executor1/798\n\n  INFO: Allocated in mpol_new.part.2+0x74/0x160 age=3 cpu=1 pid=799\n     __slab_alloc+0x768/0x970\n     kmem_cache_alloc+0x2e7/0x450\n     mpol_new.part.2+0x74/0x160\n     mpol_new+0x66/0x80\n     SyS_mbind+0x267/0x9f0\n     system_call_fastpath+0x16/0x1b\n  INFO: Freed in __mpol_put+0x2b/0x40 age=4 cpu=1 pid=799\n     __slab_free+0x495/0x8e0\n     kmem_cache_free+0x2f3/0x4c0\n     __mpol_put+0x2b/0x40\n     SyS_mbind+0x383/0x9f0\n     system_call_fastpath+0x16/0x1b\n  INFO: Slab 0xffffea0009cb8dc0 objects=23 used=8 fp=0xffff8801f582de40 flags=0x200000000004080\n  INFO: Object 0xffff8801f582d760 @offset=5984 fp=0xffff8801f582d600\n\n  Bytes b4 ffff8801f582d750: ae 01 ff ff 00 00 00 00 5a 5a 5a 5a 5a 5a 5a 5a  ........ZZZZZZZZ\n  Object ffff8801f582d760: 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b 6b  kkkkkkkkkkkkkkkk\n  Object ffff8801f582d770: 6b 6b 6b 6b 6b 6b 6b a5                          kkkkkkk.\n  Redzone ffff8801f582d778: bb bb bb bb bb bb bb bb                          ........\n  Padding ffff8801f582d8b8: 5a 5a 5a 5a 5a 5a 5a 5a                          ZZZZZZZZ\n  Memory state around the buggy address:\n  ffff8801f582d600: fb fb fb fc fc fc fc fc fc fc fc fc fc fc fc fc\n  ffff8801f582d680: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n  >ffff8801f582d700: fc fc fc fc fc fc fc fc fc fc fc fc fb fb fb fc\n\n!shared memory policy is not protected against parallel removal by other\nthread which is normally protected by the mmap_sem.  do_get_mempolicy,\nhowever, drops the lock midway while we can still access it later.\n\nEarly premature up_read is a historical artifact from times when\nput_user was called in this path see https://lwn.net/Articles/124754/\nbut that is gone since 8bccd85ffbaf (\"[PATCH] Implement sys_* do_*\nlayering in the memory policy layer.\").  but when we have the the\ncurrent mempolicy ref count model.  The issue was introduced\naccordingly.\n\nFix the issue by removing the premature release.\n\nLink: http://lkml.kernel.org/r/1502950924-27521-1-git-send-email-zhongjiang@huawei.com\nSigned-off-by: zhong jiang <zhongjiang@huawei.com>\nAcked-by: Michal Hocko <mhocko@suse.com>\nCc: Minchan Kim <minchan@kernel.org>\nCc: Vlastimil Babka <vbabka@suse.cz>\nCc: David Rientjes <rientjes@google.com>\nCc: Mel Gorman <mgorman@techsingularity.net>\nCc: <stable@vger.kernel.org>\t[2.6+]\nSigned-off-by: Andrew Morton <akpm@linux-foundation.org>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2017-08-18T22:32:02Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99",
        "html_url": "https://github.com/torvalds/linux/commit/73223e4e2e3867ebf033a5a8eb2e5df0158ccc99",
        "parents": [
            {
                "commit_id_before": "da094e42848e3c36feaa3b5271e53983fd45424f",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/da094e42848e3c36feaa3b5271e53983fd45424f",
                "html_url_before": "https://github.com/torvalds/linux/commit/da094e42848e3c36feaa3b5271e53983fd45424f"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2948,
        "cve_id": "CVE-2018-14734",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "drivers/infiniband/core/ucma.c in the Linux kernel through 4.17.11 allows ucma_leave_multicast to access a certain data structure after a cleanup step in ucma_process_join, which allows attackers to cause a denial of service (use-after-free).",
        "cvss": "7.8",
        "publish_date": "July 29, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "cb2595c1393b4a5211534e6f0a0fbad369e21ad8",
        "commit_message": "infiniband: fix a possible use-after-free bug\n\nucma_process_join() will free the new allocated \"mc\" struct,\nif there is any error after that, especially the copy_to_user().\n\nBut in parallel, ucma_leave_multicast() could find this \"mc\"\nthrough idr_find() before ucma_process_join() frees it, since it\nis already published.\n\nSo \"mc\" could be used in ucma_leave_multicast() after it is been\nallocated and freed in ucma_process_join(), since we don't refcnt\nit.\n\nFix this by separating \"publish\" from ID allocation, so that we\ncan get an ID first and publish it later after copy_to_user().\n\nFixes: c8f6a362bf3e (\"RDMA/cma: Add multicast communication support\")\nReported-by: Noam Rathaus <noamr@beyondsecurity.com>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: Jason Gunthorpe <jgg@mellanox.com>",
        "commit_date": "2018-06-04T15:37:03Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/cb2595c1393b4a5211534e6f0a0fbad369e21ad8",
        "html_url": "https://github.com/torvalds/linux/commit/cb2595c1393b4a5211534e6f0a0fbad369e21ad8",
        "parents": [
            {
                "commit_id_before": "e4b1672ac0a54c7740cbc4ff39dfdc56182236cb",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/e4b1672ac0a54c7740cbc4ff39dfdc56182236cb",
                "html_url_before": "https://github.com/torvalds/linux/commit/e4b1672ac0a54c7740cbc4ff39dfdc56182236cb"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3094,
        "cve_id": "CVE-2018-17182",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel through 4.18.8. The vmacache_flush_all function in mm/vmacache.c mishandles sequence number overflows. An attacker can trigger a use-after-free (and possibly gain privileges) via certain thread creation, map, unmap, invalidation, and dereference operations.",
        "cvss": "7.8",
        "publish_date": "September 19, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "7a9cdebdcc17e426fb5287e4a82db1dfe86339b2",
        "commit_message": "mm: get rid of vmacache_flush_all() entirely\n\nJann Horn points out that the vmacache_flush_all() function is not only\npotentially expensive, it's buggy too.  It also happens to be entirely\nunnecessary, because the sequence number overflow case can be avoided by\nsimply making the sequence number be 64-bit.  That doesn't even grow the\ndata structures in question, because the other adjacent fields are\nalready 64-bit.\n\nSo simplify the whole thing by just making the sequence number overflow\ncase go away entirely, which gets rid of all the complications and makes\nthe code faster too.  Win-win.\n\n[ Oleg Nesterov points out that the VMACACHE_FULL_FLUSHES statistics\n  also just goes away entirely with this ]\n\nReported-by: Jann Horn <jannh@google.com>\nSuggested-by: Will Deacon <will.deacon@arm.com>\nAcked-by: Davidlohr Bueso <dave@stgolabs.net>\nCc: Oleg Nesterov <oleg@redhat.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2018-09-14T01:18:04Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/7a9cdebdcc17e426fb5287e4a82db1dfe86339b2",
        "html_url": "https://github.com/torvalds/linux/commit/7a9cdebdcc17e426fb5287e4a82db1dfe86339b2",
        "parents": [
            {
                "commit_id_before": "54eda9df17f3215b9ed16629ee71ea07413efdaf",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/54eda9df17f3215b9ed16629ee71ea07413efdaf",
                "html_url_before": "https://github.com/torvalds/linux/commit/54eda9df17f3215b9ed16629ee71ea07413efdaf"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3254,
        "cve_id": "CVE-2018-19824",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "In the Linux kernel through 4.19.6, a local user could exploit a use-after-free in the ALSA driver by supplying a malicious USB Sound device (with zero interfaces) that is mishandled in usb_audio_probe in sound/usb/card.c.",
        "cvss": "7.8",
        "publish_date": "December 3, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "5f8cf712582617d523120df67d392059eaf2fc4b",
        "commit_message": "ALSA: usb-audio: Fix UAF decrement if card has no live interfaces in card.c\n\nIf a USB sound card reports 0 interfaces, an error condition is triggered\nand the function usb_audio_probe errors out. In the error path, there was a\nuse-after-free vulnerability where the memory object of the card was first\nfreed, followed by a decrement of the number of active chips. Moving the\ndecrement above the atomic_dec fixes the UAF.\n\n[ The original problem was introduced in 3.1 kernel, while it was\n  developed in a different form.  The Fixes tag below indicates the\n  original commit but it doesn't mean that the patch is applicable\n  cleanly. -- tiwai ]\n\nFixes: 362e4e49abe5 (\"ALSA: usb-audio - clear chip->probing on error exit\")\nReported-by: Hui Peng <benquike@gmail.com>\nReported-by: Mathias Payer <mathias.payer@nebelwelt.net>\nSigned-off-by: Hui Peng <benquike@gmail.com>\nSigned-off-by: Mathias Payer <mathias.payer@nebelwelt.net>\nCc: <stable@vger.kernel.org>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2018-12-03T15:09:38Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/5f8cf712582617d523120df67d392059eaf2fc4b",
        "html_url": "https://github.com/torvalds/linux/commit/5f8cf712582617d523120df67d392059eaf2fc4b",
        "parents": [
            {
                "commit_id_before": "54947cd64c1b8290f64bb2958e343c07270e3a58",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/54947cd64c1b8290f64bb2958e343c07270e3a58",
                "html_url_before": "https://github.com/torvalds/linux/commit/54947cd64c1b8290f64bb2958e343c07270e3a58"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3546,
        "cve_id": "CVE-2018-20836",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 4.20. There is a race condition in smp_task_timedout() and smp_task_done() in drivers/scsi/libsas/sas_expander.c, leading to a use-after-free.",
        "cvss": "8.1",
        "publish_date": "May 7, 2019",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "b90cd6f2b905905fb42671009dc0e27c310a16ae",
        "commit_message": "scsi: libsas: fix a race condition when smp task timeout\n\nWhen the lldd is processing the complete sas task in interrupt and set the\ntask stat as SAS_TASK_STATE_DONE, the smp timeout timer is able to be\ntriggered at the same time. And smp_task_timedout() will complete the task\nwheter the SAS_TASK_STATE_DONE is set or not. Then the sas task may freed\nbefore lldd end the interrupt process. Thus a use-after-free will happen.\n\nFix this by calling the complete() only when SAS_TASK_STATE_DONE is not\nset. And remove the check of the return value of the del_timer(). Once the\nLLDD sets DONE, it must call task->done(), which will call\nsmp_task_done()->complete() and the task will be completed and freed\ncorrectly.\n\nReported-by: chenxiang <chenxiang66@hisilicon.com>\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nCC: John Garry <john.garry@huawei.com>\nCC: Johannes Thumshirn <jthumshirn@suse.de>\nCC: Ewan Milne <emilne@redhat.com>\nCC: Christoph Hellwig <hch@lst.de>\nCC: Tomas Henzl <thenzl@redhat.com>\nCC: Dan Williams <dan.j.williams@intel.com>\nCC: Hannes Reinecke <hare@suse.com>\nReviewed-by: Hannes Reinecke <hare@suse.com>\nReviewed-by: John Garry <john.garry@huawei.com>\nReviewed-by: Johannes Thumshirn <jthumshirn@suse.de>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "commit_date": "2018-09-26T01:20:23Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/b90cd6f2b905905fb42671009dc0e27c310a16ae",
        "html_url": "https://github.com/torvalds/linux/commit/b90cd6f2b905905fb42671009dc0e27c310a16ae",
        "parents": [
            {
                "commit_id_before": "437207d3697f500f34f126a8ab1c29417ba4a184",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/437207d3697f500f34f126a8ab1c29417ba4a184",
                "html_url_before": "https://github.com/torvalds/linux/commit/437207d3697f500f34f126a8ab1c29417ba4a184"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3644,
        "cve_id": "CVE-2018-20856",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 4.18.7. In block/blk-core.c, there is an __blk_drain_queue() use-after-free because a certain error case is mishandled.",
        "cvss": "7.8",
        "publish_date": "July 25, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "54648cf1ec2d7f4b6a71767799c45676a138ca24",
        "commit_message": "block: blk_init_allocated_queue() set q->fq as NULL in the fail case\n\nWe find the memory use-after-free issue in __blk_drain_queue()\non the kernel 4.14. After read the latest kernel 4.18-rc6 we\nthink it has the same problem.\n\nMemory is allocated for q->fq in the blk_init_allocated_queue().\nIf the elevator init function called with error return, it will\nrun into the fail case to free the q->fq.\n\nThen the __blk_drain_queue() uses the same memory after the free\nof the q->fq, it will lead to the unpredictable event.\n\nThe patch is to set q->fq as NULL in the fail case of\nblk_init_allocated_queue().\n\nFixes: commit 7c94e1c157a2 (\"block: introduce blk_flush_queue to drive flush machinery\")\nCc: <stable@vger.kernel.org>\nReviewed-by: Ming Lei <ming.lei@redhat.com>\nReviewed-by: Bart Van Assche <bart.vanassche@wdc.com>\nSigned-off-by: xiao jin <jin.xiao@intel.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "commit_date": "2018-07-30T14:28:39Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/54648cf1ec2d7f4b6a71767799c45676a138ca24",
        "html_url": "https://github.com/torvalds/linux/commit/54648cf1ec2d7f4b6a71767799c45676a138ca24",
        "parents": [
            {
                "commit_id_before": "f7f1fc363aab4601786d373569c1ae802ea593d0",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f7f1fc363aab4601786d373569c1ae802ea593d0",
                "html_url_before": "https://github.com/torvalds/linux/commit/f7f1fc363aab4601786d373569c1ae802ea593d0"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 2646,
        "cve_id": "CVE-2018-5344",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "In the Linux kernel through 4.14.13, drivers/block/loop.c mishandles lo_release serialization, which allows attackers to cause a denial of service (__lock_acquire use-after-free) or possibly have unspecified other impact.",
        "cvss": "7.8",
        "publish_date": "January 12, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5",
        "commit_message": "loop: fix concurrent lo_open/lo_release\n\n\u8303\u9f99\u98de reports that KASAN can report a use-after-free in __lock_acquire.\nThe reason is due to insufficient serialization in lo_release(), which\nwill continue to use the loop device even after it has decremented the\nlo_refcnt to zero.\n\nIn the meantime, another process can come in, open the loop device\nagain as it is being shut down. Confusion ensues.\n\nReported-by: \u8303\u9f99\u98de <long7573@126.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "commit_date": "2018-01-06T16:32:07Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5",
        "html_url": "https://github.com/torvalds/linux/commit/ae6650163c66a7eff1acd6eb8b0f752dcfa8eba5",
        "parents": [
            {
                "commit_id_before": "cbf3a95924d515c1883aec2322fec277e4726134",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/cbf3a95924d515c1883aec2322fec277e4726134",
                "html_url_before": "https://github.com/torvalds/linux/commit/cbf3a95924d515c1883aec2322fec277e4726134"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3009,
        "cve_id": "CVE-2018-5873",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the __ns_get_path function in fs/nsfs.c in the Linux kernel before 4.11. Due to a race condition when accessing files, a Use After Free condition can occur. This also affects all Android releases from CAF using the Linux kernel (Android for MSM, Firefox OS for MSM, QRD Android) before security patch level 2018-07-05.",
        "cvss": "7.0",
        "publish_date": "July 6, 2018",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "073c516ff73557a8f7315066856c04b50383ac34",
        "commit_message": "nsfs: mark dentry with DCACHE_RCUACCESS\n\nAndrey reported a use-after-free in __ns_get_path():\n\n  spin_lock include/linux/spinlock.h:299 [inline]\n  lockref_get_not_dead+0x19/0x80 lib/lockref.c:179\n  __ns_get_path+0x197/0x860 fs/nsfs.c:66\n  open_related_ns+0xda/0x200 fs/nsfs.c:143\n  sock_ioctl+0x39d/0x440 net/socket.c:1001\n  vfs_ioctl fs/ioctl.c:45 [inline]\n  do_vfs_ioctl+0x1bf/0x1780 fs/ioctl.c:685\n  SYSC_ioctl fs/ioctl.c:700 [inline]\n  SyS_ioctl+0x8f/0xc0 fs/ioctl.c:691\n\nWe are under rcu read lock protection at that point:\n\n        rcu_read_lock();\n        d = atomic_long_read(&ns->stashed);\n        if (!d)\n                goto slow;\n        dentry = (struct dentry *)d;\n        if (!lockref_get_not_dead(&dentry->d_lockref))\n                goto slow;\n        rcu_read_unlock();\n\nbut don't use a proper RCU API on the free path, therefore a parallel\n__d_free() could free it at the same time.  We need to mark the stashed\ndentry with DCACHE_RCUACCESS so that __d_free() will be called after all\nreaders leave RCU.\n\nFixes: e149ed2b805f (\"take the targets of /proc/*/ns/* symlinks to separate fs\")\nCc: Alexander Viro <viro@zeniv.linux.org.uk>\nCc: Andrew Morton <akpm@linux-foundation.org>\nReported-by: Andrey Konovalov <andreyknvl@google.com>\nSigned-off-by: Cong Wang <xiyou.wangcong@gmail.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2017-04-19T22:56:24Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/073c516ff73557a8f7315066856c04b50383ac34",
        "html_url": "https://github.com/torvalds/linux/commit/073c516ff73557a8f7315066856c04b50383ac34",
        "parents": [
            {
                "commit_id_before": "80d136e138f59de35aafb0440e8ab2f51c40ccd5",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/80d136e138f59de35aafb0440e8ab2f51c40ccd5",
                "html_url_before": "https://github.com/torvalds/linux/commit/80d136e138f59de35aafb0440e8ab2f51c40ccd5"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3447,
        "cve_id": "CVE-2019-11487",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests.",
        "cvss": "7.8",
        "publish_date": "April 23, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "88b1a17dfc3ed7728316478fae0f5ad508f50397",
        "commit_message": "mm: add 'try_get_page()' helper function\n\nThis is the same as the traditional 'get_page()' function, but instead\nof unconditionally incrementing the reference count of the page, it only\ndoes so if the count was \"safe\".  It returns whether the reference count\nwas incremented (and is marked __must_check, since the caller obviously\nhas to be aware of it).\n\nAlso like 'get_page()', you can't use this function unless you already\nhad a reference to the page.  The intent is that you can use this\nexactly like get_page(), but in situations where you want to limit the\nmaximum reference count.\n\nThe code currently does an unconditional WARN_ON_ONCE() if we ever hit\nthe reference count issues (either zero or negative), as a notification\nthat the conditional non-increment actually happened.\n\nNOTE! The count access for the \"safety\" check is inherently racy, but\nthat doesn't matter since the buffer we use is basically half the range\nof the reference count (ie we look at the sign of the count).\n\nAcked-by: Matthew Wilcox <willy@infradead.org>\nCc: Jann Horn <jannh@google.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2019-04-14T17:00:04Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/88b1a17dfc3ed7728316478fae0f5ad508f50397",
        "html_url": "https://github.com/torvalds/linux/commit/88b1a17dfc3ed7728316478fae0f5ad508f50397",
        "parents": [
            {
                "commit_id_before": "f958d7b528b1b40c44cfda5eabe2d82760d868c3",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f958d7b528b1b40c44cfda5eabe2d82760d868c3",
                "html_url_before": "https://github.com/torvalds/linux/commit/f958d7b528b1b40c44cfda5eabe2d82760d868c3"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3448,
        "cve_id": "CVE-2019-11487",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests.",
        "cvss": "7.8",
        "publish_date": "April 23, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "6b3a707736301c2128ca85ce85fb13f60b5e350a",
        "commit_message": "Merge branch 'page-refs' (page ref overflow)\n\nMerge page ref overflow branch.\n\nJann Horn reported that he can overflow the page ref count with\nsufficient memory (and a filesystem that is intentionally extremely\nslow).\n\nAdmittedly it's not exactly easy.  To have more than four billion\nreferences to a page requires a minimum of 32GB of kernel memory just\nfor the pointers to the pages, much less any metadata to keep track of\nthose pointers.  Jann needed a total of 140GB of memory and a specially\ncrafted filesystem that leaves all reads pending (in order to not ever\nfree the page references and just keep adding more).\n\nStill, we have a fairly straightforward way to limit the two obvious\nuser-controllable sources of page references: direct-IO like page\nreferences gotten through get_user_pages(), and the splice pipe page\nduplication.  So let's just do that.\n\n* branch page-refs:\n  fs: prevent page refcount overflow in pipe_buf_get\n  mm: prevent get_user_pages() from overflowing page refcount\n  mm: add 'try_get_page()' helper function\n  mm: make page ref count overflow check tighter and more explicit",
        "commit_date": "2019-04-14T22:09:40Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/6b3a707736301c2128ca85ce85fb13f60b5e350a",
        "html_url": "https://github.com/torvalds/linux/commit/6b3a707736301c2128ca85ce85fb13f60b5e350a",
        "parents": [
            {
                "commit_id_before": "4443f8e6ac7755cd775c70d08be8042dc2f936cb",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/4443f8e6ac7755cd775c70d08be8042dc2f936cb",
                "html_url_before": "https://github.com/torvalds/linux/commit/4443f8e6ac7755cd775c70d08be8042dc2f936cb"
            },
            {
                "commit_id_before": "15fab63e1e57be9fdb5eec1bbc5916e9825e9acb",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb",
                "html_url_before": "https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3449,
        "cve_id": "CVE-2019-11487",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests.",
        "cvss": "7.8",
        "publish_date": "April 23, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "f958d7b528b1b40c44cfda5eabe2d82760d868c3",
        "commit_message": "mm: make page ref count overflow check tighter and more explicit\n\nWe have a VM_BUG_ON() to check that the page reference count doesn't\nunderflow (or get close to overflow) by checking the sign of the count.\n\nThat's all fine, but we actually want to allow people to use a \"get page\nref unless it's already very high\" helper function, and we want that one\nto use the sign of the page ref (without triggering this VM_BUG_ON).\n\nChange the VM_BUG_ON to only check for small underflows (or _very_ close\nto overflowing), and ignore overflows which have strayed into negative\nterritory.\n\nAcked-by: Matthew Wilcox <willy@infradead.org>\nCc: Jann Horn <jannh@google.com>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2019-04-14T17:00:04Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/f958d7b528b1b40c44cfda5eabe2d82760d868c3",
        "html_url": "https://github.com/torvalds/linux/commit/f958d7b528b1b40c44cfda5eabe2d82760d868c3",
        "parents": [
            {
                "commit_id_before": "1c163f4c7b3f621efff9b28a47abb36f7378d783",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/1c163f4c7b3f621efff9b28a47abb36f7378d783",
                "html_url_before": "https://github.com/torvalds/linux/commit/1c163f4c7b3f621efff9b28a47abb36f7378d783"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3450,
        "cve_id": "CVE-2019-11487",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests.",
        "cvss": "7.8",
        "publish_date": "April 23, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "15fab63e1e57be9fdb5eec1bbc5916e9825e9acb",
        "commit_message": "fs: prevent page refcount overflow in pipe_buf_get\n\nChange pipe_buf_get() to return a bool indicating whether it succeeded\nin raising the refcount of the page (if the thing in the pipe is a page).\nThis removes another mechanism for overflowing the page refcount.  All\ncallers converted to handle a failure.\n\nReported-by: Jann Horn <jannh@google.com>\nSigned-off-by: Matthew Wilcox <willy@infradead.org>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2019-04-14T17:00:04Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb",
        "html_url": "https://github.com/torvalds/linux/commit/15fab63e1e57be9fdb5eec1bbc5916e9825e9acb",
        "parents": [
            {
                "commit_id_before": "8fde12ca79aff9b5ba951fce1a2641901b8d8e64",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/8fde12ca79aff9b5ba951fce1a2641901b8d8e64",
                "html_url_before": "https://github.com/torvalds/linux/commit/8fde12ca79aff9b5ba951fce1a2641901b8d8e64"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3451,
        "cve_id": "CVE-2019-11487",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The Linux kernel before 5.1-rc5 allows page->_refcount reference count overflow, with resultant use-after-free issues, if about 140 GiB of RAM exists. This is related to fs/fuse/dev.c, fs/pipe.c, fs/splice.c, include/linux/mm.h, include/linux/pipe_fs_i.h, kernel/trace/trace.c, mm/gup.c, and mm/hugetlb.c. It can occur with FUSE requests.",
        "cvss": "7.8",
        "publish_date": "April 23, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "8fde12ca79aff9b5ba951fce1a2641901b8d8e64",
        "commit_message": "mm: prevent get_user_pages() from overflowing page refcount\n\nIf the page refcount wraps around past zero, it will be freed while\nthere are still four billion references to it.  One of the possible\navenues for an attacker to try to make this happen is by doing direct IO\non a page multiple times.  This patch makes get_user_pages() refuse to\ntake a new page reference if there are already more than two billion\nreferences to the page.\n\nReported-by: Jann Horn <jannh@google.com>\nAcked-by: Matthew Wilcox <willy@infradead.org>\nCc: stable@kernel.org\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2019-04-14T17:00:04Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/8fde12ca79aff9b5ba951fce1a2641901b8d8e64",
        "html_url": "https://github.com/torvalds/linux/commit/8fde12ca79aff9b5ba951fce1a2641901b8d8e64",
        "parents": [
            {
                "commit_id_before": "88b1a17dfc3ed7728316478fae0f5ad508f50397",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/88b1a17dfc3ed7728316478fae0f5ad508f50397",
                "html_url_before": "https://github.com/torvalds/linux/commit/88b1a17dfc3ed7728316478fae0f5ad508f50397"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3544,
        "cve_id": "CVE-2019-11810",
        "cwe_id": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 5.0.7. A NULL pointer dereference can occur when megasas_create_frame_pool() fails in megasas_alloc_cmds() in drivers/scsi/megaraid/megaraid_sas_base.c. This causes a Denial of Service, related to a use-after-free.",
        "cvss": "7.5",
        "publish_date": "May 7, 2019",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "bcf3b67d16a4c8ffae0aa79de5853435e683945c",
        "commit_message": "scsi: megaraid_sas: return error when create DMA pool failed\n\nwhen create DMA pool for cmd frames failed, we should return -ENOMEM,\ninstead of 0.\nIn some case in:\n\n    megasas_init_adapter_fusion()\n\n    -->megasas_alloc_cmds()\n       -->megasas_create_frame_pool\n          create DMA pool failed,\n        --> megasas_free_cmds() [1]\n\n    -->megasas_alloc_cmds_fusion()\n       failed, then goto fail_alloc_cmds.\n    -->megasas_free_cmds() [2]\n\nwe will call megasas_free_cmds twice, [1] will kfree cmd_list,\n[2] will use cmd_list.it will cause a problem:\n\nUnable to handle kernel NULL pointer dereference at virtual address\n00000000\npgd = ffffffc000f70000\n[00000000] *pgd=0000001fbf893003, *pud=0000001fbf893003,\n*pmd=0000001fbf894003, *pte=006000006d000707\nInternal error: Oops: 96000005 [#1] SMP\n Modules linked in:\n CPU: 18 PID: 1 Comm: swapper/0 Not tainted\n task: ffffffdfb9290000 ti: ffffffdfb923c000 task.ti: ffffffdfb923c000\n PC is at megasas_free_cmds+0x30/0x70\n LR is at megasas_free_cmds+0x24/0x70\n ...\n Call trace:\n [<ffffffc0005b779c>] megasas_free_cmds+0x30/0x70\n [<ffffffc0005bca74>] megasas_init_adapter_fusion+0x2f4/0x4d8\n [<ffffffc0005b926c>] megasas_init_fw+0x2dc/0x760\n [<ffffffc0005b9ab0>] megasas_probe_one+0x3c0/0xcd8\n [<ffffffc0004a5abc>] local_pci_probe+0x4c/0xb4\n [<ffffffc0004a5c40>] pci_device_probe+0x11c/0x14c\n [<ffffffc00053a5e4>] driver_probe_device+0x1ec/0x430\n [<ffffffc00053a92c>] __driver_attach+0xa8/0xb0\n [<ffffffc000538178>] bus_for_each_dev+0x74/0xc8\n  [<ffffffc000539e88>] driver_attach+0x28/0x34\n [<ffffffc000539a18>] bus_add_driver+0x16c/0x248\n [<ffffffc00053b234>] driver_register+0x6c/0x138\n [<ffffffc0004a5350>] __pci_register_driver+0x5c/0x6c\n [<ffffffc000ce3868>] megasas_init+0xc0/0x1a8\n [<ffffffc000082a58>] do_one_initcall+0xe8/0x1ec\n [<ffffffc000ca7be8>] kernel_init_freeable+0x1c8/0x284\n [<ffffffc0008d90b8>] kernel_init+0x1c/0xe4\n\nSigned-off-by: Jason Yan <yanaijie@huawei.com>\nAcked-by: Sumit Saxena <sumit.saxena@broadcom.com>\nSigned-off-by: Martin K. Petersen <martin.petersen@oracle.com>",
        "commit_date": "2019-02-19T23:58:38Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/bcf3b67d16a4c8ffae0aa79de5853435e683945c",
        "html_url": "https://github.com/torvalds/linux/commit/bcf3b67d16a4c8ffae0aa79de5853435e683945c",
        "parents": [
            {
                "commit_id_before": "f3e026951771bceb17319a4d0d6121ca58746c88",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f3e026951771bceb17319a4d0d6121ca58746c88",
                "html_url_before": "https://github.com/torvalds/linux/commit/f3e026951771bceb17319a4d0d6121ca58746c88"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3545,
        "cve_id": "CVE-2019-11811",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 5.0.4. There is a use-after-free upon attempted read access to /proc/ioports after the ipmi_si module is removed, related to drivers/char/ipmi/ipmi_si_intf.c, drivers/char/ipmi/ipmi_si_mem_io.c, and drivers/char/ipmi/ipmi_si_port_io.c.",
        "cvss": "7.0",
        "publish_date": "May 7, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "401e7e88d4ef80188ffa07095ac00456f901b8c4",
        "commit_message": "ipmi_si: fix use-after-free of resource->name\n\nWhen we excute the following commands, we got oops\nrmmod ipmi_si\ncat /proc/ioports\n\n[ 1623.482380] Unable to handle kernel paging request at virtual address ffff00000901d478\n[ 1623.482382] Mem abort info:\n[ 1623.482383]   ESR = 0x96000007\n[ 1623.482385]   Exception class = DABT (current EL), IL = 32 bits\n[ 1623.482386]   SET = 0, FnV = 0\n[ 1623.482387]   EA = 0, S1PTW = 0\n[ 1623.482388] Data abort info:\n[ 1623.482389]   ISV = 0, ISS = 0x00000007\n[ 1623.482390]   CM = 0, WnR = 0\n[ 1623.482393] swapper pgtable: 4k pages, 48-bit VAs, pgdp = 00000000d7d94a66\n[ 1623.482395] [ffff00000901d478] pgd=000000dffbfff003, pud=000000dffbffe003, pmd=0000003f5d06e003, pte=0000000000000000\n[ 1623.482399] Internal error: Oops: 96000007 [#1] SMP\n[ 1623.487407] Modules linked in: ipmi_si(E) nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm dm_mirror dm_region_hash dm_log iw_cm dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ses ghash_ce sha2_ce enclosure sha256_arm64 sg sha1_ce hisi_sas_v2_hw hibmc_drm sbsa_gwdt hisi_sas_main ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe mdio hns_dsaf ipmi_devintf hns_enet_drv ipmi_msghandler hns_mdio [last unloaded: ipmi_si]\n[ 1623.532410] CPU: 30 PID: 11438 Comm: cat Kdump: loaded Tainted: G            E     5.0.0-rc3+ #168\n[ 1623.541498] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017\n[ 1623.548822] pstate: a0000005 (NzCv daif -PAN -UAO)\n[ 1623.553684] pc : string+0x28/0x98\n[ 1623.557040] lr : vsnprintf+0x368/0x5e8\n[ 1623.560837] sp : ffff000013213a80\n[ 1623.564191] x29: ffff000013213a80 x28: ffff00001138abb5\n[ 1623.569577] x27: ffff000013213c18 x26: ffff805f67d06049\n[ 1623.574963] x25: 0000000000000000 x24: ffff00001138abb5\n[ 1623.580349] x23: 0000000000000fb7 x22: ffff0000117ed000\n[ 1623.585734] x21: ffff000011188fd8 x20: ffff805f67d07000\n[ 1623.591119] x19: ffff805f67d06061 x18: ffffffffffffffff\n[ 1623.596505] x17: 0000000000000200 x16: 0000000000000000\n[ 1623.601890] x15: ffff0000117ed748 x14: ffff805f67d07000\n[ 1623.607276] x13: ffff805f67d0605e x12: 0000000000000000\n[ 1623.612661] x11: 0000000000000000 x10: 0000000000000000\n[ 1623.618046] x9 : 0000000000000000 x8 : 000000000000000f\n[ 1623.623432] x7 : ffff805f67d06061 x6 : fffffffffffffffe\n[ 1623.628817] x5 : 0000000000000012 x4 : ffff00000901d478\n[ 1623.634203] x3 : ffff0a00ffffff04 x2 : ffff805f67d07000\n[ 1623.639588] x1 : ffff805f67d07000 x0 : ffffffffffffffff\n[ 1623.644974] Process cat (pid: 11438, stack limit = 0x000000008d4cbc10)\n[ 1623.651592] Call trace:\n[ 1623.654068]  string+0x28/0x98\n[ 1623.657071]  vsnprintf+0x368/0x5e8\n[ 1623.660517]  seq_vprintf+0x70/0x98\n[ 1623.668009]  seq_printf+0x7c/0xa0\n[ 1623.675530]  r_show+0xc8/0xf8\n[ 1623.682558]  seq_read+0x330/0x440\n[ 1623.689877]  proc_reg_read+0x78/0xd0\n[ 1623.697346]  __vfs_read+0x60/0x1a0\n[ 1623.704564]  vfs_read+0x94/0x150\n[ 1623.711339]  ksys_read+0x6c/0xd8\n[ 1623.717939]  __arm64_sys_read+0x24/0x30\n[ 1623.725077]  el0_svc_common+0x120/0x148\n[ 1623.732035]  el0_svc_handler+0x30/0x40\n[ 1623.738757]  el0_svc+0x8/0xc\n[ 1623.744520] Code: d1000406 aa0103e2 54000149 b4000080 (39400085)\n[ 1623.753441] ---[ end trace f91b6a4937de9835 ]---\n[ 1623.760871] Kernel panic - not syncing: Fatal exception\n[ 1623.768935] SMP: stopping secondary CPUs\n[ 1623.775718] Kernel Offset: disabled\n[ 1623.781998] CPU features: 0x002,21006008\n[ 1623.788777] Memory Limit: none\n[ 1623.798329] Starting crashdump kernel...\n[ 1623.805202] Bye!\n\nIf io_setup is called successful in try_smi_init() but try_smi_init()\ngoes out_err before calling ipmi_register_smi(), so ipmi_unregister_smi()\nwill not be called while removing module. It leads to the resource that\nallocated in io_setup() can not be freed, but the name(DEVICE_NAME) of\nresource is freed while removing the module. It causes use-after-free\nwhen cat /proc/ioports.\n\nFix this by calling io_cleanup() while try_smi_init() goes to out_err.\nand don't call io_cleanup() until io_setup() returns successful to avoid\nwarning prints.\n\nFixes: 93c303d2045b (\"ipmi_si: Clean up shutdown a bit\")\nCc: stable@vger.kernel.org\nReported-by: NuoHan Qiao <qiaonuohan@huawei.com>\nSuggested-by: Corey Minyard <cminyard@mvista.com>\nSigned-off-by: Yang Yingliang <yangyingliang@huawei.com>\nSigned-off-by: Corey Minyard <cminyard@mvista.com>",
        "commit_date": "2019-02-10T01:48:41Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/401e7e88d4ef80188ffa07095ac00456f901b8c4",
        "html_url": "https://github.com/torvalds/linux/commit/401e7e88d4ef80188ffa07095ac00456f901b8c4",
        "parents": [
            {
                "commit_id_before": "df3865f8f56879b7e9f0ca47fa7bc5f2252df6d3",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/df3865f8f56879b7e9f0ca47fa7bc5f2252df6d3",
                "html_url_before": "https://github.com/torvalds/linux/commit/df3865f8f56879b7e9f0ca47fa7bc5f2252df6d3"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3539,
        "cve_id": "CVE-2019-11815",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in rds_tcp_kill_sock in net/rds/tcp.c in the Linux kernel before 5.0.8. There is a race condition leading to a use-after-free, related to net namespace cleanup.",
        "cvss": "8.1",
        "publish_date": "May 8, 2019",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "cb66ddd156203daefb8d71158036b27b0e2caf63",
        "commit_message": "net: rds: force to destroy connection if t_sock is NULL in rds_tcp_kill_sock().\n\nWhen it is to cleanup net namespace, rds_tcp_exit_net() will call\nrds_tcp_kill_sock(), if t_sock is NULL, it will not call\nrds_conn_destroy(), rds_conn_path_destroy() and rds_tcp_conn_free() to free\nconnection, and the worker cp_conn_w is not stopped, afterwards the net is freed in\nnet_drop_ns(); While cp_conn_w rds_connect_worker() will call rds_tcp_conn_path_connect()\nand reference 'net' which has already been freed.\n\nIn rds_tcp_conn_path_connect(), rds_tcp_set_callbacks() will set t_sock = sock before\nsock->ops->connect, but if connect() is failed, it will call\nrds_tcp_restore_callbacks() and set t_sock = NULL, if connect is always\nfailed, rds_connect_worker() will try to reconnect all the time, so\nrds_tcp_kill_sock() will never to cancel worker cp_conn_w and free the\nconnections.\n\nTherefore, the condition !tc->t_sock is not needed if it is going to do\ncleanup_net->rds_tcp_exit_net->rds_tcp_kill_sock, because tc->t_sock is always\nNULL, and there is on other path to cancel cp_conn_w and free\nconnection. So this patch is to fix this.\n\nrds_tcp_kill_sock():\n...\nif (net != c_net || !tc->t_sock)\n...\nAcked-by: Santosh Shilimkar <santosh.shilimkar@oracle.com>\n\n==================================================================\nBUG: KASAN: use-after-free in inet_create+0xbcc/0xd28\nnet/ipv4/af_inet.c:340\nRead of size 4 at addr ffff8003496a4684 by task kworker/u8:4/3721\n\nCPU: 3 PID: 3721 Comm: kworker/u8:4 Not tainted 5.1.0 #11\nHardware name: linux,dummy-virt (DT)\nWorkqueue: krdsd rds_connect_worker\nCall trace:\n dump_backtrace+0x0/0x3c0 arch/arm64/kernel/time.c:53\n show_stack+0x28/0x38 arch/arm64/kernel/traps.c:152\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0x120/0x188 lib/dump_stack.c:113\n print_address_description+0x68/0x278 mm/kasan/report.c:253\n kasan_report_error mm/kasan/report.c:351 [inline]\n kasan_report+0x21c/0x348 mm/kasan/report.c:409\n __asan_report_load4_noabort+0x30/0x40 mm/kasan/report.c:429\n inet_create+0xbcc/0xd28 net/ipv4/af_inet.c:340\n __sock_create+0x4f8/0x770 net/socket.c:1276\n sock_create_kern+0x50/0x68 net/socket.c:1322\n rds_tcp_conn_path_connect+0x2b4/0x690 net/rds/tcp_connect.c:114\n rds_connect_worker+0x108/0x1d0 net/rds/threads.c:175\n process_one_work+0x6e8/0x1700 kernel/workqueue.c:2153\n worker_thread+0x3b0/0xdd0 kernel/workqueue.c:2296\n kthread+0x2f0/0x378 kernel/kthread.c:255\n ret_from_fork+0x10/0x18 arch/arm64/kernel/entry.S:1117\n\nAllocated by task 687:\n save_stack mm/kasan/kasan.c:448 [inline]\n set_track mm/kasan/kasan.c:460 [inline]\n kasan_kmalloc+0xd4/0x180 mm/kasan/kasan.c:553\n kasan_slab_alloc+0x14/0x20 mm/kasan/kasan.c:490\n slab_post_alloc_hook mm/slab.h:444 [inline]\n slab_alloc_node mm/slub.c:2705 [inline]\n slab_alloc mm/slub.c:2713 [inline]\n kmem_cache_alloc+0x14c/0x388 mm/slub.c:2718\n kmem_cache_zalloc include/linux/slab.h:697 [inline]\n net_alloc net/core/net_namespace.c:384 [inline]\n copy_net_ns+0xc4/0x2d0 net/core/net_namespace.c:424\n create_new_namespaces+0x300/0x658 kernel/nsproxy.c:107\n unshare_nsproxy_namespaces+0xa0/0x198 kernel/nsproxy.c:206\n ksys_unshare+0x340/0x628 kernel/fork.c:2577\n __do_sys_unshare kernel/fork.c:2645 [inline]\n __se_sys_unshare kernel/fork.c:2643 [inline]\n __arm64_sys_unshare+0x38/0x58 kernel/fork.c:2643\n __invoke_syscall arch/arm64/kernel/syscall.c:35 [inline]\n invoke_syscall arch/arm64/kernel/syscall.c:47 [inline]\n el0_svc_common+0x168/0x390 arch/arm64/kernel/syscall.c:83\n el0_svc_handler+0x60/0xd0 arch/arm64/kernel/syscall.c:129\n el0_svc+0x8/0xc arch/arm64/kernel/entry.S:960\n\nFreed by task 264:\n save_stack mm/kasan/kasan.c:448 [inline]\n set_track mm/kasan/kasan.c:460 [inline]\n __kasan_slab_free+0x114/0x220 mm/kasan/kasan.c:521\n kasan_slab_free+0x10/0x18 mm/kasan/kasan.c:528\n slab_free_hook mm/slub.c:1370 [inline]\n slab_free_freelist_hook mm/slub.c:1397 [inline]\n slab_free mm/slub.c:2952 [inline]\n kmem_cache_free+0xb8/0x3a8 mm/slub.c:2968\n net_free net/core/net_namespace.c:400 [inline]\n net_drop_ns.part.6+0x78/0x90 net/core/net_namespace.c:407\n net_drop_ns net/core/net_namespace.c:406 [inline]\n cleanup_net+0x53c/0x6d8 net/core/net_namespace.c:569\n process_one_work+0x6e8/0x1700 kernel/workqueue.c:2153\n worker_thread+0x3b0/0xdd0 kernel/workqueue.c:2296\n kthread+0x2f0/0x378 kernel/kthread.c:255\n ret_from_fork+0x10/0x18 arch/arm64/kernel/entry.S:1117\n\nThe buggy address belongs to the object at ffff8003496a3f80\n which belongs to the cache net_namespace of size 7872\nThe buggy address is located 1796 bytes inside of\n 7872-byte region [ffff8003496a3f80, ffff8003496a5e40)\nThe buggy address belongs to the page:\npage:ffff7e000d25a800 count:1 mapcount:0 mapping:ffff80036ce4b000\nindex:0x0 compound_mapcount: 0\nflags: 0xffffe0000008100(slab|head)\nraw: 0ffffe0000008100 dead000000000100 dead000000000200 ffff80036ce4b000\nraw: 0000000000000000 0000000080040004 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff8003496a4580: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8003496a4600: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff8003496a4680: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                   ^\n ffff8003496a4700: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8003496a4780: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n==================================================================\n\nFixes: 467fa15356ac(\"RDS-TCP: Support multiple RDS-TCP listen endpoints, one per netns.\")\nReported-by: Hulk Robot <hulkci@huawei.com>\nSigned-off-by: Mao Wenan <maowenan@huawei.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2019-03-29T00:17:18Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/cb66ddd156203daefb8d71158036b27b0e2caf63",
        "html_url": "https://github.com/torvalds/linux/commit/cb66ddd156203daefb8d71158036b27b0e2caf63",
        "parents": [
            {
                "commit_id_before": "f28cd2af22a0c134e4aa1c64a70f70d815d473fb",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f28cd2af22a0c134e4aa1c64a70f70d815d473fb",
                "html_url_before": "https://github.com/torvalds/linux/commit/f28cd2af22a0c134e4aa1c64a70f70d815d473fb"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3592,
        "cve_id": "CVE-2019-12819",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 5.0. The function __mdiobus_register() in drivers/net/phy/mdio_bus.c calls put_device(), which will trigger a fixed_mdio_bus_init use-after-free. This will cause a denial of service.",
        "cvss": "5.5",
        "publish_date": "June 13, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "6ff7b060535e87c2ae14dd8548512abfdda528fb",
        "commit_message": "mdio_bus: Fix use-after-free on device_register fails\n\nKASAN has found use-after-free in fixed_mdio_bus_init,\ncommit 0c692d07842a (\"drivers/net/phy/mdio_bus.c: call\nput_device on device_register() failure\") call put_device()\nwhile device_register() fails,give up the last reference\nto the device and allow mdiobus_release to be executed\n,kfreeing the bus. However in most drives, mdiobus_free\nbe called to free the bus while mdiobus_register fails.\nuse-after-free occurs when access bus again, this patch\nrevert it to let mdiobus_free free the bus.\n\nKASAN report details as below:\n\nBUG: KASAN: use-after-free in mdiobus_free+0x85/0x90 drivers/net/phy/mdio_bus.c:482\nRead of size 4 at addr ffff8881dc824d78 by task syz-executor.0/3524\n\nCPU: 1 PID: 3524 Comm: syz-executor.0 Not tainted 5.0.0-rc7+ #45\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xfa/0x1ce lib/dump_stack.c:113\n print_address_description+0x65/0x270 mm/kasan/report.c:187\n kasan_report+0x149/0x18d mm/kasan/report.c:317\n mdiobus_free+0x85/0x90 drivers/net/phy/mdio_bus.c:482\n fixed_mdio_bus_init+0x283/0x1000 [fixed_phy]\n ? 0xffffffffc0e40000\n ? 0xffffffffc0e40000\n ? 0xffffffffc0e40000\n do_one_initcall+0xfa/0x5ca init/main.c:887\n do_init_module+0x204/0x5f6 kernel/module.c:3460\n load_module+0x66b2/0x8570 kernel/module.c:3808\n __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902\n do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\nRIP: 0033:0x462e99\nCode: f7 d8 64 89 02 b8 ff ff ff ff c3 66 0f 1f 44 00 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 73 01 c3 48 c7 c1 bc ff ff ff f7 d8 64 89 01 48\nRSP: 002b:00007f6215c19c58 EFLAGS: 00000246 ORIG_RAX: 0000000000000139\nRAX: ffffffffffffffda RBX: 000000000073bf00 RCX: 0000000000462e99\nRDX: 0000000000000000 RSI: 0000000020000080 RDI: 0000000000000003\nRBP: 00007f6215c19c70 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 00007f6215c1a6bc\nR13: 00000000004bcefb R14: 00000000006f7030 R15: 0000000000000004\n\nAllocated by task 3524:\n set_track mm/kasan/common.c:85 [inline]\n __kasan_kmalloc.constprop.3+0xa0/0xd0 mm/kasan/common.c:496\n kmalloc include/linux/slab.h:545 [inline]\n kzalloc include/linux/slab.h:740 [inline]\n mdiobus_alloc_size+0x54/0x1b0 drivers/net/phy/mdio_bus.c:143\n fixed_mdio_bus_init+0x163/0x1000 [fixed_phy]\n do_one_initcall+0xfa/0x5ca init/main.c:887\n do_init_module+0x204/0x5f6 kernel/module.c:3460\n load_module+0x66b2/0x8570 kernel/module.c:3808\n __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902\n do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nFreed by task 3524:\n set_track mm/kasan/common.c:85 [inline]\n __kasan_slab_free+0x130/0x180 mm/kasan/common.c:458\n slab_free_hook mm/slub.c:1409 [inline]\n slab_free_freelist_hook mm/slub.c:1436 [inline]\n slab_free mm/slub.c:2986 [inline]\n kfree+0xe1/0x270 mm/slub.c:3938\n device_release+0x78/0x200 drivers/base/core.c:919\n kobject_cleanup lib/kobject.c:662 [inline]\n kobject_release lib/kobject.c:691 [inline]\n kref_put include/linux/kref.h:67 [inline]\n kobject_put+0x146/0x240 lib/kobject.c:708\n put_device+0x1c/0x30 drivers/base/core.c:2060\n __mdiobus_register+0x483/0x560 drivers/net/phy/mdio_bus.c:382\n fixed_mdio_bus_init+0x26b/0x1000 [fixed_phy]\n do_one_initcall+0xfa/0x5ca init/main.c:887\n do_init_module+0x204/0x5f6 kernel/module.c:3460\n load_module+0x66b2/0x8570 kernel/module.c:3808\n __do_sys_finit_module+0x238/0x2a0 kernel/module.c:3902\n do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290\n entry_SYSCALL_64_after_hwframe+0x49/0xbe\n\nThe buggy address belongs to the object at ffff8881dc824c80\n which belongs to the cache kmalloc-2k of size 2048\nThe buggy address is located 248 bytes inside of\n 2048-byte region [ffff8881dc824c80, ffff8881dc825480)\nThe buggy address belongs to the page:\npage:ffffea0007720800 count:1 mapcount:0 mapping:ffff8881f6c02800 index:0x0 compound_mapcount: 0\nflags: 0x2fffc0000010200(slab|head)\nraw: 02fffc0000010200 0000000000000000 0000000500000001 ffff8881f6c02800\nraw: 0000000000000000 00000000800f000f 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff8881dc824c00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff8881dc824c80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff8881dc824d00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                                                ^\n ffff8881dc824d80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff8881dc824e00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\nFixes: 0c692d07842a (\"drivers/net/phy/mdio_bus.c: call put_device on device_register() failure\")\nSigned-off-by: YueHaibing <yuehaibing@huawei.com>\nReviewed-by: Andrew Lunn <andrew@lunn.ch>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2019-02-22T23:34:07Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/6ff7b060535e87c2ae14dd8548512abfdda528fb",
        "html_url": "https://github.com/torvalds/linux/commit/6ff7b060535e87c2ae14dd8548512abfdda528fb",
        "parents": [
            {
                "commit_id_before": "97f0082a0592212fc15d4680f5a4d80f79a1687c",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/97f0082a0592212fc15d4680f5a4d80f79a1687c",
                "html_url_before": "https://github.com/torvalds/linux/commit/97f0082a0592212fc15d4680f5a4d80f79a1687c"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3737,
        "cve_id": "CVE-2019-13233",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "In arch/x86/lib/insn-eval.c in the Linux kernel before 5.1.9, there is a use-after-free for access to an LDT entry because of a race condition between modify_ldt() and a #BR exception for an MPX bounds violation.",
        "cvss": "7.0",
        "publish_date": "July 4, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "de9f869616dd95e95c00bdd6b0fcd3421e8a4323",
        "commit_message": "x86/insn-eval: Fix use-after-free access to LDT entry\n\nget_desc() computes a pointer into the LDT while holding a lock that\nprotects the LDT from being freed, but then drops the lock and returns the\n(now potentially dangling) pointer to its caller.\n\nFix it by giving the caller a copy of the LDT entry instead.\n\nFixes: 670f928ba09b (\"x86/insn-eval: Add utility function to get segment descriptor\")\nCc: stable@vger.kernel.org\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2019-06-07T18:11:06Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/de9f869616dd95e95c00bdd6b0fcd3421e8a4323",
        "html_url": "https://github.com/torvalds/linux/commit/de9f869616dd95e95c00bdd6b0fcd3421e8a4323",
        "parents": [
            {
                "commit_id_before": "1e1d926369545ea09c98c6c7f5d109aa4ee0cd0b",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/1e1d926369545ea09c98c6c7f5d109aa4ee0cd0b",
                "html_url_before": "https://github.com/torvalds/linux/commit/1e1d926369545ea09c98c6c7f5d109aa4ee0cd0b"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3912,
        "cve_id": "CVE-2019-15917",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 5.0.5. There is a use-after-free issue when hci_uart_register_dev() fails in hci_uart_set_proto() in drivers/bluetooth/hci_ldisc.c.",
        "cvss": "7.0",
        "publish_date": "September 4, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "56897b217a1d0a91c9920cb418d6b3fe922f590a",
        "commit_message": "Bluetooth: hci_ldisc: Postpone HCI_UART_PROTO_READY bit set in hci_uart_set_proto()\n\ntask A:                                task B:\nhci_uart_set_proto                     flush_to_ldisc\n - p->open(hu) -> h5_open  //alloc h5  - receive_buf\n - set_bit HCI_UART_PROTO_READY         - tty_port_default_receive_buf\n - hci_uart_register_dev                 - tty_ldisc_receive_buf\n                                          - hci_uart_tty_receive\n\t\t\t\t           - test_bit HCI_UART_PROTO_READY\n\t\t\t\t            - h5_recv\n - clear_bit HCI_UART_PROTO_READY             while() {\n - p->open(hu) -> h5_close //free h5\n\t\t\t\t              - h5_rx_3wire_hdr\n\t\t\t\t               - h5_reset()  //use-after-free\n                                              }\n\nIt could use ioctl to set hci uart proto, but there is\na use-after-free issue when hci_uart_register_dev() fail in\nhci_uart_set_proto(), see stack above, fix this by setting\nHCI_UART_PROTO_READY bit only when hci_uart_register_dev()\nreturn success.\n\nReported-by: syzbot+899a33dc0fa0dbaf06a6@syzkaller.appspotmail.com\nSigned-off-by: Kefeng Wang <wangkefeng.wang@huawei.com>\nReviewed-by: Jeremy Cline <jcline@redhat.com>\nSigned-off-by: Marcel Holtmann <marcel@holtmann.org>",
        "commit_date": "2019-02-26T08:55:39Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/56897b217a1d0a91c9920cb418d6b3fe922f590a",
        "html_url": "https://github.com/torvalds/linux/commit/56897b217a1d0a91c9920cb418d6b3fe922f590a",
        "parents": [
            {
                "commit_id_before": "4a67e5d4adbf3b419f17924322f468ac5cb8c14f",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/4a67e5d4adbf3b419f17924322f468ac5cb8c14f",
                "html_url_before": "https://github.com/torvalds/linux/commit/4a67e5d4adbf3b419f17924322f468ac5cb8c14f"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3914,
        "cve_id": "CVE-2019-15919",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 5.0.10. SMB2_write in fs/cifs/smb2pdu.c has a use-after-free.",
        "cvss": "3.3",
        "publish_date": "September 4, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "LOW",
        "I": "NONE",
        "A": "NONE",
        "commit_id": "6a3eb3360667170988f8a6477f6686242061488a",
        "commit_message": "cifs: Fix use-after-free in SMB2_write\n\nThere is a KASAN use-after-free:\nBUG: KASAN: use-after-free in SMB2_write+0x1342/0x1580\nRead of size 8 at addr ffff8880b6a8e450 by task ln/4196\n\nShould not release the 'req' because it will use in the trace.\n\nFixes: eccb4422cf97 (\"smb3: Add ftrace tracepoints for improved SMB3 debugging\")\n\nSigned-off-by: ZhangXiaoxu <zhangxiaoxu5@huawei.com>\nSigned-off-by: Steve French <stfrench@microsoft.com>\nCC: Stable <stable@vger.kernel.org> 4.18+\nReviewed-by: Pavel Shilovsky <pshilov@microsoft.com>",
        "commit_date": "2019-04-16T14:38:18Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/6a3eb3360667170988f8a6477f6686242061488a",
        "html_url": "https://github.com/torvalds/linux/commit/6a3eb3360667170988f8a6477f6686242061488a",
        "parents": [
            {
                "commit_id_before": "618d919cae2fcaadc752f27ddac8b939da8b441a",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/618d919cae2fcaadc752f27ddac8b939da8b441a",
                "html_url_before": "https://github.com/torvalds/linux/commit/618d919cae2fcaadc752f27ddac8b939da8b441a"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3915,
        "cve_id": "CVE-2019-15920",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 5.0.10. SMB2_read in fs/cifs/smb2pdu.c has a use-after-free. NOTE: this was not fixed correctly in 5.0.10; see the 5.0.11 ChangeLog, which documents a memory leak.",
        "cvss": "4.3",
        "publish_date": "September 4, 2019",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "LOW",
        "I": "NONE",
        "A": "NONE",
        "commit_id": "088aaf17aa79300cab14dbee2569c58cfafd7d6e",
        "commit_message": "cifs: Fix use-after-free in SMB2_read\n\nThere is a KASAN use-after-free:\nBUG: KASAN: use-after-free in SMB2_read+0x1136/0x1190\nRead of size 8 at addr ffff8880b4e45e50 by task ln/1009\n\nShould not release the 'req' because it will use in the trace.\n\nFixes: eccb4422cf97 (\"smb3: Add ftrace tracepoints for improved SMB3 debugging\")\n\nSigned-off-by: ZhangXiaoxu <zhangxiaoxu5@huawei.com>\nSigned-off-by: Steve French <stfrench@microsoft.com>\nCC: Stable <stable@vger.kernel.org> 4.18+\nReviewed-by: Pavel Shilovsky <pshilov@microsoft.com>",
        "commit_date": "2019-04-16T14:38:21Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/088aaf17aa79300cab14dbee2569c58cfafd7d6e",
        "html_url": "https://github.com/torvalds/linux/commit/088aaf17aa79300cab14dbee2569c58cfafd7d6e",
        "parents": [
            {
                "commit_id_before": "6a3eb3360667170988f8a6477f6686242061488a",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/6a3eb3360667170988f8a6477f6686242061488a",
                "html_url_before": "https://github.com/torvalds/linux/commit/6a3eb3360667170988f8a6477f6686242061488a"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 4211,
        "cve_id": "CVE-2019-19767",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "The Linux kernel before 5.4.2 mishandles ext4_expand_extra_isize, as demonstrated by use-after-free errors in __ext4_expand_extra_isize and ext4_xattr_set_entry, related to fs/ext4/inode.c and fs/ext4/super.c, aka CID-4ea99936a163.",
        "cvss": "5.5",
        "publish_date": "December 12, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "NONE",
        "UI": "REQUIRED",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a",
        "commit_message": "ext4: add more paranoia checking in ext4_expand_extra_isize handling\n\nIt's possible to specify a non-zero s_want_extra_isize via debugging\noption, and this can cause bad things(tm) to happen when using a file\nsystem with an inode size of 128 bytes.\n\nAdd better checking when the file system is mounted, as well as when\nwe are actually doing the trying to do the inode expansion.\n\nLink: https://lore.kernel.org/r/20191110121510.GH23325@mit.edu\nReported-by: syzbot+f8d6f8386ceacdbfff57@syzkaller.appspotmail.com\nReported-by: syzbot+33d7ea72e47de3bdf4e1@syzkaller.appspotmail.com\nReported-by: syzbot+44b6763edfc17144296f@syzkaller.appspotmail.com\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>\nCc: stable@kernel.org",
        "commit_date": "2019-11-19T17:24:55Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a",
        "html_url": "https://github.com/torvalds/linux/commit/4ea99936a1630f51fc3a2d61a58ec4a1c4b7d55a",
        "parents": [
            {
                "commit_id_before": "8d0d47ea1640b23678306c007ccc813b5b930af4",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/8d0d47ea1640b23678306c007ccc813b5b930af4",
                "html_url_before": "https://github.com/torvalds/linux/commit/8d0d47ea1640b23678306c007ccc813b5b930af4"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 4208,
        "cve_id": "CVE-2019-19807",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "In the Linux kernel before 5.3.11, sound/core/timer.c has a use-after-free caused by erroneous code refactoring, aka CID-e7af6307a8a5. This is related to snd_timer_open and snd_timer_close_locked. The timeri variable was originally intended to be for a newly created timer instance, but was used for a different purpose after refactoring.",
        "cvss": "7.8",
        "publish_date": "December 15, 2019",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "e7af6307a8a54f0b873960b32b6a644f2d0fbd97",
        "commit_message": "ALSA: timer: Fix incorrectly assigned timer instance\n\nThe clean up commit 41672c0c24a6 (\"ALSA: timer: Simplify error path in\nsnd_timer_open()\") unified the error handling code paths with the\nstandard goto, but it introduced a subtle bug: the timer instance is\nstored in snd_timer_open() incorrectly even if it returns an error.\nThis may eventually lead to UAF, as spotted by fuzzer.\n\nThe culprit is the snd_timer_open() code checks the\nSNDRV_TIMER_IFLG_EXCLUSIVE flag with the common variable timeri.\nThis variable is supposed to be the newly created instance, but we\n(ab-)used it for a temporary check before the actual creation of a\ntimer instance.  After that point, there is another check for the max\nnumber of instances, and it bails out if over the threshold.  Before\nthe refactoring above, it worked fine because the code returned\ndirectly from that point.  After the refactoring, however, it jumps to\nthe unified error path that stores the timeri variable in return --\neven if it returns an error.  Unfortunately this stored value is kept\nin the caller side (snd_timer_user_tselect()) in tu->timeri.  This\ncauses inconsistency later, as if the timer was successfully\nassigned.\n\nIn this patch, we fix it by not re-using timeri variable but a\ntemporary variable for testing the exclusive connection, so timeri\nremains NULL at that point.\n\nFixes: 41672c0c24a6 (\"ALSA: timer: Simplify error path in snd_timer_open()\")\nReported-and-tested-by: Tristan Madani <tristmd@gmail.com>\nCc: <stable@vger.kernel.org>\nLink: https://lore.kernel.org/r/20191106165547.23518-1-tiwai@suse.de\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2019-11-06T16:58:28Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/e7af6307a8a54f0b873960b32b6a644f2d0fbd97",
        "html_url": "https://github.com/torvalds/linux/commit/e7af6307a8a54f0b873960b32b6a644f2d0fbd97",
        "parents": [
            {
                "commit_id_before": "9a11ba7388f165762549903492fc34d29bbb3c04",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/9a11ba7388f165762549903492fc34d29bbb3c04",
                "html_url_before": "https://github.com/torvalds/linux/commit/9a11ba7388f165762549903492fc34d29bbb3c04"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3335,
        "cve_id": "CVE-2019-6974",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "In the Linux kernel before 4.20.8, kvm_ioctl_create_device in virt/kvm/kvm_main.c mishandles reference counting because of a race condition, leading to a use-after-free.",
        "cvss": "8.1",
        "publish_date": "February 15, 2019",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "cfa39381173d5f969daf43582c95ad679189cbc9",
        "commit_message": "kvm: fix kvm_ioctl_create_device() reference counting (CVE-2019-6974)\n\nkvm_ioctl_create_device() does the following:\n\n1. creates a device that holds a reference to the VM object (with a borrowed\n   reference, the VM's refcount has not been bumped yet)\n2. initializes the device\n3. transfers the reference to the device to the caller's file descriptor table\n4. calls kvm_get_kvm() to turn the borrowed reference to the VM into a real\n   reference\n\nThe ownership transfer in step 3 must not happen before the reference to the VM\nbecomes a proper, non-borrowed reference, which only happens in step 4.\nAfter step 3, an attacker can close the file descriptor and drop the borrowed\nreference, which can cause the refcount of the kvm object to drop to zero.\n\nThis means that we need to grab a reference for the device before\nanon_inode_getfd(), otherwise the VM can disappear from under us.\n\nFixes: 852b6d57dc7f (\"kvm: add device control API\")\nCc: stable@kernel.org\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Paolo Bonzini <pbonzini@redhat.com>",
        "commit_date": "2019-02-07T18:02:38Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/cfa39381173d5f969daf43582c95ad679189cbc9",
        "html_url": "https://github.com/torvalds/linux/commit/cfa39381173d5f969daf43582c95ad679189cbc9",
        "parents": [
            {
                "commit_id_before": "8834f5600cf3c8db365e18a3d5cac2c2780c81e5",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/8834f5600cf3c8db365e18a3d5cac2c2780c81e5",
                "html_url_before": "https://github.com/torvalds/linux/commit/8834f5600cf3c8db365e18a3d5cac2c2780c81e5"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 3315,
        "cve_id": "CVE-2019-9003",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "In the Linux kernel before 4.20.5, attackers can trigger a drivers/char/ipmi/ipmi_msghandler.c use-after-free and OOPS by arranging for certain simultaneous execution of the code, as demonstrated by a \"service ipmievd restart\" loop.",
        "cvss": "7.5",
        "publish_date": "February 22, 2019",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "77f8269606bf95fcb232ee86f6da80886f1dfae8",
        "commit_message": "ipmi: fix use-after-free of user->release_barrier.rda\n\nWhen we do the following test, we got oops in ipmi_msghandler driver\nwhile((1))\ndo\n\tservice ipmievd restart & service ipmievd restart\ndone\n\n---------------------------------------------------------------\n[  294.230186] Unable to handle kernel paging request at virtual address 0000803fea6ea008\n[  294.230188] Mem abort info:\n[  294.230190]   ESR = 0x96000004\n[  294.230191]   Exception class = DABT (current EL), IL = 32 bits\n[  294.230193]   SET = 0, FnV = 0\n[  294.230194]   EA = 0, S1PTW = 0\n[  294.230195] Data abort info:\n[  294.230196]   ISV = 0, ISS = 0x00000004\n[  294.230197]   CM = 0, WnR = 0\n[  294.230199] user pgtable: 4k pages, 48-bit VAs, pgdp = 00000000a1c1b75a\n[  294.230201] [0000803fea6ea008] pgd=0000000000000000\n[  294.230204] Internal error: Oops: 96000004 [#1] SMP\n[  294.235211] Modules linked in: nls_utf8 isofs rpcrdma ib_iser ib_srpt target_core_mod ib_srp scsi_transport_srp ib_ipoib rdma_ucm ib_umad rdma_cm ib_cm iw_cm dm_mirror dm_region_hash dm_log dm_mod aes_ce_blk crypto_simd cryptd aes_ce_cipher ghash_ce sha2_ce ses sha256_arm64 sha1_ce hibmc_drm hisi_sas_v2_hw enclosure sg hisi_sas_main sbsa_gwdt ip_tables mlx5_ib ib_uverbs marvell ib_core mlx5_core ixgbe ipmi_si mdio hns_dsaf ipmi_devintf ipmi_msghandler hns_enet_drv hns_mdio\n[  294.277745] CPU: 3 PID: 0 Comm: swapper/3 Kdump: loaded Not tainted 5.0.0-rc2+ #113\n[  294.285511] Hardware name: Huawei TaiShan 2280 /BC11SPCD, BIOS 1.37 11/21/2017\n[  294.292835] pstate: 80000005 (Nzcv daif -PAN -UAO)\n[  294.297695] pc : __srcu_read_lock+0x38/0x58\n[  294.301940] lr : acquire_ipmi_user+0x2c/0x70 [ipmi_msghandler]\n[  294.307853] sp : ffff00001001bc80\n[  294.311208] x29: ffff00001001bc80 x28: ffff0000117e5000\n[  294.316594] x27: 0000000000000000 x26: dead000000000100\n[  294.321980] x25: dead000000000200 x24: ffff803f6bd06800\n[  294.327366] x23: 0000000000000000 x22: 0000000000000000\n[  294.332752] x21: ffff00001001bd04 x20: ffff80df33d19018\n[  294.338137] x19: ffff80df33d19018 x18: 0000000000000000\n[  294.343523] x17: 0000000000000000 x16: 0000000000000000\n[  294.348908] x15: 0000000000000000 x14: 0000000000000002\n[  294.354293] x13: 0000000000000000 x12: 0000000000000000\n[  294.359679] x11: 0000000000000000 x10: 0000000000100000\n[  294.365065] x9 : 0000000000000000 x8 : 0000000000000004\n[  294.370451] x7 : 0000000000000000 x6 : ffff80df34558678\n[  294.375836] x5 : 000000000000000c x4 : 0000000000000000\n[  294.381221] x3 : 0000000000000001 x2 : 0000803fea6ea000\n[  294.386607] x1 : 0000803fea6ea008 x0 : 0000000000000001\n[  294.391994] Process swapper/3 (pid: 0, stack limit = 0x0000000083087293)\n[  294.398791] Call trace:\n[  294.401266]  __srcu_read_lock+0x38/0x58\n[  294.405154]  acquire_ipmi_user+0x2c/0x70 [ipmi_msghandler]\n[  294.410716]  deliver_response+0x80/0xf8 [ipmi_msghandler]\n[  294.416189]  deliver_local_response+0x28/0x68 [ipmi_msghandler]\n[  294.422193]  handle_one_recv_msg+0x158/0xcf8 [ipmi_msghandler]\n[  294.432050]  handle_new_recv_msgs+0xc0/0x210 [ipmi_msghandler]\n[  294.441984]  smi_recv_tasklet+0x8c/0x158 [ipmi_msghandler]\n[  294.451618]  tasklet_action_common.isra.5+0x88/0x138\n[  294.460661]  tasklet_action+0x2c/0x38\n[  294.468191]  __do_softirq+0x120/0x2f8\n[  294.475561]  irq_exit+0x134/0x140\n[  294.482445]  __handle_domain_irq+0x6c/0xc0\n[  294.489954]  gic_handle_irq+0xb8/0x178\n[  294.497037]  el1_irq+0xb0/0x140\n[  294.503381]  arch_cpu_idle+0x34/0x1a8\n[  294.510096]  do_idle+0x1d4/0x290\n[  294.516322]  cpu_startup_entry+0x28/0x30\n[  294.523230]  secondary_start_kernel+0x184/0x1d0\n[  294.530657] Code: d538d082 d2800023 8b010c81 8b020021 (c85f7c25)\n[  294.539746] ---[ end trace 8a7a880dee570b29 ]---\n[  294.547341] Kernel panic - not syncing: Fatal exception in interrupt\n[  294.556837] SMP: stopping secondary CPUs\n[  294.563996] Kernel Offset: disabled\n[  294.570515] CPU features: 0x002,21006008\n[  294.577638] Memory Limit: none\n[  294.587178] Starting crashdump kernel...\n[  294.594314] Bye!\n\nBecause the user->release_barrier.rda is freed in ipmi_destroy_user(), but\nthe refcount is not zero, when acquire_ipmi_user() uses user->release_barrier.rda\nin __srcu_read_lock(), it causes oops.\nFix this by calling cleanup_srcu_struct() when the refcount is zero.\n\nFixes: e86ee2d44b44 (\"ipmi: Rework locking and shutdown for hot remove\")\nCc: stable@vger.kernel.org # 4.18\nSigned-off-by: Yang Yingliang <yangyingliang@huawei.com>\n\nSigned-off-by: Corey Minyard <cminyard@mvista.com>",
        "commit_date": "2019-01-23T16:44:23Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/77f8269606bf95fcb232ee86f6da80886f1dfae8",
        "html_url": "https://github.com/torvalds/linux/commit/77f8269606bf95fcb232ee86f6da80886f1dfae8",
        "parents": [
            {
                "commit_id_before": "479d6b39b9e0d2de648ebf146f23a1e40962068f",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/479d6b39b9e0d2de648ebf146f23a1e40962068f",
                "html_url_before": "https://github.com/torvalds/linux/commit/479d6b39b9e0d2de648ebf146f23a1e40962068f"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 4498,
        "cve_id": "CVE-2020-12464",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "usb_sg_cancel in drivers/usb/core/message.c in the Linux kernel before 5.6.8 has a use-after-free because a transfer occurs without a reference, aka CID-056ad39ee925.",
        "cvss": "6.7",
        "publish_date": "April 29, 2020",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "HIGH",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "056ad39ee9253873522f6469c3364964a322912b",
        "commit_message": "USB: core: Fix free-while-in-use bug in the USB S-Glibrary\n\nFuzzUSB (a variant of syzkaller) found a free-while-still-in-use bug\nin the USB scatter-gather library:\n\nBUG: KASAN: use-after-free in atomic_read\ninclude/asm-generic/atomic-instrumented.h:26 [inline]\nBUG: KASAN: use-after-free in usb_hcd_unlink_urb+0x5f/0x170\ndrivers/usb/core/hcd.c:1607\nRead of size 4 at addr ffff888065379610 by task kworker/u4:1/27\n\nCPU: 1 PID: 27 Comm: kworker/u4:1 Not tainted 5.5.11 #2\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS\n1.10.2-1ubuntu1 04/01/2014\nWorkqueue: scsi_tmf_2 scmd_eh_abort_handler\nCall Trace:\n __dump_stack lib/dump_stack.c:77 [inline]\n dump_stack+0xce/0x128 lib/dump_stack.c:118\n print_address_description.constprop.4+0x21/0x3c0 mm/kasan/report.c:374\n __kasan_report+0x153/0x1cb mm/kasan/report.c:506\n kasan_report+0x12/0x20 mm/kasan/common.c:639\n check_memory_region_inline mm/kasan/generic.c:185 [inline]\n check_memory_region+0x152/0x1b0 mm/kasan/generic.c:192\n __kasan_check_read+0x11/0x20 mm/kasan/common.c:95\n atomic_read include/asm-generic/atomic-instrumented.h:26 [inline]\n usb_hcd_unlink_urb+0x5f/0x170 drivers/usb/core/hcd.c:1607\n usb_unlink_urb+0x72/0xb0 drivers/usb/core/urb.c:657\n usb_sg_cancel+0x14e/0x290 drivers/usb/core/message.c:602\n usb_stor_stop_transport+0x5e/0xa0 drivers/usb/storage/transport.c:937\n\nThis bug occurs when cancellation of the S-G transfer races with\ntransfer completion.  When that happens, usb_sg_cancel() may continue\nto access the transfer's URBs after usb_sg_wait() has freed them.\n\nThe bug is caused by the fact that usb_sg_cancel() does not take any\nsort of reference to the transfer, and so there is nothing to prevent\nthe URBs from being deallocated while the routine is trying to use\nthem.  The fix is to take such a reference by incrementing the\ntransfer's io->count field while the cancellation is in progres and\ndecrementing it afterward.  The transfer's URBs are not deallocated\nuntil io->complete is triggered, which happens when io->count reaches\nzero.\n\nSigned-off-by: Alan Stern <stern@rowland.harvard.edu>\nReported-and-tested-by: Kyungtae Kim <kt0755@gmail.com>\nCC: <stable@vger.kernel.org>\n\nLink: https://lore.kernel.org/r/Pine.LNX.4.44L0.2003281615140.14837-100000@netrider.rowland.org\nSigned-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>",
        "commit_date": "2020-04-16T12:46:00Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/056ad39ee9253873522f6469c3364964a322912b",
        "html_url": "https://github.com/torvalds/linux/commit/056ad39ee9253873522f6469c3364964a322912b",
        "parents": [
            {
                "commit_id_before": "8f3d9f354286745c751374f5f1fcafee6b3f3136",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/8f3d9f354286745c751374f5f1fcafee6b3f3136",
                "html_url_before": "https://github.com/torvalds/linux/commit/8f3d9f354286745c751374f5f1fcafee6b3f3136"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 4729,
        "cve_id": "CVE-2020-12657",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 5.6.5. There is a use-after-free in block/bfq-iosched.c related to bfq_idle_slice_timer_body.",
        "cvss": "7.8",
        "publish_date": "June 13, 2020",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9",
        "commit_message": "block, bfq: fix use-after-free in bfq_idle_slice_timer_body\n\nIn bfq_idle_slice_timer func, bfqq = bfqd->in_service_queue is\nnot in bfqd-lock critical section. The bfqq, which is not\nequal to NULL in bfq_idle_slice_timer, may be freed after passing\nto bfq_idle_slice_timer_body. So we will access the freed memory.\n\nIn addition, considering the bfqq may be in race, we should\nfirstly check whether bfqq is in service before doing something\non it in bfq_idle_slice_timer_body func. If the bfqq in race is\nnot in service, it means the bfqq has been expired through\n__bfq_bfqq_expire func, and wait_request flags has been cleared in\n__bfq_bfqd_reset_in_service func. So we do not need to re-clear the\nwait_request of bfqq which is not in service.\n\nKASAN log is given as follows:\n[13058.354613] ==================================================================\n[13058.354640] BUG: KASAN: use-after-free in bfq_idle_slice_timer+0xac/0x290\n[13058.354644] Read of size 8 at addr ffffa02cf3e63f78 by task fork13/19767\n[13058.354646]\n[13058.354655] CPU: 96 PID: 19767 Comm: fork13\n[13058.354661] Call trace:\n[13058.354667]  dump_backtrace+0x0/0x310\n[13058.354672]  show_stack+0x28/0x38\n[13058.354681]  dump_stack+0xd8/0x108\n[13058.354687]  print_address_description+0x68/0x2d0\n[13058.354690]  kasan_report+0x124/0x2e0\n[13058.354697]  __asan_load8+0x88/0xb0\n[13058.354702]  bfq_idle_slice_timer+0xac/0x290\n[13058.354707]  __hrtimer_run_queues+0x298/0x8b8\n[13058.354710]  hrtimer_interrupt+0x1b8/0x678\n[13058.354716]  arch_timer_handler_phys+0x4c/0x78\n[13058.354722]  handle_percpu_devid_irq+0xf0/0x558\n[13058.354731]  generic_handle_irq+0x50/0x70\n[13058.354735]  __handle_domain_irq+0x94/0x110\n[13058.354739]  gic_handle_irq+0x8c/0x1b0\n[13058.354742]  el1_irq+0xb8/0x140\n[13058.354748]  do_wp_page+0x260/0xe28\n[13058.354752]  __handle_mm_fault+0x8ec/0x9b0\n[13058.354756]  handle_mm_fault+0x280/0x460\n[13058.354762]  do_page_fault+0x3ec/0x890\n[13058.354765]  do_mem_abort+0xc0/0x1b0\n[13058.354768]  el0_da+0x24/0x28\n[13058.354770]\n[13058.354773] Allocated by task 19731:\n[13058.354780]  kasan_kmalloc+0xe0/0x190\n[13058.354784]  kasan_slab_alloc+0x14/0x20\n[13058.354788]  kmem_cache_alloc_node+0x130/0x440\n[13058.354793]  bfq_get_queue+0x138/0x858\n[13058.354797]  bfq_get_bfqq_handle_split+0xd4/0x328\n[13058.354801]  bfq_init_rq+0x1f4/0x1180\n[13058.354806]  bfq_insert_requests+0x264/0x1c98\n[13058.354811]  blk_mq_sched_insert_requests+0x1c4/0x488\n[13058.354818]  blk_mq_flush_plug_list+0x2d4/0x6e0\n[13058.354826]  blk_flush_plug_list+0x230/0x548\n[13058.354830]  blk_finish_plug+0x60/0x80\n[13058.354838]  read_pages+0xec/0x2c0\n[13058.354842]  __do_page_cache_readahead+0x374/0x438\n[13058.354846]  ondemand_readahead+0x24c/0x6b0\n[13058.354851]  page_cache_sync_readahead+0x17c/0x2f8\n[13058.354858]  generic_file_buffered_read+0x588/0xc58\n[13058.354862]  generic_file_read_iter+0x1b4/0x278\n[13058.354965]  ext4_file_read_iter+0xa8/0x1d8 [ext4]\n[13058.354972]  __vfs_read+0x238/0x320\n[13058.354976]  vfs_read+0xbc/0x1c0\n[13058.354980]  ksys_read+0xdc/0x1b8\n[13058.354984]  __arm64_sys_read+0x50/0x60\n[13058.354990]  el0_svc_common+0xb4/0x1d8\n[13058.354994]  el0_svc_handler+0x50/0xa8\n[13058.354998]  el0_svc+0x8/0xc\n[13058.354999]\n[13058.355001] Freed by task 19731:\n[13058.355007]  __kasan_slab_free+0x120/0x228\n[13058.355010]  kasan_slab_free+0x10/0x18\n[13058.355014]  kmem_cache_free+0x288/0x3f0\n[13058.355018]  bfq_put_queue+0x134/0x208\n[13058.355022]  bfq_exit_icq_bfqq+0x164/0x348\n[13058.355026]  bfq_exit_icq+0x28/0x40\n[13058.355030]  ioc_exit_icq+0xa0/0x150\n[13058.355035]  put_io_context_active+0x250/0x438\n[13058.355038]  exit_io_context+0xd0/0x138\n[13058.355045]  do_exit+0x734/0xc58\n[13058.355050]  do_group_exit+0x78/0x220\n[13058.355054]  __wake_up_parent+0x0/0x50\n[13058.355058]  el0_svc_common+0xb4/0x1d8\n[13058.355062]  el0_svc_handler+0x50/0xa8\n[13058.355066]  el0_svc+0x8/0xc\n[13058.355067]\n[13058.355071] The buggy address belongs to the object at ffffa02cf3e63e70#012 which belongs to the cache bfq_queue of size 464\n[13058.355075] The buggy address is located 264 bytes inside of#012 464-byte region [ffffa02cf3e63e70, ffffa02cf3e64040)\n[13058.355077] The buggy address belongs to the page:\n[13058.355083] page:ffff7e80b3cf9800 count:1 mapcount:0 mapping:ffff802db5c90780 index:0xffffa02cf3e606f0 compound_mapcount: 0\n[13058.366175] flags: 0x2ffffe0000008100(slab|head)\n[13058.370781] raw: 2ffffe0000008100 ffff7e80b53b1408 ffffa02d730c1c90 ffff802db5c90780\n[13058.370787] raw: ffffa02cf3e606f0 0000000000370023 00000001ffffffff 0000000000000000\n[13058.370789] page dumped because: kasan: bad access detected\n[13058.370791]\n[13058.370792] Memory state around the buggy address:\n[13058.370797]  ffffa02cf3e63e00: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fb fb\n[13058.370801]  ffffa02cf3e63e80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[13058.370805] >ffffa02cf3e63f00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[13058.370808]                                                                 ^\n[13058.370811]  ffffa02cf3e63f80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n[13058.370815]  ffffa02cf3e64000: fb fb fb fb fb fb fb fb fc fc fc fc fc fc fc fc\n[13058.370817] ==================================================================\n[13058.370820] Disabling lock debugging due to kernel taint\n\nHere, we directly pass the bfqd to bfq_idle_slice_timer_body func.\n--\nV2->V3: rewrite the comment as suggested by Paolo Valente\nV1->V2: add one comment, and add Fixes and Reported-by tag.\n\nFixes: aee69d78d (\"block, bfq: introduce the BFQ-v0 I/O scheduler as an extra scheduler\")\nAcked-by: Paolo Valente <paolo.valente@linaro.org>\nReported-by: Wang Wang <wangwang2@huawei.com>\nSigned-off-by: Zhiqiang Liu <liuzhiqiang26@huawei.com>\nSigned-off-by: Feilong Lin <linfeilong@huawei.com>\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "commit_date": "2020-03-21T20:29:44Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9",
        "html_url": "https://github.com/torvalds/linux/commit/2f95fa5c955d0a9987ffdc3a095e2f4e62c5f2a9",
        "parents": [
            {
                "commit_id_before": "78317c5d58e625e60d1eaded37283d14dfcd1489",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/78317c5d58e625e60d1eaded37283d14dfcd1489",
                "html_url_before": "https://github.com/torvalds/linux/commit/78317c5d58e625e60d1eaded37283d14dfcd1489"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 5853,
        "cve_id": "CVE-2020-25669",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A vulnerability was found in the Linux Kernel where the function sunkbd_reinit having been scheduled by sunkbd_interrupt before sunkbd being freed. Though the dangling pointer is set to NULL in sunkbd_disconnect, there is still an alias in sunkbd_reinit causing Use After Free.",
        "cvss": "7.8",
        "publish_date": "May 26, 2021",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "77e70d351db7de07a46ac49b87a6c3c7a60fca7e",
        "commit_message": "Input: sunkbd - avoid use-after-free in teardown paths\n\nWe need to make sure we cancel the reinit work before we tear down the\ndriver structures.\n\nReported-by: Bodong Zhao <nopitydays@gmail.com>\nTested-by: Bodong Zhao <nopitydays@gmail.com>\nCc: stable@vger.kernel.org\nSigned-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>",
        "commit_date": "2020-11-09T05:59:07Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/77e70d351db7de07a46ac49b87a6c3c7a60fca7e",
        "html_url": "https://github.com/torvalds/linux/commit/77e70d351db7de07a46ac49b87a6c3c7a60fca7e",
        "parents": [
            {
                "commit_id_before": "b1884583fcd17d6a1b1bba94bbb5826e6b5c6e17",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/b1884583fcd17d6a1b1bba94bbb5826e6b5c6e17",
                "html_url_before": "https://github.com/torvalds/linux/commit/b1884583fcd17d6a1b1bba94bbb5826e6b5c6e17"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 5018,
        "cve_id": "CVE-2020-27675",
        "cwe_id": [
            "CWE-476",
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel through 5.9.1, as used with Xen through 4.14.x. drivers/xen/events/events_base.c allows event-channel removal during the event-handling loop (a race condition). This can cause a use-after-free or NULL pointer dereference, as demonstrated by a dom0 crash via events for an in-reconfiguration paravirtualized device, aka CID-073d0552ead5.",
        "cvss": "4.7",
        "publish_date": "October 22, 2020",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "073d0552ead5bfc7a3a9c01de590e924f11b5dd2",
        "commit_message": "xen/events: avoid removing an event channel while handling it\n\nToday it can happen that an event channel is being removed from the\nsystem while the event handling loop is active. This can lead to a\nrace resulting in crashes or WARN() splats when trying to access the\nirq_info structure related to the event channel.\n\nFix this problem by using a rwlock taken as reader in the event\nhandling loop and as writer when deallocating the irq_info structure.\n\nAs the observed problem was a NULL dereference in evtchn_from_irq()\nmake this function more robust against races by testing the irq_info\npointer to be not NULL before dereferencing it.\n\nAnd finally make all accesses to evtchn_to_irq[row][col] atomic ones\nin order to avoid seeing partial updates of an array element in irq\nhandling. Note that irq handling can be entered only for event channels\nwhich have been valid before, so any not populated row isn't a problem\nin this regard, as rows are only ever added and never removed.\n\nThis is XSA-331.\n\nCc: stable@vger.kernel.org\nReported-by: Marek Marczykowski-G\u00f3recki <marmarek@invisiblethingslab.com>\nReported-by: Jinoh Kang <luke1337@theori.io>\nSigned-off-by: Juergen Gross <jgross@suse.com>\nReviewed-by: Stefano Stabellini <sstabellini@kernel.org>\nReviewed-by: Wei Liu <wl@xen.org>",
        "commit_date": "2020-10-20T08:21:51Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/073d0552ead5bfc7a3a9c01de590e924f11b5dd2",
        "html_url": "https://github.com/torvalds/linux/commit/073d0552ead5bfc7a3a9c01de590e924f11b5dd2",
        "parents": [
            {
                "commit_id_before": "32118f97f41d26a2447118fa956715cb4bd1bdac",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/32118f97f41d26a2447118fa956715cb4bd1bdac",
                "html_url_before": "https://github.com/torvalds/linux/commit/32118f97f41d26a2447118fa956715cb4bd1bdac"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 4738,
        "cve_id": "CVE-2020-8428",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "fs/namei.c in the Linux kernel before 5.5 has a may_create_in_sticky use-after-free, which allows local users to cause a denial of service (OOPS) or possibly obtain sensitive information from kernel memory, aka CID-d0cb50185ae9. One attack vector may be an open system call for a UNIX domain socket, if the socket is being moved to a new parent directory and its old parent directory is being removed.",
        "cvss": "7.1",
        "publish_date": "June 10, 2020",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "d0cb50185ae942b03c4327be322055d622dc79f6",
        "commit_message": "do_last(): fetch directory ->i_mode and ->i_uid before it's too late\n\nmay_create_in_sticky() call is done when we already have dropped the\nreference to dir.\n\nFixes: 30aba6656f61e (namei: allow restricted O_CREAT of FIFOs and regular files)\nSigned-off-by: Al Viro <viro@zeniv.linux.org.uk>",
        "commit_date": "2020-01-26T14:31:07Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/d0cb50185ae942b03c4327be322055d622dc79f6",
        "html_url": "https://github.com/torvalds/linux/commit/d0cb50185ae942b03c4327be322055d622dc79f6",
        "parents": [
            {
                "commit_id_before": "508c8772760d4ef9c1a044519b564710c3684fc5",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/508c8772760d4ef9c1a044519b564710c3684fc5",
                "html_url_before": "https://github.com/torvalds/linux/commit/508c8772760d4ef9c1a044519b564710c3684fc5"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 8672,
        "cve_id": "CVE-2022-1199",
        "cwe_id": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",
        "cvss": "7.5",
        "publish_date": "August 29, 2022",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10",
        "commit_message": "ax25: fix NPD bug in ax25_disconnect\n\nThe ax25_disconnect() in ax25_kill_by_device() is not\nprotected by any locks, thus there is a race condition\nbetween ax25_disconnect() and ax25_destroy_socket().\nwhen ax25->sk is assigned as NULL by ax25_destroy_socket(),\na NULL pointer dereference bug will occur if site (1) or (2)\ndereferences ax25->sk.\n\nax25_kill_by_device()                | ax25_release()\n  ax25_disconnect()                  |   ax25_destroy_socket()\n    ...                              |\n    if(ax25->sk != NULL)             |     ...\n      ...                            |     ax25->sk = NULL;\n      bh_lock_sock(ax25->sk); //(1)  |     ...\n      ...                            |\n      bh_unlock_sock(ax25->sk); //(2)|\n\nThis patch moves ax25_disconnect() into lock_sock(), which can\nsynchronize with ax25_destroy_socket() in ax25_release().\n\nFail log:\n===============================================================\nBUG: kernel NULL pointer dereference, address: 0000000000000088\n...\nRIP: 0010:_raw_spin_lock+0x7e/0xd0\n...\nCall Trace:\nax25_disconnect+0xf6/0x220\nax25_device_event+0x187/0x250\nraw_notifier_call_chain+0x5e/0x70\ndev_close_many+0x17d/0x230\nrollback_registered_many+0x1f1/0x950\nunregister_netdevice_queue+0x133/0x200\nunregister_netdev+0x13/0x20\n...\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2022-02-09T11:55:02Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10",
        "html_url": "https://github.com/torvalds/linux/commit/7ec02f5ac8a5be5a3f20611731243dc5e1d9ba10",
        "parents": [
            {
                "commit_id_before": "676b49366a70ea91997585ba8e4577290f5172a5",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/676b49366a70ea91997585ba8e4577290f5172a5",
                "html_url_before": "https://github.com/torvalds/linux/commit/676b49366a70ea91997585ba8e4577290f5172a5"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 8673,
        "cve_id": "CVE-2022-1199",
        "cwe_id": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",
        "cvss": "7.5",
        "publish_date": "August 29, 2022",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac",
        "commit_message": "ax25: Fix NULL pointer dereference in ax25_kill_by_device\n\nWhen two ax25 devices attempted to establish connection, the requester use ax25_create(),\nax25_bind() and ax25_connect() to initiate connection. The receiver use ax25_rcv() to\naccept connection and use ax25_create_cb() in ax25_rcv() to create ax25_cb, but the\nax25_cb->sk is NULL. When the receiver is detaching, a NULL pointer dereference bug\ncaused by sock_hold(sk) in ax25_kill_by_device() will happen. The corresponding\nfail log is shown below:\n\n===============================================================\nBUG: KASAN: null-ptr-deref in ax25_device_event+0xfd/0x290\nCall Trace:\n...\nax25_device_event+0xfd/0x290\nraw_notifier_call_chain+0x5e/0x70\ndev_close_many+0x174/0x220\nunregister_netdevice_many+0x1f7/0xa60\nunregister_netdevice_queue+0x12f/0x170\nunregister_netdev+0x13/0x20\nmkiss_close+0xcd/0x140\ntty_ldisc_release+0xc0/0x220\ntty_release_struct+0x17/0xa0\ntty_release+0x62d/0x670\n...\n\nThis patch add condition check in ax25_kill_by_device(). If s->sk is\nNULL, it will goto if branch to kill device.\n\nFixes: 4e0f718daf97 (\"ax25: improve the incomplete fix to avoid UAF and NPD bugs\")\nReported-by: Thomas Osterried <thomas@osterried.de>\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2022-03-09T12:45:02Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac",
        "html_url": "https://github.com/torvalds/linux/commit/71171ac8eb34ce7fe6b3267dce27c313ab3cb3ac",
        "parents": [
            {
                "commit_id_before": "c9ffa3e2bc451816ce0295e40063514fabf2bd36",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c9ffa3e2bc451816ce0295e40063514fabf2bd36",
                "html_url_before": "https://github.com/torvalds/linux/commit/c9ffa3e2bc451816ce0295e40063514fabf2bd36"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 8674,
        "cve_id": "CVE-2022-1199",
        "cwe_id": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the Linux kernel. This flaw allows an attacker to crash the Linux kernel by simulating amateur radio from the user space, resulting in a null-ptr-deref vulnerability and a use-after-free vulnerability.",
        "cvss": "7.5",
        "publish_date": "August 29, 2022",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "4e0f718daf97d47cf7dec122da1be970f145c809",
        "commit_message": "ax25: improve the incomplete fix to avoid UAF and NPD bugs\n\nThe previous commit 1ade48d0c27d (\"ax25: NPD bug when detaching\nAX25 device\") introduce lock_sock() into ax25_kill_by_device to\nprevent NPD bug. But the concurrency NPD or UAF bug will occur,\nwhen lock_sock() or release_sock() dereferences the ax25_cb->sock.\n\nThe NULL pointer dereference bug can be shown as below:\n\nax25_kill_by_device()        | ax25_release()\n                             |   ax25_destroy_socket()\n                             |     ax25_cb_del()\n  ...                        |     ...\n                             |     ax25->sk=NULL;\n  lock_sock(s->sk); //(1)    |\n  s->ax25_dev = NULL;        |     ...\n  release_sock(s->sk); //(2) |\n  ...                        |\n\nThe root cause is that the sock is set to null before dereference\nsite (1) or (2). Therefore, this patch extracts the ax25_cb->sock\nin advance, and uses ax25_list_lock to protect it, which can synchronize\nwith ax25_cb_del() and ensure the value of sock is not null before\ndereference sites.\n\nThe concurrency UAF bug can be shown as below:\n\nax25_kill_by_device()        | ax25_release()\n                             |   ax25_destroy_socket()\n  ...                        |   ...\n                             |   sock_put(sk); //FREE\n  lock_sock(s->sk); //(1)    |\n  s->ax25_dev = NULL;        |   ...\n  release_sock(s->sk); //(2) |\n  ...                        |\n\nThe root cause is that the sock is released before dereference\nsite (1) or (2). Therefore, this patch uses sock_hold() to increase\nthe refcount of sock and uses ax25_list_lock to protect it, which\ncan synchronize with ax25_cb_del() in ax25_destroy_socket() and\nensure the sock wil not be released before dereference sites.\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2022-01-28T14:56:47Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/4e0f718daf97d47cf7dec122da1be970f145c809",
        "html_url": "https://github.com/torvalds/linux/commit/4e0f718daf97d47cf7dec122da1be970f145c809",
        "parents": [
            {
                "commit_id_before": "928d6fe996f69330ded6b887baf4534c5fac7988",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/928d6fe996f69330ded6b887baf4534c5fac7988",
                "html_url_before": "https://github.com/torvalds/linux/commit/928d6fe996f69330ded6b887baf4534c5fac7988"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 8196,
        "cve_id": "CVE-2022-1734",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw in Linux Kernel found in nfcmrvl_nci_unregister_dev() in drivers/nfc/nfcmrvl/main.c can lead to use after free both read or write when non synchronized between cleanup routine and firmware download routine.",
        "cvss": "7.0",
        "publish_date": "May 18, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "d270453a0d9ec10bb8a802a142fb1b3601a83098",
        "commit_message": "nfc: nfcmrvl: main: reorder destructive operations in nfcmrvl_nci_unregister_dev to avoid bugs\n\nThere are destructive operations such as nfcmrvl_fw_dnld_abort and\ngpio_free in nfcmrvl_nci_unregister_dev. The resources such as firmware,\ngpio and so on could be destructed while the upper layer functions such as\nnfcmrvl_fw_dnld_start and nfcmrvl_nci_recv_frame is executing, which leads\nto double-free, use-after-free and null-ptr-deref bugs.\n\nThere are three situations that could lead to double-free bugs.\n\nThe first situation is shown below:\n\n   (Thread 1)                 |      (Thread 2)\nnfcmrvl_fw_dnld_start         |\n ...                          |  nfcmrvl_nci_unregister_dev\n release_firmware()           |   nfcmrvl_fw_dnld_abort\n  kfree(fw) //(1)             |    fw_dnld_over\n                              |     release_firmware\n  ...                         |      kfree(fw) //(2)\n                              |     ...\n\nThe second situation is shown below:\n\n   (Thread 1)                 |      (Thread 2)\nnfcmrvl_fw_dnld_start         |\n ...                          |\n mod_timer                    |\n (wait a time)                |\n fw_dnld_timeout              |  nfcmrvl_nci_unregister_dev\n   fw_dnld_over               |   nfcmrvl_fw_dnld_abort\n    release_firmware          |    fw_dnld_over\n     kfree(fw) //(1)          |     release_firmware\n     ...                      |      kfree(fw) //(2)\n\nThe third situation is shown below:\n\n       (Thread 1)               |       (Thread 2)\nnfcmrvl_nci_recv_frame          |\n if(..->fw_download_in_progress)|\n  nfcmrvl_fw_dnld_recv_frame    |\n   queue_work                   |\n                                |\nfw_dnld_rx_work                 | nfcmrvl_nci_unregister_dev\n fw_dnld_over                   |  nfcmrvl_fw_dnld_abort\n  release_firmware              |   fw_dnld_over\n   kfree(fw) //(1)              |    release_firmware\n                                |     kfree(fw) //(2)\n\nThe firmware struct is deallocated in position (1) and deallocated\nin position (2) again.\n\nThe crash trace triggered by POC is like below:\n\nBUG: KASAN: double-free or invalid-free in fw_dnld_over\nCall Trace:\n  kfree\n  fw_dnld_over\n  nfcmrvl_nci_unregister_dev\n  nci_uart_tty_close\n  tty_ldisc_kill\n  tty_ldisc_hangup\n  __tty_hangup.part.0\n  tty_release\n  ...\n\nWhat's more, there are also use-after-free and null-ptr-deref bugs\nin nfcmrvl_fw_dnld_start. If we deallocate firmware struct, gpio or\nset null to the members of priv->fw_dnld in nfcmrvl_nci_unregister_dev,\nthen, we dereference firmware, gpio or the members of priv->fw_dnld in\nnfcmrvl_fw_dnld_start, the UAF or NPD bugs will happen.\n\nThis patch reorders destructive operations after nci_unregister_device\nin order to synchronize between cleanup routine and firmware download\nroutine.\n\nThe nci_unregister_device is well synchronized. If the device is\ndetaching, the firmware download routine will goto error. If firmware\ndownload routine is executing, nci_unregister_device will wait until\nfirmware download routine is finished.\n\nFixes: 3194c6870158 (\"NFC: nfcmrvl: add firmware download support\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2022-05-01T12:26:05Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/d270453a0d9ec10bb8a802a142fb1b3601a83098",
        "html_url": "https://github.com/torvalds/linux/commit/d270453a0d9ec10bb8a802a142fb1b3601a83098",
        "parents": [
            {
                "commit_id_before": "da5c0f119203ad9728920456a0f52a6d850c01cd",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/da5c0f119203ad9728920456a0f52a6d850c01cd",
                "html_url_before": "https://github.com/torvalds/linux/commit/da5c0f119203ad9728920456a0f52a6d850c01cd"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 8652,
        "cve_id": "CVE-2022-1974",
        "cwe_id": [
            "CWE-416",
            "CWE-367"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in the Linux kernel's NFC core functionality due to a race condition between kobject creation and delete. This vulnerability allows a local attacker with CAP_NET_ADMIN privilege to leak kernel information.",
        "cvss": "4.1",
        "publish_date": "August 31, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "HIGH",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "NONE",
        "commit_id": "da5c0f119203ad9728920456a0f52a6d850c01cd",
        "commit_message": "nfc: replace improper check device_is_registered() in netlink related functions\n\nThe device_is_registered() in nfc core is used to check whether\nnfc device is registered in netlink related functions such as\nnfc_fw_download(), nfc_dev_up() and so on. Although device_is_registered()\nis protected by device_lock, there is still a race condition between\ndevice_del() and device_is_registered(). The root cause is that\nkobject_del() in device_del() is not protected by device_lock.\n\n   (cleanup task)         |     (netlink task)\n                          |\nnfc_unregister_device     | nfc_fw_download\n device_del               |  device_lock\n  ...                     |   if (!device_is_registered)//(1)\n  kobject_del//(2)        |   ...\n ...                      |  device_unlock\n\nThe device_is_registered() returns the value of state_in_sysfs and\nthe state_in_sysfs is set to zero in kobject_del(). If we pass check in\nposition (1), then set zero in position (2). As a result, the check\nin position (1) is useless.\n\nThis patch uses bool variable instead of device_is_registered() to judge\nwhether the nfc device is registered, which is well synchronized.\n\nFixes: 3e256b8f8dfa (\"NFC: add nfc subsystem core\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2022-05-01T12:26:05Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/da5c0f119203ad9728920456a0f52a6d850c01cd",
        "html_url": "https://github.com/torvalds/linux/commit/da5c0f119203ad9728920456a0f52a6d850c01cd",
        "parents": [
            {
                "commit_id_before": "47f753c1108e287edb3e27fad8a7511a9d55578e",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/47f753c1108e287edb3e27fad8a7511a9d55578e",
                "html_url_before": "https://github.com/torvalds/linux/commit/47f753c1108e287edb3e27fad8a7511a9d55578e"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 8609,
        "cve_id": "CVE-2022-2318",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "There are use-after-free vulnerabilities caused by timer handler in net/rose/rose_timer.c of linux that allow attackers to crash linux kernel without any privileges.",
        "cvss": "5.5",
        "publish_date": "July 6, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "9cc02ede696272c5271a401e4f27c262359bc2f6",
        "commit_message": "net: rose: fix UAF bugs caused by timer handler\n\nThere are UAF bugs in rose_heartbeat_expiry(), rose_timer_expiry()\nand rose_idletimer_expiry(). The root cause is that del_timer()\ncould not stop the timer handler that is running and the refcount\nof sock is not managed properly.\n\nOne of the UAF bugs is shown below:\n\n    (thread 1)          |        (thread 2)\n                        |  rose_bind\n                        |  rose_connect\n                        |    rose_start_heartbeat\nrose_release            |    (wait a time)\n  case ROSE_STATE_0     |\n  rose_destroy_socket   |  rose_heartbeat_expiry\n    rose_stop_heartbeat |\n    sock_put(sk)        |    ...\n  sock_put(sk) // FREE  |\n                        |    bh_lock_sock(sk) // USE\n\nThe sock is deallocated by sock_put() in rose_release() and\nthen used by bh_lock_sock() in rose_heartbeat_expiry().\n\nAlthough rose_destroy_socket() calls rose_stop_heartbeat(),\nit could not stop the timer that is running.\n\nThe KASAN report triggered by POC is shown below:\n\nBUG: KASAN: use-after-free in _raw_spin_lock+0x5a/0x110\nWrite of size 4 at addr ffff88800ae59098 by task swapper/3/0\n...\nCall Trace:\n <IRQ>\n dump_stack_lvl+0xbf/0xee\n print_address_description+0x7b/0x440\n print_report+0x101/0x230\n ? irq_work_single+0xbb/0x140\n ? _raw_spin_lock+0x5a/0x110\n kasan_report+0xed/0x120\n ? _raw_spin_lock+0x5a/0x110\n kasan_check_range+0x2bd/0x2e0\n _raw_spin_lock+0x5a/0x110\n rose_heartbeat_expiry+0x39/0x370\n ? rose_start_heartbeat+0xb0/0xb0\n call_timer_fn+0x2d/0x1c0\n ? rose_start_heartbeat+0xb0/0xb0\n expire_timers+0x1f3/0x320\n __run_timers+0x3ff/0x4d0\n run_timer_softirq+0x41/0x80\n __do_softirq+0x233/0x544\n irq_exit_rcu+0x41/0xa0\n sysvec_apic_timer_interrupt+0x8c/0xb0\n </IRQ>\n <TASK>\n asm_sysvec_apic_timer_interrupt+0x1b/0x20\nRIP: 0010:default_idle+0xb/0x10\nRSP: 0018:ffffc9000012fea0 EFLAGS: 00000202\nRAX: 000000000000bcae RBX: ffff888006660f00 RCX: 000000000000bcae\nRDX: 0000000000000001 RSI: ffffffff843a11c0 RDI: ffffffff843a1180\nRBP: dffffc0000000000 R08: dffffc0000000000 R09: ffffed100da36d46\nR10: dfffe9100da36d47 R11: ffffffff83cf0950 R12: 0000000000000000\nR13: 1ffff11000ccc1e0 R14: ffffffff8542af28 R15: dffffc0000000000\n...\nAllocated by task 146:\n __kasan_kmalloc+0xc4/0xf0\n sk_prot_alloc+0xdd/0x1a0\n sk_alloc+0x2d/0x4e0\n rose_create+0x7b/0x330\n __sock_create+0x2dd/0x640\n __sys_socket+0xc7/0x270\n __x64_sys_socket+0x71/0x80\n do_syscall_64+0x43/0x90\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nFreed by task 152:\n kasan_set_track+0x4c/0x70\n kasan_set_free_info+0x1f/0x40\n ____kasan_slab_free+0x124/0x190\n kfree+0xd3/0x270\n __sk_destruct+0x314/0x460\n rose_release+0x2fa/0x3b0\n sock_close+0xcb/0x230\n __fput+0x2d9/0x650\n task_work_run+0xd6/0x160\n exit_to_user_mode_loop+0xc7/0xd0\n exit_to_user_mode_prepare+0x4e/0x80\n syscall_exit_to_user_mode+0x20/0x40\n do_syscall_64+0x4f/0x90\n entry_SYSCALL_64_after_hwframe+0x46/0xb0\n\nThis patch adds refcount of sock when we use functions\nsuch as rose_start_heartbeat() and so on to start timer,\nand decreases the refcount of sock when timer is finished\nor deleted by functions such as rose_stop_heartbeat()\nand so on. As a result, the UAF bugs could be mitigated.\n\nFixes: 1da177e4c3f4 (\"Linux-2.6.12-rc2\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nTested-by: Duoming Zhou <duoming@zju.edu.cn>\nLink: https://lore.kernel.org/r/20220629002640.5693-1-duoming@zju.edu.cn\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
        "commit_date": "2022-06-30T09:07:30Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/9cc02ede696272c5271a401e4f27c262359bc2f6",
        "html_url": "https://github.com/torvalds/linux/commit/9cc02ede696272c5271a401e4f27c262359bc2f6",
        "parents": [
            {
                "commit_id_before": "f8ebb3ac881b17712e1d5967c97ab1806b16d3d6",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f8ebb3ac881b17712e1d5967c97ab1806b16d3d6",
                "html_url_before": "https://github.com/torvalds/linux/commit/f8ebb3ac881b17712e1d5967c97ab1806b16d3d6"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 7025,
        "cve_id": "CVE-2022-24122",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "kernel/ucount.c in the Linux kernel 5.14 through 5.16.4, when unprivileged user namespaces are enabled, allows a use-after-free and privilege escalation because a ucounts object can outlive its namespace.",
        "cvss": "7.8",
        "publish_date": "January 29, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "f9d87929d451d3e649699d0f1d74f71f77ad38f5",
        "commit_message": "ucount:  Make get_ucount a safe get_user replacement\n\nWhen the ucount code was refactored to create get_ucount it was missed\nthat some of the contexts in which a rlimit is kept elevated can be\nthe only reference to the user/ucount in the system.\n\nOrdinary ucount references exist in places that also have a reference\nto the user namspace, but in POSIX message queues, the SysV shm code,\nand the SIGPENDING code there is no independent user namespace\nreference.\n\nInspection of the the user_namespace show no instance of circular\nreferences between struct ucounts and the user_namespace.  So\nhold a reference from struct ucount to i's user_namespace to\nresolve this problem.\n\nLink: https://lore.kernel.org/lkml/YZV7Z+yXbsx9p3JN@fixkernel.com/\nReported-by: Qian Cai <quic_qiancai@quicinc.com>\nReported-by: Mathias Krause <minipli@grsecurity.net>\nTested-by: Mathias Krause <minipli@grsecurity.net>\nReviewed-by: Mathias Krause <minipli@grsecurity.net>\nReviewed-by: Alexey Gladkov <legion@kernel.org>\nFixes: d64696905554 (\"Reimplement RLIMIT_SIGPENDING on top of ucounts\")\nFixes: 6e52a9f0532f (\"Reimplement RLIMIT_MSGQUEUE on top of ucounts\")\nFixes: d7c9e99aee48 (\"Reimplement RLIMIT_MEMLOCK on top of ucounts\")\nCc: stable@vger.kernel.org\nSigned-off-by: \"Eric W. Biederman\" <ebiederm@xmission.com>",
        "commit_date": "2022-01-27T00:34:11Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/f9d87929d451d3e649699d0f1d74f71f77ad38f5",
        "html_url": "https://github.com/torvalds/linux/commit/f9d87929d451d3e649699d0f1d74f71f77ad38f5",
        "parents": [
            {
                "commit_id_before": "e783362eb54cd99b2cac8b3a9aeac942e6f6ac07",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/e783362eb54cd99b2cac8b3a9aeac942e6f6ac07",
                "html_url_before": "https://github.com/torvalds/linux/commit/e783362eb54cd99b2cac8b3a9aeac942e6f6ac07"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 7995,
        "cve_id": "CVE-2022-28796",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "jbd2_journal_wait_updates in fs/jbd2/transaction.c in the Linux kernel before 5.17.1 has a use-after-free caused by a transaction_t race condition.",
        "cvss": "7.0",
        "publish_date": "April 8, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "cc16eecae687912238ee6efbff71ad31e2bc414e",
        "commit_message": "jbd2: fix use-after-free of transaction_t race\n\njbd2_journal_wait_updates() is called with j_state_lock held. But if\nthere is a commit in progress, then this transaction might get committed\nand freed via jbd2_journal_commit_transaction() ->\njbd2_journal_free_transaction(), when we release j_state_lock.\nSo check for journal->j_running_transaction everytime we release and\nacquire j_state_lock to avoid use-after-free issue.\n\nLink: https://lore.kernel.org/r/948c2fed518ae739db6a8f7f83f1d58b504f87d0.1644497105.git.ritesh.list@gmail.com\nFixes: 4f98186848707f53 (\"jbd2: refactor wait logic for transaction updates into a common function\")\nCc: stable@kernel.org\nReported-and-tested-by: syzbot+afa2ca5171d93e44b348@syzkaller.appspotmail.com\nReviewed-by: Jan Kara <jack@suse.cz>\nSigned-off-by: Ritesh Harjani <riteshh@linux.ibm.com>\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
        "commit_date": "2022-02-26T02:28:10Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/cc16eecae687912238ee6efbff71ad31e2bc414e",
        "html_url": "https://github.com/torvalds/linux/commit/cc16eecae687912238ee6efbff71ad31e2bc414e",
        "parents": [
            {
                "commit_id_before": "e3952fcce1aad934f1322843b564ff86256444b2",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/e3952fcce1aad934f1322843b564ff86256444b2",
                "html_url_before": "https://github.com/torvalds/linux/commit/e3952fcce1aad934f1322843b564ff86256444b2"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 9216,
        "cve_id": "CVE-2022-3586",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the Linux kernel\u2019s networking code. A use-after-free was found in the way the sch_sfb enqueue function used the socket buffer (SKB) cb field after the same SKB had been enqueued (and freed) into a child qdisc. This flaw allows a local, unprivileged user to crash the system, causing a denial of service.",
        "cvss": "5.5",
        "publish_date": "October 19, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "9efd23297cca530bb35e1848665805d3fcdd7889",
        "commit_message": "sch_sfb: Don't assume the skb is still around after enqueueing to child\n\nThe sch_sfb enqueue() routine assumes the skb is still alive after it has\nbeen enqueued into a child qdisc, using the data in the skb cb field in the\nincrement_qlen() routine after enqueue. However, the skb may in fact have\nbeen freed, causing a use-after-free in this case. In particular, this\nhappens if sch_cake is used as a child of sfb, and the GSO splitting mode\nof CAKE is enabled (in which case the skb will be split into segments and\nthe original skb freed).\n\nFix this by copying the sfb cb data to the stack before enqueueing the skb,\nand using this stack copy in increment_qlen() instead of the skb pointer\nitself.\n\nReported-by: zdi-disclosures@trendmicro.com # ZDI-CAN-18231\nFixes: e13e02a3c68d (\"net_sched: SFB flow scheduler\")\nSigned-off-by: Toke H\u00f8iland-J\u00f8rgensen <toke@toke.dk>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2022-09-02T11:23:26Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/9efd23297cca530bb35e1848665805d3fcdd7889",
        "html_url": "https://github.com/torvalds/linux/commit/9efd23297cca530bb35e1848665805d3fcdd7889",
        "parents": [
            {
                "commit_id_before": "7fdc77665f3d45c9da7c6edd4beadee9790f43aa",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/7fdc77665f3d45c9da7c6edd4beadee9790f43aa",
                "html_url_before": "https://github.com/torvalds/linux/commit/7fdc77665f3d45c9da7c6edd4beadee9790f43aa"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 9618,
        "cve_id": "CVE-2022-3910",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "Use After Free vulnerability in Linux Kernel allows Privilege Escalation. An improper Update of Reference Count in io_uring leads to Use-After-Free and Local Privilege Escalation. When io_msg_ring was invoked with a fixed file, it called io_fput_file() which improperly decreased its reference count (leading to Use-After-Free and Local Privilege Escalation). Fixed files are permanently registered to the ring, and should not be put separately. We recommend upgrading past commit https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679 https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679",
        "cvss": "7.8",
        "publish_date": "November 22, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "fc7222c3a9f56271fba02aabbfbae999042f1679",
        "commit_message": "io_uring/msg_ring: check file type before putting\n\nIf we're invoked with a fixed file, follow the normal rules of not\ncalling io_fput_file(). Fixed files are permanently registered to the\nring, and do not need putting separately.\n\nCc: stable@vger.kernel.org\nFixes: aa184e8671f0 (\"io_uring: don't attempt to IOPOLL for MSG_RING requests\")\nSigned-off-by: Jens Axboe <axboe@kernel.dk>",
        "commit_date": "2022-09-15T17:44:35Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/fc7222c3a9f56271fba02aabbfbae999042f1679",
        "html_url": "https://github.com/torvalds/linux/commit/fc7222c3a9f56271fba02aabbfbae999042f1679",
        "parents": [
            {
                "commit_id_before": "62bb0647b14646fa6c9aa25ecdf67ad18f13523c",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/62bb0647b14646fa6c9aa25ecdf67ad18f13523c",
                "html_url_before": "https://github.com/torvalds/linux/commit/62bb0647b14646fa6c9aa25ecdf67ad18f13523c"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 9097,
        "cve_id": "CVE-2022-40307",
        "cwe_id": [
            "CWE-362",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel through 5.19.8. drivers/firmware/efi/capsule-loader.c has a race condition with a resultant use-after-free.",
        "cvss": "4.7",
        "publish_date": "September 9, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "9cb636b5f6a8cc6d1b50809ec8f8d33ae0c84c95",
        "commit_message": "efi: capsule-loader: Fix use-after-free in efi_capsule_write\n\nA race condition may occur if the user calls close() on another thread\nduring a write() operation on the device node of the efi capsule.\n\nThis is a race condition that occurs between the efi_capsule_write() and\nefi_capsule_flush() functions of efi_capsule_fops, which ultimately\nresults in UAF.\n\nSo, the page freeing process is modified to be done in\nefi_capsule_release() instead of efi_capsule_flush().\n\nCc: <stable@vger.kernel.org> # v4.9+\nSigned-off-by: Hyunwoo Kim <imv4bel@gmail.com>\nLink: https://lore.kernel.org/all/20220907102920.GA88602@ubuntu/\nSigned-off-by: Ard Biesheuvel <ardb@kernel.org>",
        "commit_date": "2022-09-07T16:23:56Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/9cb636b5f6a8cc6d1b50809ec8f8d33ae0c84c95",
        "html_url": "https://github.com/torvalds/linux/commit/9cb636b5f6a8cc6d1b50809ec8f8d33ae0c84c95",
        "parents": [
            {
                "commit_id_before": "7a1ec84ffba9e90ac772ddb33ea9c3899ed8d2c9",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/7a1ec84ffba9e90ac772ddb33ea9c3899ed8d2c9",
                "html_url_before": "https://github.com/torvalds/linux/commit/7a1ec84ffba9e90ac772ddb33ea9c3899ed8d2c9"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 10285,
        "cve_id": "CVE-2022-41858",
        "cwe_id": [
            "CWE-476",
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the Linux kernel. A NULL pointer dereference may occur while a slip driver is in progress to detach in sl_tx_timeout in drivers/net/slip/slip.c. This issue could allow an attacker to crash the system or leak internal kernel information.",
        "cvss": "7.1",
        "publish_date": "January 17, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "ec4eb8a86ade4d22633e1da2a7d85a846b7d1798",
        "commit_message": "drivers: net: slip: fix NPD bug in sl_tx_timeout()\n\nWhen a slip driver is detaching, the slip_close() will act to\ncleanup necessary resources and sl->tty is set to NULL in\nslip_close(). Meanwhile, the packet we transmit is blocked,\nsl_tx_timeout() will be called. Although slip_close() and\nsl_tx_timeout() use sl->lock to synchronize, we don`t judge\nwhether sl->tty equals to NULL in sl_tx_timeout() and the\nnull pointer dereference bug will happen.\n\n   (Thread 1)                 |      (Thread 2)\n                              | slip_close()\n                              |   spin_lock_bh(&sl->lock)\n                              |   ...\n...                           |   sl->tty = NULL //(1)\nsl_tx_timeout()               |   spin_unlock_bh(&sl->lock)\n  spin_lock(&sl->lock);       |\n  ...                         |   ...\n  tty_chars_in_buffer(sl->tty)|\n    if (tty->ops->..) //(2)   |\n    ...                       |   synchronize_rcu()\n\nWe set NULL to sl->tty in position (1) and dereference sl->tty\nin position (2).\n\nThis patch adds check in sl_tx_timeout(). If sl->tty equals to\nNULL, sl_tx_timeout() will goto out.\n\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nReviewed-by: Jiri Slaby <jirislaby@kernel.org>\nLink: https://lore.kernel.org/r/20220405132206.55291-1-duoming@zju.edu.cn\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
        "commit_date": "2022-04-07T06:00:16Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798",
        "html_url": "https://github.com/torvalds/linux/commit/ec4eb8a86ade4d22633e1da2a7d85a846b7d1798",
        "parents": [
            {
                "commit_id_before": "8e9d0d7a76c556e8b73289555950917db13d2077",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/8e9d0d7a76c556e8b73289555950917db13d2077",
                "html_url_before": "https://github.com/torvalds/linux/commit/8e9d0d7a76c556e8b73289555950917db13d2077"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 9257,
        "cve_id": "CVE-2022-42703",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "mm/rmap.c in the Linux kernel before 5.19.7 has a use-after-free related to leaf anon_vma double reuse.",
        "cvss": "5.5",
        "publish_date": "October 9, 2022",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "2555283eb40df89945557273121e9393ef9b542b",
        "commit_message": "mm/rmap: Fix anon_vma->degree ambiguity leading to double-reuse\n\nanon_vma->degree tracks the combined number of child anon_vmas and VMAs\nthat use the anon_vma as their ->anon_vma.\n\nanon_vma_clone() then assumes that for any anon_vma attached to\nsrc->anon_vma_chain other than src->anon_vma, it is impossible for it to\nbe a leaf node of the VMA tree, meaning that for such VMAs ->degree is\nelevated by 1 because of a child anon_vma, meaning that if ->degree\nequals 1 there are no VMAs that use the anon_vma as their ->anon_vma.\n\nThis assumption is wrong because the ->degree optimization leads to leaf\nnodes being abandoned on anon_vma_clone() - an existing anon_vma is\nreused and no new parent-child relationship is created.  So it is\npossible to reuse an anon_vma for one VMA while it is still tied to\nanother VMA.\n\nThis is an issue because is_mergeable_anon_vma() and its callers assume\nthat if two VMAs have the same ->anon_vma, the list of anon_vmas\nattached to the VMAs is guaranteed to be the same.  When this assumption\nis violated, vma_merge() can merge pages into a VMA that is not attached\nto the corresponding anon_vma, leading to dangling page->mapping\npointers that will be dereferenced during rmap walks.\n\nFix it by separately tracking the number of child anon_vmas and the\nnumber of VMAs using the anon_vma as their ->anon_vma.\n\nFixes: 7a3ef208e662 (\"mm: prevent endless growth of anon_vma hierarchy\")\nCc: stable@kernel.org\nAcked-by: Michal Hocko <mhocko@suse.com>\nAcked-by: Vlastimil Babka <vbabka@suse.cz>\nSigned-off-by: Jann Horn <jannh@google.com>\nSigned-off-by: Linus Torvalds <torvalds@linux-foundation.org>",
        "commit_date": "2022-08-31T22:45:10Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/2555283eb40df89945557273121e9393ef9b542b",
        "html_url": "https://github.com/torvalds/linux/commit/2555283eb40df89945557273121e9393ef9b542b",
        "parents": [
            {
                "commit_id_before": "c5e4d5e99162ba8025d58a3af7ad103f155d2df7",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c5e4d5e99162ba8025d58a3af7ad103f155d2df7",
                "html_url_before": "https://github.com/torvalds/linux/commit/c5e4d5e99162ba8025d58a3af7ad103f155d2df7"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 9613,
        "cve_id": "CVE-2022-42896",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "There are use-after-free vulnerabilities in the Linux kernel's net/bluetooth/l2cap_core.c's l2cap_connect and l2cap_le_connect_req functions which may allow code execution and leaking kernel memory (respectively) remotely via Bluetooth. A remote attacker could execute code leaking kernel memory via Bluetooth if within proximity of the victim. We recommend upgrading past commit https://www.google.com/url https://github.com/torvalds/linux/commit/711f8c3fb3db61897080468586b970c87c61d9e4 https://www.google.com/url",
        "cvss": "8.8",
        "publish_date": "November 23, 2022",
        "AV": "ADJACENT_NETWORK",
        "AC": "ADJACENT_NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "711f8c3fb3db61897080468586b970c87c61d9e4",
        "commit_message": "Bluetooth: L2CAP: Fix accepting connection request for invalid SPSM\n\nThe Bluetooth spec states that the valid range for SPSM is from\n0x0001-0x00ff so it is invalid to accept values outside of this range:\n\n  BLUETOOTH CORE SPECIFICATION Version 5.3 | Vol 3, Part A\n  page 1059:\n  Table 4.15: L2CAP_LE_CREDIT_BASED_CONNECTION_REQ SPSM ranges\n\nCVE: CVE-2022-42896\nCC: stable@vger.kernel.org\nReported-by: Tam\u00e1s Koczka <poprdi@google.com>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nReviewed-by: Tedd Ho-Jeong An <tedd.an@intel.com>",
        "commit_date": "2022-11-02T23:36:59Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/711f8c3fb3db61897080468586b970c87c61d9e4",
        "html_url": "https://github.com/torvalds/linux/commit/711f8c3fb3db61897080468586b970c87c61d9e4",
        "parents": [
            {
                "commit_id_before": "5638d9ea9c01c77fc11693d48cf719bc7e88f224",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/5638d9ea9c01c77fc11693d48cf719bc7e88f224",
                "html_url_before": "https://github.com/torvalds/linux/commit/5638d9ea9c01c77fc11693d48cf719bc7e88f224"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 9917,
        "cve_id": "CVE-2022-47939",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. fs/ksmbd/smb2pdu.c has a use-after-free and OOPS for SMB2_TREE_DISCONNECT.",
        "cvss": "9.8",
        "publish_date": "December 23, 2022",
        "AV": "NETWORK",
        "AC": "NETWORK",
        "PR": "NONE",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "cf6531d98190fa2cf92a6d8bbc8af0a4740a223c",
        "commit_message": "ksmbd: fix use-after-free bug in smb2_tree_disconect\n\nsmb2_tree_disconnect() freed the struct ksmbd_tree_connect,\nbut it left the dangling pointer. It can be accessed\nagain under compound requests.\n\nThis bug can lead an oops looking something link:\n\n[ 1685.468014 ] BUG: KASAN: use-after-free in ksmbd_tree_conn_disconnect+0x131/0x160 [ksmbd]\n[ 1685.468068 ] Read of size 4 at addr ffff888102172180 by task kworker/1:2/4807\n...\n[ 1685.468130 ] Call Trace:\n[ 1685.468132 ]  <TASK>\n[ 1685.468135 ]  dump_stack_lvl+0x49/0x5f\n[ 1685.468141 ]  print_report.cold+0x5e/0x5cf\n[ 1685.468145 ]  ? ksmbd_tree_conn_disconnect+0x131/0x160 [ksmbd]\n[ 1685.468157 ]  kasan_report+0xaa/0x120\n[ 1685.468194 ]  ? ksmbd_tree_conn_disconnect+0x131/0x160 [ksmbd]\n[ 1685.468206 ]  __asan_report_load4_noabort+0x14/0x20\n[ 1685.468210 ]  ksmbd_tree_conn_disconnect+0x131/0x160 [ksmbd]\n[ 1685.468222 ]  smb2_tree_disconnect+0x175/0x250 [ksmbd]\n[ 1685.468235 ]  handle_ksmbd_work+0x30e/0x1020 [ksmbd]\n[ 1685.468247 ]  process_one_work+0x778/0x11c0\n[ 1685.468251 ]  ? _raw_spin_lock_irq+0x8e/0xe0\n[ 1685.468289 ]  worker_thread+0x544/0x1180\n[ 1685.468293 ]  ? __cpuidle_text_end+0x4/0x4\n[ 1685.468297 ]  kthread+0x282/0x320\n[ 1685.468301 ]  ? process_one_work+0x11c0/0x11c0\n[ 1685.468305 ]  ? kthread_complete_and_exit+0x30/0x30\n[ 1685.468309 ]  ret_from_fork+0x1f/0x30\n\nFixes: e2f34481b24d (\"cifsd: add server-side procedures for SMB3\")\nCc: stable@vger.kernel.org\nReported-by: zdi-disclosures@trendmicro.com # ZDI-CAN-17816\nSigned-off-by: Namjae Jeon <linkinjeon@kernel.org>\nReviewed-by: Hyunchul Lee <hyc.lee@gmail.com>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
        "commit_date": "2022-08-01T04:14:32Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/cf6531d98190fa2cf92a6d8bbc8af0a4740a223c",
        "html_url": "https://github.com/torvalds/linux/commit/cf6531d98190fa2cf92a6d8bbc8af0a4740a223c",
        "parents": [
            {
                "commit_id_before": "aa7253c2393f6dcd6a1468b0792f6da76edad917",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/aa7253c2393f6dcd6a1468b0792f6da76edad917",
                "html_url_before": "https://github.com/torvalds/linux/commit/aa7253c2393f6dcd6a1468b0792f6da76edad917"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 10148,
        "cve_id": "CVE-2023-0266",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel.\u00a0SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit\u00a056b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "cvss": "7.8",
        "publish_date": "January 30, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "becf9e5d553c2389d857a3c178ce80fdb34a02e1",
        "commit_message": "ALSA: control: code refactoring for ELEM_READ/ELEM_WRITE operations\n\nALSA control core handles ELEM_READ/ELEM_WRITE requests within lock\nacquisition of a counting semaphore. The lock is acquired in helper\nfunctions in the end of call path before calling implementations of each\ndriver.\n\nioctl(2) with SNDRV_CTL_ELEM_READ\n...\n->snd_ctl_ioctl()\n  ->snd_ctl_elem_read_user()\n    ->snd_ctl_elem_read()\n      ->down_read(controls_rwsem)\n      ->snd_ctl_find_id()\n      ->struct snd_kcontrol.get()\n      ->up_read(controls_rwsem)\n\nioctl(2) with SNDRV_CTL_ELEM_WRITE\n...\n->snd_ctl_ioctl()\n  ->snd_ctl_elem_write_user()\n    ->snd_ctl_elem_write()\n      ->down_read(controls_rwsem)\n      ->snd_ctl_find_id()\n      ->struct snd_kcontrol.put()\n      ->up_read(controls_rwsem)\n\nThis commit moves the lock acquisition to middle of the call graph to\nsimplify the helper functions. As a result:\n\nioctl(2) with SNDRV_CTL_ELEM_READ\n...\n->snd_ctl_ioctl()\n  ->snd_ctl_elem_read_user()\n    ->down_read(controls_rwsem)\n    ->snd_ctl_elem_read()\n      ->snd_ctl_find_id()\n      ->struct snd_kcontrol.get()\n    ->up_read(controls_rwsem)\n\nioctl(2) with SNDRV_CTL_ELEM_WRITE\n...\n->snd_ctl_ioctl()\n  ->snd_ctl_elem_write_user()\n    ->down_read(controls_rwsem)\n    ->snd_ctl_elem_write()\n      ->snd_ctl_find_id()\n      ->struct snd_kcontrol.put()\n    ->up_read(controls_rwsem)\n\nSigned-off-by: Takashi Sakamoto <o-takashi@sakamocchi.jp>\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2017-08-20T07:39:54Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/becf9e5d553c2389d857a3c178ce80fdb34a02e1",
        "html_url": "https://github.com/torvalds/linux/commit/becf9e5d553c2389d857a3c178ce80fdb34a02e1",
        "parents": [
            {
                "commit_id_before": "7b42cfafdcbf73bd58687cbe3157b9ca4a0fd2e5",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/7b42cfafdcbf73bd58687cbe3157b9ca4a0fd2e5",
                "html_url_before": "https://github.com/torvalds/linux/commit/7b42cfafdcbf73bd58687cbe3157b9ca4a0fd2e5"
            }
        ],
        "outdated": 1,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 10149,
        "cve_id": "CVE-2023-0266",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use after free vulnerability exists in the ALSA PCM package in the Linux Kernel.\u00a0SNDRV_CTL_IOCTL_ELEM_{READ|WRITE}32 is missing locks that can be used in a use-after-free that can result in a priviledge escalation to gain ring0 access from the system user. We recommend upgrading past commit\u00a056b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "cvss": "7.8",
        "publish_date": "January 30, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "56b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "commit_message": "ALSA: pcm: Move rwsem lock inside snd_ctl_elem_read to prevent UAF\n\nTakes rwsem lock inside snd_ctl_elem_read instead of snd_ctl_elem_read_user\nlike it was done for write in commit 1fa4445f9adf1 (\"ALSA: control - introduce\nsnd_ctl_notify_one() helper\"). Doing this way we are also fixing the following\nlocking issue happening in the compat path which can be easily triggered and\nturned into an use-after-free.\n\n64-bits:\nsnd_ctl_ioctl\n  snd_ctl_elem_read_user\n    [takes controls_rwsem]\n    snd_ctl_elem_read [lock properly held, all good]\n    [drops controls_rwsem]\n\n32-bits:\nsnd_ctl_ioctl_compat\n  snd_ctl_elem_write_read_compat\n    ctl_elem_write_read\n      snd_ctl_elem_read [missing lock, not good]\n\nCVE-2023-0266 was assigned for this issue.\n\nCc: stable@kernel.org # 5.13+\nSigned-off-by: Clement Lecigne <clecigne@google.com>\nReviewed-by: Jaroslav Kysela <perex@perex.cz>\nLink: https://lore.kernel.org/r/20230113120745.25464-1-tiwai@suse.de\nSigned-off-by: Takashi Iwai <tiwai@suse.de>",
        "commit_date": "2023-01-13T13:15:26Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/56b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "html_url": "https://github.com/torvalds/linux/commit/56b88b50565cd8b946a2d00b0c83927b7ebb055e",
        "parents": [
            {
                "commit_id_before": "92a9c0ad86d47ff4cce899012e355c400f02cfb8",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/92a9c0ad86d47ff4cce899012e355c400f02cfb8",
                "html_url_before": "https://github.com/torvalds/linux/commit/92a9c0ad86d47ff4cce899012e355c400f02cfb8"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 11098,
        "cve_id": "CVE-2023-1118",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw use after free in the Linux kernel integrated infrared receiver/transceiver driver was found in the way user detaching rc device. A local user could use this flaw to crash the system or potentially escalate their privileges on the system.",
        "cvss": "7.8",
        "publish_date": "March 2, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "29b0589a865b6f66d141d79b2dd1373e4e50fe17",
        "commit_message": "media: rc: Fix use-after-free bugs caused by ene_tx_irqsim()\n\nWhen the ene device is detaching, function ene_remove() will\nbe called. But there is no function to cancel tx_sim_timer\nin ene_remove(), the timer handler ene_tx_irqsim() could race\nwith ene_remove(). As a result, the UAF bugs could happen,\nthe process is shown below.\n\n    (cleanup routine)          |        (timer routine)\n                               | mod_timer(&dev->tx_sim_timer, ..)\nene_remove()                   | (wait a time)\n                               | ene_tx_irqsim()\n                               |   dev->hw_lock //USE\n                               |   ene_tx_sample(dev) //USE\n\nFix by adding del_timer_sync(&dev->tx_sim_timer) in ene_remove(),\nThe tx_sim_timer could stop before ene device is deallocated.\n\nWhat's more, The rc_unregister_device() and del_timer_sync()\nshould be called first in ene_remove() and the deallocated\nfunctions such as free_irq(), release_region() and so on\nshould be called behind them. Because the rc_unregister_device()\nis well synchronized. Otherwise, race conditions may happen. The\nsituations that may lead to race conditions are shown below.\n\nFirstly, the rx receiver is disabled with ene_rx_disable()\nbefore rc_unregister_device() in ene_remove(), which means it\ncan be enabled again if a process opens /dev/lirc0 between\nene_rx_disable() and rc_unregister_device().\n\nSecondly, the irqaction descriptor is freed by free_irq()\nbefore the rc device is unregistered, which means irqaction\ndescriptor may be accessed again after it is deallocated.\n\nThirdly, the timer can call ene_tx_sample() that can write\nto the io ports, which means the io ports could be accessed\nagain after they are deallocated by release_region().\n\nTherefore, the rc_unregister_device() and del_timer_sync()\nshould be called first in ene_remove().\n\nSuggested by: Sean Young <sean@mess.org>\n\nFixes: 9ea53b74df9c (\"V4L/DVB: STAGING: remove lirc_ene0100 driver\")\nSigned-off-by: Duoming Zhou <duoming@zju.edu.cn>\nSigned-off-by: Sean Young <sean@mess.org>\nSigned-off-by: Mauro Carvalho Chehab <mchehab@kernel.org>",
        "commit_date": "2023-02-08T06:49:22Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/29b0589a865b6f66d141d79b2dd1373e4e50fe17",
        "html_url": "https://github.com/torvalds/linux/commit/29b0589a865b6f66d141d79b2dd1373e4e50fe17",
        "parents": [
            {
                "commit_id_before": "30040818b338b8ebc956ce0ebd198f8d593586a6",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/30040818b338b8ebc956ce0ebd198f8d593586a6",
                "html_url_before": "https://github.com/torvalds/linux/commit/30040818b338b8ebc956ce0ebd198f8d593586a6"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 11490,
        "cve_id": "CVE-2023-1195",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in reconn_set_ipaddr_from_hostname in fs/cifs/connect.c in the Linux kernel. The issue occurs when it forgets to set the free pointer server->hostname to NULL, leading to an invalid pointer request.",
        "cvss": "5.5",
        "publish_date": "May 18, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "153695d36ead0ccc4d0256953c751cabf673e621",
        "commit_message": "cifs: fix use-after-free caused by invalid pointer `hostname`\n\n`hostname` needs to be set as null-pointer after free in\n`cifs_put_tcp_session` function, or when `cifsd` thread attempts\nto resolve hostname and reconnect the host, the thread would deref\nthe invalid pointer.\n\nHere is one of practical backtrace examples as reference:\n\nTask 477\n---------------------------\n do_mount\n  path_mount\n   do_new_mount\n    vfs_get_tree\n     smb3_get_tree\n      smb3_get_tree_common\n       cifs_smb3_do_mount\n        cifs_mount\n         mount_put_conns\n          cifs_put_tcp_session\n          --> kfree(server->hostname)\n\ncifsd\n---------------------------\n kthread\n  cifs_demultiplex_thread\n   cifs_reconnect\n    reconn_set_ipaddr_from_hostname\n    --> if (!server->hostname)\n    --> if (server->hostname[0] == '\\0')  // !! UAF fault here\n\nCIFS: VFS: cifs_mount failed w/return code = -112\nmount error(112): Host is down\nBUG: KASAN: use-after-free in reconn_set_ipaddr_from_hostname+0x2ba/0x310\nRead of size 1 at addr ffff888108f35380 by task cifsd/480\nCPU: 2 PID: 480 Comm: cifsd Not tainted 6.1.0-rc2-00106-gf705792f89dd-dirty #25\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.13.0-1ubuntu1.1 04/01/2014\nCall Trace:\n <TASK>\n dump_stack_lvl+0x68/0x85\n print_report+0x16c/0x4a3\n kasan_report+0x95/0x190\n reconn_set_ipaddr_from_hostname+0x2ba/0x310\n __cifs_reconnect.part.0+0x241/0x800\n cifs_reconnect+0x65f/0xb60\n cifs_demultiplex_thread+0x1570/0x2570\n kthread+0x2c5/0x380\n ret_from_fork+0x22/0x30\n </TASK>\nAllocated by task 477:\n kasan_save_stack+0x1e/0x40\n kasan_set_track+0x21/0x30\n __kasan_kmalloc+0x7e/0x90\n __kmalloc_node_track_caller+0x52/0x1b0\n kstrdup+0x3b/0x70\n cifs_get_tcp_session+0xbc/0x19b0\n mount_get_conns+0xa9/0x10c0\n cifs_mount+0xdf/0x1970\n cifs_smb3_do_mount+0x295/0x1660\n smb3_get_tree+0x352/0x5e0\n vfs_get_tree+0x8e/0x2e0\n path_mount+0xf8c/0x1990\n do_mount+0xee/0x110\n __x64_sys_mount+0x14b/0x1f0\n do_syscall_64+0x3b/0x90\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nFreed by task 477:\n kasan_save_stack+0x1e/0x40\n kasan_set_track+0x21/0x30\n kasan_save_free_info+0x2a/0x50\n __kasan_slab_free+0x10a/0x190\n __kmem_cache_free+0xca/0x3f0\n cifs_put_tcp_session+0x30c/0x450\n cifs_mount+0xf95/0x1970\n cifs_smb3_do_mount+0x295/0x1660\n smb3_get_tree+0x352/0x5e0\n vfs_get_tree+0x8e/0x2e0\n path_mount+0xf8c/0x1990\n do_mount+0xee/0x110\n __x64_sys_mount+0x14b/0x1f0\n do_syscall_64+0x3b/0x90\n entry_SYSCALL_64_after_hwframe+0x63/0xcd\nThe buggy address belongs to the object at ffff888108f35380\n which belongs to the cache kmalloc-16 of size 16\nThe buggy address is located 0 bytes inside of\n 16-byte region [ffff888108f35380, ffff888108f35390)\nThe buggy address belongs to the physical page:\npage:00000000333f8e58 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888108f350e0 pfn:0x108f35\nflags: 0x200000000000200(slab|node=0|zone=2)\nraw: 0200000000000200 0000000000000000 dead000000000122 ffff8881000423c0\nraw: ffff888108f350e0 000000008080007a 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\nMemory state around the buggy address:\n ffff888108f35280: fa fb fc fc fa fb fc fc fa fb fc fc fa fb fc fc\n ffff888108f35300: fa fb fc fc fa fb fc fc fa fb fc fc fa fb fc fc\n>ffff888108f35380: fa fb fc fc fa fb fc fc fa fb fc fc fa fb fc fc\n                   ^\n ffff888108f35400: fa fb fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff888108f35480: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n\nFixes: 7be3248f3139 (\"cifs: To match file servers, make sure the server hostname matches\")\nSigned-off-by: Zeng Heng <zengheng4@huawei.com>\nReviewed-by: Paulo Alcantara (SUSE) <pc@cjr.nz>\nSigned-off-by: Steve French <stfrench@microsoft.com>",
        "commit_date": "2022-10-28T04:59:13Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/153695d36ead0ccc4d0256953c751cabf673e621",
        "html_url": "https://github.com/torvalds/linux/commit/153695d36ead0ccc4d0256953c751cabf673e621",
        "parents": [
            {
                "commit_id_before": "f950c85e782f90702468bba8243cc97a8d0d04b0",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/f950c85e782f90702468bba8243cc97a8d0d04b0",
                "html_url_before": "https://github.com/torvalds/linux/commit/f950c85e782f90702468bba8243cc97a8d0d04b0"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 11356,
        "cve_id": "CVE-2023-1611",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in btrfs_search_slot in fs/btrfs/ctree.c in btrfs in the Linux Kernel.This flaw allows an attacker to crash the system and possibly cause a kernel information lea",
        "cvss": "6.3",
        "publish_date": "April 3, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "2f1a6be12ab6c8470d5776e68644726c94257c54",
        "commit_message": "btrfs: fix race between quota disable and quota assign ioctls\n\nThe quota assign ioctl can currently run in parallel with a quota disable\nioctl call. The assign ioctl uses the quota root, while the disable ioctl\nfrees that root, and therefore we can have a use-after-free triggered in\nthe assign ioctl, leading to a trace like the following when KASAN is\nenabled:\n\n  [672.723][T736] BUG: KASAN: slab-use-after-free in btrfs_search_slot+0x2962/0x2db0\n  [672.723][T736] Read of size 8 at addr ffff888022ec0208 by task btrfs_search_sl/27736\n  [672.724][T736]\n  [672.725][T736] CPU: 1 PID: 27736 Comm: btrfs_search_sl Not tainted 6.3.0-rc3 #37\n  [672.723][T736] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\n  [672.727][T736] Call Trace:\n  [672.728][T736]  <TASK>\n  [672.728][T736]  dump_stack_lvl+0xd9/0x150\n  [672.725][T736]  print_report+0xc1/0x5e0\n  [672.720][T736]  ? __virt_addr_valid+0x61/0x2e0\n  [672.727][T736]  ? __phys_addr+0xc9/0x150\n  [672.725][T736]  ? btrfs_search_slot+0x2962/0x2db0\n  [672.722][T736]  kasan_report+0xc0/0xf0\n  [672.729][T736]  ? btrfs_search_slot+0x2962/0x2db0\n  [672.724][T736]  btrfs_search_slot+0x2962/0x2db0\n  [672.723][T736]  ? fs_reclaim_acquire+0xba/0x160\n  [672.722][T736]  ? split_leaf+0x13d0/0x13d0\n  [672.726][T736]  ? rcu_is_watching+0x12/0xb0\n  [672.723][T736]  ? kmem_cache_alloc+0x338/0x3c0\n  [672.722][T736]  update_qgroup_status_item+0xf7/0x320\n  [672.724][T736]  ? add_qgroup_rb+0x3d0/0x3d0\n  [672.739][T736]  ? do_raw_spin_lock+0x12d/0x2b0\n  [672.730][T736]  ? spin_bug+0x1d0/0x1d0\n  [672.737][T736]  btrfs_run_qgroups+0x5de/0x840\n  [672.730][T736]  ? btrfs_qgroup_rescan_worker+0xa70/0xa70\n  [672.738][T736]  ? __del_qgroup_relation+0x4ba/0xe00\n  [672.738][T736]  btrfs_ioctl+0x3d58/0x5d80\n  [672.735][T736]  ? tomoyo_path_number_perm+0x16a/0x550\n  [672.737][T736]  ? tomoyo_execute_permission+0x4a0/0x4a0\n  [672.731][T736]  ? btrfs_ioctl_get_supported_features+0x50/0x50\n  [672.737][T736]  ? __sanitizer_cov_trace_switch+0x54/0x90\n  [672.734][T736]  ? do_vfs_ioctl+0x132/0x1660\n  [672.730][T736]  ? vfs_fileattr_set+0xc40/0xc40\n  [672.730][T736]  ? _raw_spin_unlock_irq+0x2e/0x50\n  [672.732][T736]  ? sigprocmask+0xf2/0x340\n  [672.737][T736]  ? __fget_files+0x26a/0x480\n  [672.732][T736]  ? bpf_lsm_file_ioctl+0x9/0x10\n  [672.738][T736]  ? btrfs_ioctl_get_supported_features+0x50/0x50\n  [672.736][T736]  __x64_sys_ioctl+0x198/0x210\n  [672.736][T736]  do_syscall_64+0x39/0xb0\n  [672.731][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  [672.739][T736] RIP: 0033:0x4556ad\n  [672.742][T736]  </TASK>\n  [672.743][T736]\n  [672.748][T736] Allocated by task 27677:\n  [672.743][T736]  kasan_save_stack+0x22/0x40\n  [672.741][T736]  kasan_set_track+0x25/0x30\n  [672.741][T736]  __kasan_kmalloc+0xa4/0xb0\n  [672.749][T736]  btrfs_alloc_root+0x48/0x90\n  [672.746][T736]  btrfs_create_tree+0x146/0xa20\n  [672.744][T736]  btrfs_quota_enable+0x461/0x1d20\n  [672.743][T736]  btrfs_ioctl+0x4a1c/0x5d80\n  [672.747][T736]  __x64_sys_ioctl+0x198/0x210\n  [672.749][T736]  do_syscall_64+0x39/0xb0\n  [672.744][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  [672.756][T736]\n  [672.757][T736] Freed by task 27677:\n  [672.759][T736]  kasan_save_stack+0x22/0x40\n  [672.759][T736]  kasan_set_track+0x25/0x30\n  [672.756][T736]  kasan_save_free_info+0x2e/0x50\n  [672.751][T736]  ____kasan_slab_free+0x162/0x1c0\n  [672.758][T736]  slab_free_freelist_hook+0x89/0x1c0\n  [672.752][T736]  __kmem_cache_free+0xaf/0x2e0\n  [672.752][T736]  btrfs_put_root+0x1ff/0x2b0\n  [672.759][T736]  btrfs_quota_disable+0x80a/0xbc0\n  [672.752][T736]  btrfs_ioctl+0x3e5f/0x5d80\n  [672.756][T736]  __x64_sys_ioctl+0x198/0x210\n  [672.753][T736]  do_syscall_64+0x39/0xb0\n  [672.765][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  [672.769][T736]\n  [672.768][T736] The buggy address belongs to the object at ffff888022ec0000\n  [672.768][T736]  which belongs to the cache kmalloc-4k of size 4096\n  [672.769][T736] The buggy address is located 520 bytes inside of\n  [672.769][T736]  freed 4096-byte region [ffff888022ec0000, ffff888022ec1000)\n  [672.760][T736]\n  [672.764][T736] The buggy address belongs to the physical page:\n  [672.761][T736] page:ffffea00008bb000 refcount:1 mapcount:0 mapping:0000000000000000 index:0x0 pfn:0x22ec0\n  [672.766][T736] head:ffffea00008bb000 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0\n  [672.779][T736] flags: 0xfff00000010200(slab|head|node=0|zone=1|lastcpupid=0x7ff)\n  [672.770][T736] raw: 00fff00000010200 ffff888012842140 ffffea000054ba00 dead000000000002\n  [672.770][T736] raw: 0000000000000000 0000000000040004 00000001ffffffff 0000000000000000\n  [672.771][T736] page dumped because: kasan: bad access detected\n  [672.778][T736] page_owner tracks the page as allocated\n  [672.777][T736] page last allocated via order 3, migratetype Unmovable, gfp_mask 0xd2040(__GFP_IO|__GFP_NOWARN|__GFP_NORETRY|__GFP_COMP|__GFP_NOMEMALLOC), pid 88\n  [672.779][T736]  get_page_from_freelist+0x119c/0x2d50\n  [672.779][T736]  __alloc_pages+0x1cb/0x4a0\n  [672.776][T736]  alloc_pages+0x1aa/0x270\n  [672.773][T736]  allocate_slab+0x260/0x390\n  [672.771][T736]  ___slab_alloc+0xa9a/0x13e0\n  [672.778][T736]  __slab_alloc.constprop.0+0x56/0xb0\n  [672.771][T736]  __kmem_cache_alloc_node+0x136/0x320\n  [672.789][T736]  __kmalloc+0x4e/0x1a0\n  [672.783][T736]  tomoyo_realpath_from_path+0xc3/0x600\n  [672.781][T736]  tomoyo_path_perm+0x22f/0x420\n  [672.782][T736]  tomoyo_path_unlink+0x92/0xd0\n  [672.780][T736]  security_path_unlink+0xdb/0x150\n  [672.788][T736]  do_unlinkat+0x377/0x680\n  [672.788][T736]  __x64_sys_unlink+0xca/0x110\n  [672.789][T736]  do_syscall_64+0x39/0xb0\n  [672.783][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  [672.784][T736] page last free stack trace:\n  [672.787][T736]  free_pcp_prepare+0x4e5/0x920\n  [672.787][T736]  free_unref_page+0x1d/0x4e0\n  [672.784][T736]  __unfreeze_partials+0x17c/0x1a0\n  [672.797][T736]  qlist_free_all+0x6a/0x180\n  [672.796][T736]  kasan_quarantine_reduce+0x189/0x1d0\n  [672.797][T736]  __kasan_slab_alloc+0x64/0x90\n  [672.793][T736]  kmem_cache_alloc+0x17c/0x3c0\n  [672.799][T736]  getname_flags.part.0+0x50/0x4e0\n  [672.799][T736]  getname_flags+0x9e/0xe0\n  [672.792][T736]  vfs_fstatat+0x77/0xb0\n  [672.791][T736]  __do_sys_newlstat+0x84/0x100\n  [672.798][T736]  do_syscall_64+0x39/0xb0\n  [672.796][T736]  entry_SYSCALL_64_after_hwframe+0x63/0xcd\n  [672.790][T736]\n  [672.791][T736] Memory state around the buggy address:\n  [672.799][T736]  ffff888022ec0100: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  [672.805][T736]  ffff888022ec0180: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  [672.802][T736] >ffff888022ec0200: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  [672.809][T736]                       ^\n  [672.809][T736]  ffff888022ec0280: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n  [672.809][T736]  ffff888022ec0300: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\nFix this by having the qgroup assign ioctl take the qgroup ioctl mutex\nbefore calling btrfs_run_qgroups(), which is what all qgroup ioctls should\ncall.\n\nReported-by: butt3rflyh4ck <butterflyhuangxx@gmail.com>\nLink: https://lore.kernel.org/linux-btrfs/CAFcO6XN3VD8ogmHwqRk4kbiwtpUSNySu2VAxN8waEPciCHJvMA@mail.gmail.com/\nCC: stable@vger.kernel.org # 5.10+\nReviewed-by: Qu Wenruo <wqu@suse.com>\nSigned-off-by: Filipe Manana <fdmanana@suse.com>\nReviewed-by: David Sterba <dsterba@suse.com>\nSigned-off-by: David Sterba <dsterba@suse.com>",
        "commit_date": "2023-03-27T22:46:53Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/2f1a6be12ab6c8470d5776e68644726c94257c54",
        "html_url": "https://github.com/torvalds/linux/commit/2f1a6be12ab6c8470d5776e68644726c94257c54",
        "parents": [
            {
                "commit_id_before": "e15acc25880cf048dba9df94d76ed7e7e10040e6",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/e15acc25880cf048dba9df94d76ed7e7e10040e6",
                "html_url_before": "https://github.com/torvalds/linux/commit/e15acc25880cf048dba9df94d76ed7e7e10040e6"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 11333,
        "cve_id": "CVE-2023-1855",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in xgene_hwmon_remove in drivers/hwmon/xgene-hwmon.c in the Hardware Monitoring Linux Kernel Driver (xgene-hwmon). This flaw could allow a local attacker to crash the system due to a race problem. This vulnerability could even lead to a kernel information leak problem.",
        "cvss": "6.3",
        "publish_date": "April 5, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "cb090e64cf25602b9adaf32d5dfc9c8bec493cd1",
        "commit_message": "hwmon: (xgene) Fix use after free bug in xgene_hwmon_remove due to race condition\n\nIn xgene_hwmon_probe, &ctx->workq is bound with xgene_hwmon_evt_work.\nThen it will be started.\n\nIf we remove the driver which will call xgene_hwmon_remove to clean up,\nthere may be unfinished work.\n\nThe possible sequence is as follows:\n\nFix it by finishing the work before cleanup in xgene_hwmon_remove.\n\nCPU0                  CPU1\n\n                    |xgene_hwmon_evt_work\nxgene_hwmon_remove   |\nkfifo_free(&ctx->async_msg_fifo);|\n                    |\n                    |kfifo_out_spinlocked\n                    |//use &ctx->async_msg_fifo\nFixes: 2ca492e22cb7 (\"hwmon: (xgene) Fix crash when alarm occurs before driver probe\")\nSigned-off-by: Zheng Wang <zyytlz.wz@163.com>\nLink: https://lore.kernel.org/r/20230310084007.1403388-1-zyytlz.wz@163.com\nSigned-off-by: Guenter Roeck <linux@roeck-us.net>",
        "commit_date": "2023-03-12T18:13:25Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/cb090e64cf25602b9adaf32d5dfc9c8bec493cd1",
        "html_url": "https://github.com/torvalds/linux/commit/cb090e64cf25602b9adaf32d5dfc9c8bec493cd1",
        "parents": [
            {
                "commit_id_before": "48e8186870d9d0902e712d601ccb7098cb220688",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/48e8186870d9d0902e712d601ccb7098cb220688",
                "html_url_before": "https://github.com/torvalds/linux/commit/48e8186870d9d0902e712d601ccb7098cb220688"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 11561,
        "cve_id": "CVE-2023-2513",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free vulnerability was found in the Linux kernel's ext4 filesystem in the way it handled the extra inode size for extended attributes. This flaw could allow a privileged local user to cause a system crash or other undefined behaviors.",
        "cvss": "6.7",
        "publish_date": "May 8, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "HIGH",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "67d7d8ad99beccd9fe92d585b87f1760dc9018e3",
        "commit_message": "ext4: fix use-after-free in ext4_xattr_set_entry\n\nHulk Robot reported a issue:\n==================================================================\nBUG: KASAN: use-after-free in ext4_xattr_set_entry+0x18ab/0x3500\nWrite of size 4105 at addr ffff8881675ef5f4 by task syz-executor.0/7092\n\nCPU: 1 PID: 7092 Comm: syz-executor.0 Not tainted 4.19.90-dirty #17\nCall Trace:\n[...]\n memcpy+0x34/0x50 mm/kasan/kasan.c:303\n ext4_xattr_set_entry+0x18ab/0x3500 fs/ext4/xattr.c:1747\n ext4_xattr_ibody_inline_set+0x86/0x2a0 fs/ext4/xattr.c:2205\n ext4_xattr_set_handle+0x940/0x1300 fs/ext4/xattr.c:2386\n ext4_xattr_set+0x1da/0x300 fs/ext4/xattr.c:2498\n __vfs_setxattr+0x112/0x170 fs/xattr.c:149\n __vfs_setxattr_noperm+0x11b/0x2a0 fs/xattr.c:180\n __vfs_setxattr_locked+0x17b/0x250 fs/xattr.c:238\n vfs_setxattr+0xed/0x270 fs/xattr.c:255\n setxattr+0x235/0x330 fs/xattr.c:520\n path_setxattr+0x176/0x190 fs/xattr.c:539\n __do_sys_lsetxattr fs/xattr.c:561 [inline]\n __se_sys_lsetxattr fs/xattr.c:557 [inline]\n __x64_sys_lsetxattr+0xc2/0x160 fs/xattr.c:557\n do_syscall_64+0xdf/0x530 arch/x86/entry/common.c:298\n entry_SYSCALL_64_after_hwframe+0x44/0xa9\nRIP: 0033:0x459fe9\nRSP: 002b:00007fa5e54b4c08 EFLAGS: 00000246 ORIG_RAX: 00000000000000bd\nRAX: ffffffffffffffda RBX: 000000000051bf60 RCX: 0000000000459fe9\nRDX: 00000000200003c0 RSI: 0000000020000180 RDI: 0000000020000140\nRBP: 000000000051bf60 R08: 0000000000000001 R09: 0000000000000000\nR10: 0000000000001009 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007ffc73c93fc0 R14: 000000000051bf60 R15: 00007fa5e54b4d80\n[...]\n==================================================================\n\nAbove issue may happen as follows:\n-------------------------------------\next4_xattr_set\n  ext4_xattr_set_handle\n    ext4_xattr_ibody_find\n      >> s->end < s->base\n      >> no EXT4_STATE_XATTR\n      >> xattr_check_inode is not executed\n    ext4_xattr_ibody_set\n      ext4_xattr_set_entry\n       >> size_t min_offs = s->end - s->base\n       >> UAF in memcpy\n\nwe can easily reproduce this problem with the following commands:\n    mkfs.ext4 -F /dev/sda\n    mount -o debug_want_extra_isize=128 /dev/sda /mnt\n    touch /mnt/file\n    setfattr -n user.cat -v `seq -s z 4096|tr -d '[:digit:]'` /mnt/file\n\nIn ext4_xattr_ibody_find, we have the following assignment logic:\n  header = IHDR(inode, raw_inode)\n         = raw_inode + EXT4_GOOD_OLD_INODE_SIZE + i_extra_isize\n  is->s.base = IFIRST(header)\n             = header + sizeof(struct ext4_xattr_ibody_header)\n  is->s.end = raw_inode + s_inode_size\n\nIn ext4_xattr_set_entry\n  min_offs = s->end - s->base\n           = s_inode_size - EXT4_GOOD_OLD_INODE_SIZE - i_extra_isize -\n\t     sizeof(struct ext4_xattr_ibody_header)\n  last = s->first\n  free = min_offs - ((void *)last - s->base) - sizeof(__u32)\n       = s_inode_size - EXT4_GOOD_OLD_INODE_SIZE - i_extra_isize -\n         sizeof(struct ext4_xattr_ibody_header) - sizeof(__u32)\n\nIn the calculation formula, all values except s_inode_size and\ni_extra_size are fixed values. When i_extra_size is the maximum value\ns_inode_size - EXT4_GOOD_OLD_INODE_SIZE, min_offs is -4 and free is -8.\nThe value overflows. As a result, the preceding issue is triggered when\nmemcpy is executed.\n\nTherefore, when finding xattr or setting xattr, check whether\nthere is space for storing xattr in the inode to resolve this issue.\n\nCc: stable@kernel.org\nReported-by: Hulk Robot <hulkci@huawei.com>\nSigned-off-by: Baokun Li <libaokun1@huawei.com>\nReviewed-by: Ritesh Harjani (IBM) <ritesh.list@gmail.com>\nReviewed-by: Jan Kara <jack@suse.cz>\nLink: https://lore.kernel.org/r/20220616021358.2504451-3-libaokun1@huawei.com\nSigned-off-by: Theodore Ts'o <tytso@mit.edu>",
        "commit_date": "2022-08-03T03:52:34Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/67d7d8ad99beccd9fe92d585b87f1760dc9018e3",
        "html_url": "https://github.com/torvalds/linux/commit/67d7d8ad99beccd9fe92d585b87f1760dc9018e3",
        "parents": [
            {
                "commit_id_before": "179b14152dcb6a24c3415200603aebca70ff13af",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/179b14152dcb6a24c3415200603aebca70ff13af",
                "html_url_before": "https://github.com/torvalds/linux/commit/179b14152dcb6a24c3415200603aebca70ff13af"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 11562,
        "cve_id": "CVE-2023-32233",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "In the Linux kernel through 6.3.1, a use-after-free in Netfilter nf_tables when processing batch requests can be abused to perform arbitrary read and write operations on kernel memory. Unprivileged local users can obtain root privileges. This occurs because anonymous sets are mishandled.",
        "cvss": "7.8",
        "publish_date": "May 8, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "c1592a89942e9678f7d9c8030efa777c0d57edab",
        "commit_message": "netfilter: nf_tables: deactivate anonymous set from preparation phase\n\nToggle deleted anonymous sets as inactive in the next generation, so\nusers cannot perform any update on it. Clear the generation bitmask\nin case the transaction is aborted.\n\nThe following KASAN splat shows a set element deletion for a bound\nanonymous set that has been already removed in the same transaction.\n\n[   64.921510] ==================================================================\n[   64.923123] BUG: KASAN: wild-memory-access in nf_tables_commit+0xa24/0x1490 [nf_tables]\n[   64.924745] Write of size 8 at addr dead000000000122 by task test/890\n[   64.927903] CPU: 3 PID: 890 Comm: test Not tainted 6.3.0+ #253\n[   64.931120] Call Trace:\n[   64.932699]  <TASK>\n[   64.934292]  dump_stack_lvl+0x33/0x50\n[   64.935908]  ? nf_tables_commit+0xa24/0x1490 [nf_tables]\n[   64.937551]  kasan_report+0xda/0x120\n[   64.939186]  ? nf_tables_commit+0xa24/0x1490 [nf_tables]\n[   64.940814]  nf_tables_commit+0xa24/0x1490 [nf_tables]\n[   64.942452]  ? __kasan_slab_alloc+0x2d/0x60\n[   64.944070]  ? nf_tables_setelem_notify+0x190/0x190 [nf_tables]\n[   64.945710]  ? kasan_set_track+0x21/0x30\n[   64.947323]  nfnetlink_rcv_batch+0x709/0xd90 [nfnetlink]\n[   64.948898]  ? nfnetlink_rcv_msg+0x480/0x480 [nfnetlink]\n\nSigned-off-by: Pablo Neira Ayuso <pablo@netfilter.org>",
        "commit_date": "2023-05-03T06:24:32Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/c1592a89942e9678f7d9c8030efa777c0d57edab",
        "html_url": "https://github.com/torvalds/linux/commit/c1592a89942e9678f7d9c8030efa777c0d57edab",
        "parents": [
            {
                "commit_id_before": "de4773f0235acf74554f6a64ea60adc0d7b01895",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/de4773f0235acf74554f6a64ea60adc0d7b01895",
                "html_url_before": "https://github.com/torvalds/linux/commit/de4773f0235acf74554f6a64ea60adc0d7b01895"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 11484,
        "cve_id": "CVE-2023-33288",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in the Linux kernel before 6.2.9. A use-after-free was found in bq24190_remove in drivers/power/supply/bq24190_charger.c. It could allow a local attacker to crash the system due to a race condition.",
        "cvss": "4.7",
        "publish_date": "May 21, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "47c29d69212911f50bdcdd0564b5999a559010d4",
        "commit_message": "power: supply: bq24190: Fix use after free bug in bq24190_remove due to race condition\n\nIn bq24190_probe, &bdi->input_current_limit_work is bound\nwith bq24190_input_current_limit_work. When external power\nchanged, it will call bq24190_charger_external_power_changed\n to start the work.\n\nIf we remove the module which will call bq24190_remove to make\ncleanup, there may be a unfinished work. The possible\nsequence is as follows:\n\nCPU0                  CPUc1\n\n                    |bq24190_input_current_limit_work\nbq24190_remove      |\npower_supply_unregister  |\ndevice_unregister   |\npower_supply_dev_release|\nkfree(psy)          |\n                    |\n                    | power_supply_get_property_from_supplier\n                    |   //use\n\nFix it by finishing the work before cleanup in the bq24190_remove\n\nFixes: 97774672573a (\"power_supply: Initialize changed_work before calling device_add\")\nSigned-off-by: Zheng Wang <zyytlz.wz@163.com>\nSigned-off-by: Sebastian Reichel <sebastian.reichel@collabora.com>",
        "commit_date": "2023-03-09T23:35:20Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/47c29d69212911f50bdcdd0564b5999a559010d4",
        "html_url": "https://github.com/torvalds/linux/commit/47c29d69212911f50bdcdd0564b5999a559010d4",
        "parents": [
            {
                "commit_id_before": "bf6c880d5d1448489ebf92e2d13d5713ff644930",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/bf6c880d5d1448489ebf92e2d13d5713ff644930",
                "html_url_before": "https://github.com/torvalds/linux/commit/bf6c880d5d1448489ebf92e2d13d5713ff644930"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 11625,
        "cve_id": "CVE-2023-3439",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A flaw was found in the MCTP protocol in the Linux kernel. The function mctp_unregister() reclaims the device's relevant resource when a netcard detaches. However, a running routine may be unaware of this and cause the use-after-free of the mdev->addrs object, potentially leading to a denial of service.",
        "cvss": "4.7",
        "publish_date": "June 28, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "NONE",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "b561275d633bcd8e0e8055ab86f1a13df75a0269",
        "commit_message": "mctp: defer the kfree of object mdev->addrs\n\nThe function mctp_unregister() reclaims the device's relevant resource\nwhen a netcard detaches. However, a running routine may be unaware of\nthis and cause the use-after-free of the mdev->addrs object.\n\nThe race condition can be demonstrated below\n\n cleanup thread               another thread\n                          |\nunregister_netdev()       |  mctp_sendmsg()\n...                       |    ...\n  mctp_unregister()       |    rt = mctp_route_lookup()\n    ...                   |    mctl_local_output()\n    kfree(mdev->addrs)    |      ...\n                          |      saddr = rt->dev->addrs[0];\n                          |\n\nAn attacker can adopt the (recent provided) mtcpserial driver with pty\nto fake the device detaching and use the userfaultfd to increase the\nrace success chance (in mctp_sendmsg). The KASan report for such a POC\nis shown below:\n\n[   86.051955] ==================================================================\n[   86.051955] BUG: KASAN: use-after-free in mctp_local_output+0x4e9/0xb7d\n[   86.051955] Read of size 1 at addr ffff888005f298c0 by task poc/295\n[   86.051955]\n[   86.051955] Call Trace:\n[   86.051955]  <TASK>\n[   86.051955]  dump_stack_lvl+0x33/0x42\n[   86.051955]  print_report.cold.13+0xb2/0x6b3\n[   86.051955]  ? preempt_schedule_irq+0x57/0x80\n[   86.051955]  ? mctp_local_output+0x4e9/0xb7d\n[   86.051955]  kasan_report+0xa5/0x120\n[   86.051955]  ? mctp_local_output+0x4e9/0xb7d\n[   86.051955]  mctp_local_output+0x4e9/0xb7d\n[   86.051955]  ? mctp_dev_set_key+0x79/0x79\n[   86.051955]  ? copyin+0x38/0x50\n[   86.051955]  ? _copy_from_iter+0x1b6/0xf20\n[   86.051955]  ? sysvec_apic_timer_interrupt+0x97/0xb0\n[   86.051955]  ? asm_sysvec_apic_timer_interrupt+0x12/0x20\n[   86.051955]  ? mctp_local_output+0x1/0xb7d\n[   86.051955]  mctp_sendmsg+0x64d/0xdb0\n[   86.051955]  ? mctp_sk_close+0x20/0x20\n[   86.051955]  ? __fget_light+0x2fd/0x4f0\n[   86.051955]  ? mctp_sk_close+0x20/0x20\n[   86.051955]  sock_sendmsg+0xdd/0x110\n[   86.051955]  __sys_sendto+0x1cc/0x2a0\n[   86.051955]  ? __ia32_sys_getpeername+0xa0/0xa0\n[   86.051955]  ? new_sync_write+0x335/0x550\n[   86.051955]  ? alloc_file+0x22f/0x500\n[   86.051955]  ? __ip_do_redirect+0x820/0x1820\n[   86.051955]  ? vfs_write+0x44d/0x7b0\n[   86.051955]  ? vfs_write+0x44d/0x7b0\n[   86.051955]  ? fput_many+0x15/0x120\n[   86.051955]  ? ksys_write+0x155/0x1b0\n[   86.051955]  ? __ia32_sys_read+0xa0/0xa0\n[   86.051955]  __x64_sys_sendto+0xd8/0x1b0\n[   86.051955]  ? exit_to_user_mode_prepare+0x2f/0x120\n[   86.051955]  ? syscall_exit_to_user_mode+0x12/0x20\n[   86.051955]  do_syscall_64+0x3a/0x80\n[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[   86.051955] RIP: 0033:0x7f82118a56b3\n[   86.051955] RSP: 002b:00007ffdb154b110 EFLAGS: 00000293 ORIG_RAX: 000000000000002c\n[   86.051955] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007f82118a56b3\n[   86.051955] RDX: 0000000000000010 RSI: 00007f8211cd4000 RDI: 0000000000000007\n[   86.051955] RBP: 00007ffdb154c1d0 R08: 00007ffdb154b164 R09: 000000000000000c\n[   86.051955] R10: 0000000000000000 R11: 0000000000000293 R12: 000055d779800db0\n[   86.051955] R13: 00007ffdb154c2b0 R14: 0000000000000000 R15: 0000000000000000\n[   86.051955]  </TASK>\n[   86.051955]\n[   86.051955] Allocated by task 295:\n[   86.051955]  kasan_save_stack+0x1c/0x40\n[   86.051955]  __kasan_kmalloc+0x84/0xa0\n[   86.051955]  mctp_rtm_newaddr+0x242/0x610\n[   86.051955]  rtnetlink_rcv_msg+0x2fd/0x8b0\n[   86.051955]  netlink_rcv_skb+0x11c/0x340\n[   86.051955]  netlink_unicast+0x439/0x630\n[   86.051955]  netlink_sendmsg+0x752/0xc00\n[   86.051955]  sock_sendmsg+0xdd/0x110\n[   86.051955]  __sys_sendto+0x1cc/0x2a0\n[   86.051955]  __x64_sys_sendto+0xd8/0x1b0\n[   86.051955]  do_syscall_64+0x3a/0x80\n[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[   86.051955]\n[   86.051955] Freed by task 301:\n[   86.051955]  kasan_save_stack+0x1c/0x40\n[   86.051955]  kasan_set_track+0x21/0x30\n[   86.051955]  kasan_set_free_info+0x20/0x30\n[   86.051955]  __kasan_slab_free+0x104/0x170\n[   86.051955]  kfree+0x8c/0x290\n[   86.051955]  mctp_dev_notify+0x161/0x2c0\n[   86.051955]  raw_notifier_call_chain+0x8b/0xc0\n[   86.051955]  unregister_netdevice_many+0x299/0x1180\n[   86.051955]  unregister_netdevice_queue+0x210/0x2f0\n[   86.051955]  unregister_netdev+0x13/0x20\n[   86.051955]  mctp_serial_close+0x6d/0xa0\n[   86.051955]  tty_ldisc_kill+0x31/0xa0\n[   86.051955]  tty_ldisc_hangup+0x24f/0x560\n[   86.051955]  __tty_hangup.part.28+0x2ce/0x6b0\n[   86.051955]  tty_release+0x327/0xc70\n[   86.051955]  __fput+0x1df/0x8b0\n[   86.051955]  task_work_run+0xca/0x150\n[   86.051955]  exit_to_user_mode_prepare+0x114/0x120\n[   86.051955]  syscall_exit_to_user_mode+0x12/0x20\n[   86.051955]  do_syscall_64+0x46/0x80\n[   86.051955]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n[   86.051955]\n[   86.051955] The buggy address belongs to the object at ffff888005f298c0\n[   86.051955]  which belongs to the cache kmalloc-8 of size 8\n[   86.051955] The buggy address is located 0 bytes inside of\n[   86.051955]  8-byte region [ffff888005f298c0, ffff888005f298c8)\n[   86.051955]\n[   86.051955] The buggy address belongs to the physical page:\n[   86.051955] flags: 0x100000000000200(slab|node=0|zone=1)\n[   86.051955] raw: 0100000000000200 dead000000000100 dead000000000122 ffff888005c42280\n[   86.051955] raw: 0000000000000000 0000000080660066 00000001ffffffff 0000000000000000\n[   86.051955] page dumped because: kasan: bad access detected\n[   86.051955]\n[   86.051955] Memory state around the buggy address:\n[   86.051955]  ffff888005f29780: 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00\n[   86.051955]  ffff888005f29800: fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc\n[   86.051955] >ffff888005f29880: fc fc fc fb fc fc fc fc fa fc fc fc fc fa fc fc\n[   86.051955]                                            ^\n[   86.051955]  ffff888005f29900: fc fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc\n[   86.051955]  ffff888005f29980: fc 00 fc fc fc fc 00 fc fc fc fc 00 fc fc fc fc\n[   86.051955] ==================================================================\n\nTo this end, just like the commit e04480920d1e (\"Bluetooth: defer\ncleanup of resources in hci_unregister_dev()\")  this patch defers the\ndestructive kfree(mdev->addrs) in mctp_unregister to the mctp_dev_put,\nwhere the refcount of mdev is zero and the entire device is reclaimed.\nThis prevents the use-after-free because the sendmsg thread holds the\nreference of mdev in the mctp_route object.\n\nFixes: 583be982d934 (mctp: Add device handling and netlink interface)\nSigned-off-by: Lin Ma <linma@zju.edu.cn>\nAcked-by: Jeremy Kerr <jk@codeconstruct.com.au>\nLink: https://lore.kernel.org/r/20220422114340.32346-1-linma@zju.edu.cn\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
        "commit_date": "2022-04-26T07:14:47Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/b561275d633bcd8e0e8055ab86f1a13df75a0269",
        "html_url": "https://github.com/torvalds/linux/commit/b561275d633bcd8e0e8055ab86f1a13df75a0269",
        "parents": [
            {
                "commit_id_before": "c3e8d5a40685aed49d736a24f4d2b9e7607771f0",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/c3e8d5a40685aed49d736a24f4d2b9e7607771f0",
                "html_url_before": "https://github.com/torvalds/linux/commit/c3e8d5a40685aed49d736a24f4d2b9e7607771f0"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 11891,
        "cve_id": "CVE-2023-3863",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in nfc_llcp_find_local in net/nfc/llcp_core.c in NFC in the Linux kernel. This flaw allows a local user with special privileges to impact a kernel information leak issue.",
        "cvss": "4.1",
        "publish_date": "July 24, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "HIGH",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "NONE",
        "commit_id": "6709d4b7bc2e079241fdef15d1160581c5261c10",
        "commit_message": "net: nfc: Fix use-after-free caused by nfc_llcp_find_local\n\nThis commit fixes several use-after-free that caused by function\nnfc_llcp_find_local(). For example, one UAF can happen when below buggy\ntime window occurs.\n\n// nfc_genl_llc_get_params   | // nfc_unregister_device\n                             |\ndev = nfc_get_device(idx);   | device_lock(...)\nif (!dev)                    | dev->shutting_down = true;\n    return -ENODEV;          | device_unlock(...);\n                             |\ndevice_lock(...);            |   // nfc_llcp_unregister_device\n                             |   nfc_llcp_find_local()\nnfc_llcp_find_local(...);    |\n                             |   local_cleanup()\nif (!local) {                |\n    rc = -ENODEV;            |     // nfc_llcp_local_put\n    goto exit;               |     kref_put(.., local_release)\n}                            |\n                             |       // local_release\n                             |       list_del(&local->list)\n  // nfc_genl_send_params    |       kfree()\n  local->dev->idx !!!UAF!!!  |\n                             |\n\nand the crash trace for the one of the discussed UAF like:\n\nBUG: KASAN: slab-use-after-free in nfc_genl_llc_get_params+0x72f/0x780  net/nfc/netlink.c:1045\nRead of size 8 at addr ffff888105b0e410 by task 20114\n\nCall Trace:\n <TASK>\n __dump_stack  lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x72/0xa0  lib/dump_stack.c:106\n print_address_description  mm/kasan/report.c:319 [inline]\n print_report+0xcc/0x620  mm/kasan/report.c:430\n kasan_report+0xb2/0xe0  mm/kasan/report.c:536\n nfc_genl_send_params  net/nfc/netlink.c:999 [inline]\n nfc_genl_llc_get_params+0x72f/0x780  net/nfc/netlink.c:1045\n genl_family_rcv_msg_doit.isra.0+0x1ee/0x2e0  net/netlink/genetlink.c:968\n genl_family_rcv_msg  net/netlink/genetlink.c:1048 [inline]\n genl_rcv_msg+0x503/0x7d0  net/netlink/genetlink.c:1065\n netlink_rcv_skb+0x161/0x430  net/netlink/af_netlink.c:2548\n genl_rcv+0x28/0x40  net/netlink/genetlink.c:1076\n netlink_unicast_kernel  net/netlink/af_netlink.c:1339 [inline]\n netlink_unicast+0x644/0x900  net/netlink/af_netlink.c:1365\n netlink_sendmsg+0x934/0xe70  net/netlink/af_netlink.c:1913\n sock_sendmsg_nosec  net/socket.c:724 [inline]\n sock_sendmsg+0x1b6/0x200  net/socket.c:747\n ____sys_sendmsg+0x6e9/0x890  net/socket.c:2501\n ___sys_sendmsg+0x110/0x1b0  net/socket.c:2555\n __sys_sendmsg+0xf7/0x1d0  net/socket.c:2584\n do_syscall_x64  arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3f/0x90  arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\nRIP: 0033:0x7f34640a2389\nRSP: 002b:00007f3463415168 EFLAGS: 00000246 ORIG_RAX: 000000000000002e\nRAX: ffffffffffffffda RBX: 00007f34641c1f80 RCX: 00007f34640a2389\nRDX: 0000000000000000 RSI: 0000000020000240 RDI: 0000000000000006\nRBP: 00007f34640ed493 R08: 0000000000000000 R09: 0000000000000000\nR10: 0000000000000000 R11: 0000000000000246 R12: 0000000000000000\nR13: 00007ffe38449ecf R14: 00007f3463415300 R15: 0000000000022000\n </TASK>\n\nAllocated by task 20116:\n kasan_save_stack+0x22/0x50  mm/kasan/common.c:45\n kasan_set_track+0x25/0x30  mm/kasan/common.c:52\n ____kasan_kmalloc  mm/kasan/common.c:374 [inline]\n __kasan_kmalloc+0x7f/0x90  mm/kasan/common.c:383\n kmalloc  include/linux/slab.h:580 [inline]\n kzalloc  include/linux/slab.h:720 [inline]\n nfc_llcp_register_device+0x49/0xa40  net/nfc/llcp_core.c:1567\n nfc_register_device+0x61/0x260  net/nfc/core.c:1124\n nci_register_device+0x776/0xb20  net/nfc/nci/core.c:1257\n virtual_ncidev_open+0x147/0x230  drivers/nfc/virtual_ncidev.c:148\n misc_open+0x379/0x4a0  drivers/char/misc.c:165\n chrdev_open+0x26c/0x780  fs/char_dev.c:414\n do_dentry_open+0x6c4/0x12a0  fs/open.c:920\n do_open  fs/namei.c:3560 [inline]\n path_openat+0x24fe/0x37e0  fs/namei.c:3715\n do_filp_open+0x1ba/0x410  fs/namei.c:3742\n do_sys_openat2+0x171/0x4c0  fs/open.c:1356\n do_sys_open  fs/open.c:1372 [inline]\n __do_sys_openat  fs/open.c:1388 [inline]\n __se_sys_openat  fs/open.c:1383 [inline]\n __x64_sys_openat+0x143/0x200  fs/open.c:1383\n do_syscall_x64  arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3f/0x90  arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nFreed by task 20115:\n kasan_save_stack+0x22/0x50  mm/kasan/common.c:45\n kasan_set_track+0x25/0x30  mm/kasan/common.c:52\n kasan_save_free_info+0x2e/0x50  mm/kasan/generic.c:521\n ____kasan_slab_free  mm/kasan/common.c:236 [inline]\n ____kasan_slab_free  mm/kasan/common.c:200 [inline]\n __kasan_slab_free+0x10a/0x190  mm/kasan/common.c:244\n kasan_slab_free  include/linux/kasan.h:162 [inline]\n slab_free_hook  mm/slub.c:1781 [inline]\n slab_free_freelist_hook  mm/slub.c:1807 [inline]\n slab_free  mm/slub.c:3787 [inline]\n __kmem_cache_free+0x7a/0x190  mm/slub.c:3800\n local_release  net/nfc/llcp_core.c:174 [inline]\n kref_put  include/linux/kref.h:65 [inline]\n nfc_llcp_local_put  net/nfc/llcp_core.c:182 [inline]\n nfc_llcp_local_put  net/nfc/llcp_core.c:177 [inline]\n nfc_llcp_unregister_device+0x206/0x290  net/nfc/llcp_core.c:1620\n nfc_unregister_device+0x160/0x1d0  net/nfc/core.c:1179\n virtual_ncidev_close+0x52/0xa0  drivers/nfc/virtual_ncidev.c:163\n __fput+0x252/0xa20  fs/file_table.c:321\n task_work_run+0x174/0x270  kernel/task_work.c:179\n resume_user_mode_work  include/linux/resume_user_mode.h:49 [inline]\n exit_to_user_mode_loop  kernel/entry/common.c:171 [inline]\n exit_to_user_mode_prepare+0x108/0x110  kernel/entry/common.c:204\n __syscall_exit_to_user_mode_work  kernel/entry/common.c:286 [inline]\n syscall_exit_to_user_mode+0x21/0x50  kernel/entry/common.c:297\n do_syscall_64+0x4c/0x90  arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nLast potentially related work creation:\n kasan_save_stack+0x22/0x50  mm/kasan/common.c:45\n __kasan_record_aux_stack+0x95/0xb0  mm/kasan/generic.c:491\n kvfree_call_rcu+0x29/0xa80  kernel/rcu/tree.c:3328\n drop_sysctl_table+0x3be/0x4e0  fs/proc/proc_sysctl.c:1735\n unregister_sysctl_table.part.0+0x9c/0x190  fs/proc/proc_sysctl.c:1773\n unregister_sysctl_table+0x24/0x30  fs/proc/proc_sysctl.c:1753\n neigh_sysctl_unregister+0x5f/0x80  net/core/neighbour.c:3895\n addrconf_notify+0x140/0x17b0  net/ipv6/addrconf.c:3684\n notifier_call_chain+0xbe/0x210  kernel/notifier.c:87\n call_netdevice_notifiers_info+0xb5/0x150  net/core/dev.c:1937\n call_netdevice_notifiers_extack  net/core/dev.c:1975 [inline]\n call_netdevice_notifiers  net/core/dev.c:1989 [inline]\n dev_change_name+0x3c3/0x870  net/core/dev.c:1211\n dev_ifsioc+0x800/0xf70  net/core/dev_ioctl.c:376\n dev_ioctl+0x3d9/0xf80  net/core/dev_ioctl.c:542\n sock_do_ioctl+0x160/0x260  net/socket.c:1213\n sock_ioctl+0x3f9/0x670  net/socket.c:1316\n vfs_ioctl  fs/ioctl.c:51 [inline]\n __do_sys_ioctl  fs/ioctl.c:870 [inline]\n __se_sys_ioctl  fs/ioctl.c:856 [inline]\n __x64_sys_ioctl+0x19e/0x210  fs/ioctl.c:856\n do_syscall_x64  arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3f/0x90  arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nThe buggy address belongs to the object at ffff888105b0e400\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 16 bytes inside of\n freed 1024-byte region [ffff888105b0e400, ffff888105b0e800)\n\nThe buggy address belongs to the physical page:\nhead:ffffea000416c200 order:3 entire_mapcount:0 nr_pages_mapped:0 pincount:0\nflags: 0x200000000010200(slab|head|node=0|zone=2)\nraw: 0200000000010200 ffff8881000430c0 ffffea00044c7010 ffffea0004510e10\nraw: 0000000000000000 00000000000a000a 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff888105b0e300: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n ffff888105b0e380: fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc fc\n>ffff888105b0e400: fa fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                         ^\n ffff888105b0e480: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888105b0e500: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n\nIn summary, this patch solves those use-after-free by\n\n1. Re-implement the nfc_llcp_find_local(). The current version does not\ngrab the reference when getting the local from the linked list.  For\nexample, the llcp_sock_bind() gets the reference like below:\n\n// llcp_sock_bind()\n\n    local = nfc_llcp_find_local(dev); // A\n    ..... \\\n           | raceable\n    ..... /\n    llcp_sock->local = nfc_llcp_local_get(local); // B\n\nThere is an apparent race window that one can  drop the reference\nand free the local object fetched in (A) before (B) gets the reference.\n\n2. Some callers of the nfc_llcp_find_local() do not grab the reference\nat all. For example, the nfc_genl_llc_{{get/set}_params/sdreq} functions.\nWe add the nfc_llcp_local_put() for them. Moreover, we add the necessary\nerror handling function to put the reference.\n\n3. Add the nfc_llcp_remove_local() helper. The local object is removed\nfrom the linked list in local_release() when all reference is gone. This\npatch removes it when nfc_llcp_unregister_device() is called.\n\nTherefore, every caller of nfc_llcp_find_local() will get a reference\neven when the nfc_llcp_unregister_device() is called. This promises no\nuse-after-free for the local object is ever possible.\n\nFixes: 52feb444a903 (\"NFC: Extend netlink interface for LTO, RW, and MIUX parameters support\")\nFixes: c7aa12252f51 (\"NFC: Take a reference on the LLCP local pointer when creating a socket\")\nSigned-off-by: Lin Ma <linma@zju.edu.cn>\nReviewed-by: Simon Horman <simon.horman@corigine.com>\nSigned-off-by: David S. Miller <davem@davemloft.net>",
        "commit_date": "2023-06-26T09:57:23Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/6709d4b7bc2e079241fdef15d1160581c5261c10",
        "html_url": "https://github.com/torvalds/linux/commit/6709d4b7bc2e079241fdef15d1160581c5261c10",
        "parents": [
            {
                "commit_id_before": "d1b355438b8325a486f087e506d412c4e852f37b",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/d1b355438b8325a486f087e506d412c4e852f37b",
                "html_url_before": "https://github.com/torvalds/linux/commit/d1b355438b8325a486f087e506d412c4e852f37b"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 12149,
        "cve_id": "CVE-2023-40283",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "An issue was discovered in l2cap_sock_release in net/bluetooth/l2cap_sock.c in the Linux kernel before 6.4.10. There is a use-after-free because the children of an sk are mishandled.",
        "cvss": "7.8",
        "publish_date": "August 13, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "HIGH",
        "A": "HIGH",
        "commit_id": "1728137b33c00d5a2b5110ed7aafb42e7c32e4a1",
        "commit_message": "Bluetooth: L2CAP: Fix use-after-free in l2cap_sock_ready_cb\n\nl2cap_sock_release(sk) frees sk. However, sk's children are still alive\nand point to the already free'd sk's address.\nTo fix this, l2cap_sock_release(sk) also cleans sk's children.\n\n==================================================================\nBUG: KASAN: use-after-free in l2cap_sock_ready_cb+0xb7/0x100 net/bluetooth/l2cap_sock.c:1650\nRead of size 8 at addr ffff888104617aa8 by task kworker/u3:0/276\n\nCPU: 0 PID: 276 Comm: kworker/u3:0 Not tainted 6.2.0-00001-gef397bd4d5fb-dirty #59\nHardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.15.0-1 04/01/2014\nWorkqueue: hci2 hci_rx_work\nCall Trace:\n <TASK>\n __dump_stack lib/dump_stack.c:88 [inline]\n dump_stack_lvl+0x72/0x95 lib/dump_stack.c:106\n print_address_description mm/kasan/report.c:306 [inline]\n print_report+0x175/0x478 mm/kasan/report.c:417\n kasan_report+0xb1/0x130 mm/kasan/report.c:517\n l2cap_sock_ready_cb+0xb7/0x100 net/bluetooth/l2cap_sock.c:1650\n l2cap_chan_ready+0x10e/0x1e0 net/bluetooth/l2cap_core.c:1386\n l2cap_config_req+0x753/0x9f0 net/bluetooth/l2cap_core.c:4480\n l2cap_bredr_sig_cmd net/bluetooth/l2cap_core.c:5739 [inline]\n l2cap_sig_channel net/bluetooth/l2cap_core.c:6509 [inline]\n l2cap_recv_frame+0xe2e/0x43c0 net/bluetooth/l2cap_core.c:7788\n l2cap_recv_acldata+0x6ed/0x7e0 net/bluetooth/l2cap_core.c:8506\n hci_acldata_packet net/bluetooth/hci_core.c:3813 [inline]\n hci_rx_work+0x66e/0xbc0 net/bluetooth/hci_core.c:4048\n process_one_work+0x4ea/0x8e0 kernel/workqueue.c:2289\n worker_thread+0x364/0x8e0 kernel/workqueue.c:2436\n kthread+0x1b9/0x200 kernel/kthread.c:376\n ret_from_fork+0x2c/0x50 arch/x86/entry/entry_64.S:308\n </TASK>\n\nAllocated by task 288:\n kasan_save_stack+0x22/0x50 mm/kasan/common.c:45\n kasan_set_track+0x25/0x30 mm/kasan/common.c:52\n ____kasan_kmalloc mm/kasan/common.c:374 [inline]\n __kasan_kmalloc+0x82/0x90 mm/kasan/common.c:383\n kasan_kmalloc include/linux/kasan.h:211 [inline]\n __do_kmalloc_node mm/slab_common.c:968 [inline]\n __kmalloc+0x5a/0x140 mm/slab_common.c:981\n kmalloc include/linux/slab.h:584 [inline]\n sk_prot_alloc+0x113/0x1f0 net/core/sock.c:2040\n sk_alloc+0x36/0x3c0 net/core/sock.c:2093\n l2cap_sock_alloc.constprop.0+0x39/0x1c0 net/bluetooth/l2cap_sock.c:1852\n l2cap_sock_create+0x10d/0x220 net/bluetooth/l2cap_sock.c:1898\n bt_sock_create+0x183/0x290 net/bluetooth/af_bluetooth.c:132\n __sock_create+0x226/0x380 net/socket.c:1518\n sock_create net/socket.c:1569 [inline]\n __sys_socket_create net/socket.c:1606 [inline]\n __sys_socket_create net/socket.c:1591 [inline]\n __sys_socket+0x112/0x200 net/socket.c:1639\n __do_sys_socket net/socket.c:1652 [inline]\n __se_sys_socket net/socket.c:1650 [inline]\n __x64_sys_socket+0x40/0x50 net/socket.c:1650\n do_syscall_x64 arch/x86/entry/common.c:50 [inline]\n do_syscall_64+0x3f/0x90 arch/x86/entry/common.c:80\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nFreed by task 288:\n kasan_save_stack+0x22/0x50 mm/kasan/common.c:45\n kasan_set_track+0x25/0x30 mm/kasan/common.c:52\n kasan_save_free_info+0x2e/0x50 mm/kasan/generic.c:523\n ____kasan_slab_free mm/kasan/common.c:236 [inline]\n ____kasan_slab_free mm/kasan/common.c:200 [inline]\n __kasan_slab_free+0x10a/0x190 mm/kasan/common.c:244\n kasan_slab_free include/linux/kasan.h:177 [inline]\n slab_free_hook mm/slub.c:1781 [inline]\n slab_free_freelist_hook mm/slub.c:1807 [inline]\n slab_free mm/slub.c:3787 [inline]\n __kmem_cache_free+0x88/0x1f0 mm/slub.c:3800\n sk_prot_free net/core/sock.c:2076 [inline]\n __sk_destruct+0x347/0x430 net/core/sock.c:2168\n sk_destruct+0x9c/0xb0 net/core/sock.c:2183\n __sk_free+0x82/0x220 net/core/sock.c:2194\n sk_free+0x7c/0xa0 net/core/sock.c:2205\n sock_put include/net/sock.h:1991 [inline]\n l2cap_sock_kill+0x256/0x2b0 net/bluetooth/l2cap_sock.c:1257\n l2cap_sock_release+0x1a7/0x220 net/bluetooth/l2cap_sock.c:1428\n __sock_release+0x80/0x150 net/socket.c:650\n sock_close+0x19/0x30 net/socket.c:1368\n __fput+0x17a/0x5c0 fs/file_table.c:320\n task_work_run+0x132/0x1c0 kernel/task_work.c:179\n resume_user_mode_work include/linux/resume_user_mode.h:49 [inline]\n exit_to_user_mode_loop kernel/entry/common.c:171 [inline]\n exit_to_user_mode_prepare+0x113/0x120 kernel/entry/common.c:203\n __syscall_exit_to_user_mode_work kernel/entry/common.c:285 [inline]\n syscall_exit_to_user_mode+0x21/0x50 kernel/entry/common.c:296\n do_syscall_64+0x4c/0x90 arch/x86/entry/common.c:86\n entry_SYSCALL_64_after_hwframe+0x72/0xdc\n\nThe buggy address belongs to the object at ffff888104617800\n which belongs to the cache kmalloc-1k of size 1024\nThe buggy address is located 680 bytes inside of\n 1024-byte region [ffff888104617800, ffff888104617c00)\n\nThe buggy address belongs to the physical page:\npage:00000000dbca6a80 refcount:1 mapcount:0 mapping:0000000000000000 index:0xffff888104614000 pfn:0x104614\nhead:00000000dbca6a80 order:2 compound_mapcount:0 subpages_mapcount:0 compound_pincount:0\nflags: 0x200000000010200(slab|head|node=0|zone=2)\nraw: 0200000000010200 ffff888100041dc0 ffffea0004212c10 ffffea0004234b10\nraw: ffff888104614000 0000000000080002 00000001ffffffff 0000000000000000\npage dumped because: kasan: bad access detected\n\nMemory state around the buggy address:\n ffff888104617980: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888104617a00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n>ffff888104617a80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n                                  ^\n ffff888104617b00: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n ffff888104617b80: fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb fb\n==================================================================\n\nAck: This bug is found by FuzzBT with a modified Syzkaller. Other\ncontributors are Ruoyu Wu and Hui Peng.\nSigned-off-by: Sungwoo Kim <iam@sung-woo.kim>\nSigned-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>\nSigned-off-by: Jakub Kicinski <kuba@kernel.org>",
        "commit_date": "2023-06-29T17:48:35Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/1728137b33c00d5a2b5110ed7aafb42e7c32e4a1",
        "html_url": "https://github.com/torvalds/linux/commit/1728137b33c00d5a2b5110ed7aafb42e7c32e4a1",
        "parents": [
            {
                "commit_id_before": "6945795bc81ab7be22750ecfb365056688f2fada",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/6945795bc81ab7be22750ecfb365056688f2fada",
                "html_url_before": "https://github.com/torvalds/linux/commit/6945795bc81ab7be22750ecfb365056688f2fada"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    },
    {
        "index": 12133,
        "cve_id": "CVE-2023-4387",
        "cwe_id": [
            "CWE-416"
        ],
        "cve_language": "C",
        "cve_description": "A use-after-free flaw was found in vmxnet3_rq_alloc_rx_buf in drivers/net/vmxnet3/vmxnet3_drv.c in VMware's vmxnet3 ethernet NIC driver in the Linux Kernel. This issue could allow a local attacker to crash the system due to a double-free while cleaning up vmxnet3_rq_cleanup_all, which could also lead to a kernel information leak problem.",
        "cvss": "7.1",
        "publish_date": "August 16, 2023",
        "AV": "LOCAL",
        "AC": "LOCAL",
        "PR": "LOW",
        "UI": "NONE",
        "S": "UNCHANGED",
        "C": "HIGH",
        "I": "NONE",
        "A": "HIGH",
        "commit_id": "9e7fef9521e73ca8afd7da9e58c14654b02dfad8",
        "commit_message": "net: vmxnet3: fix possible use-after-free bugs in vmxnet3_rq_alloc_rx_buf()\n\nIn vmxnet3_rq_alloc_rx_buf(), when dma_map_single() fails, rbi->skb is\nfreed immediately. Similarly, in another branch, when dma_map_page() fails,\nrbi->page is also freed. In the two cases, vmxnet3_rq_alloc_rx_buf()\nreturns an error to its callers vmxnet3_rq_init() -> vmxnet3_rq_init_all()\n-> vmxnet3_activate_dev(). Then vmxnet3_activate_dev() calls\nvmxnet3_rq_cleanup_all() in error handling code, and rbi->skb or rbi->page\nare freed again in vmxnet3_rq_cleanup_all(), causing use-after-free bugs.\n\nTo fix these possible bugs, rbi->skb and rbi->page should be cleared after\nthey are freed.\n\nThe error log in our fault-injection testing is shown as follows:\n\n[   14.319016] BUG: KASAN: use-after-free in consume_skb+0x2f/0x150\n...\n[   14.321586] Call Trace:\n...\n[   14.325357]  consume_skb+0x2f/0x150\n[   14.325671]  vmxnet3_rq_cleanup_all+0x33a/0x4e0 [vmxnet3]\n[   14.326150]  vmxnet3_activate_dev+0xb9d/0x2ca0 [vmxnet3]\n[   14.326616]  vmxnet3_open+0x387/0x470 [vmxnet3]\n...\n[   14.361675] Allocated by task 351:\n...\n[   14.362688]  __netdev_alloc_skb+0x1b3/0x6f0\n[   14.362960]  vmxnet3_rq_alloc_rx_buf+0x1b0/0x8d0 [vmxnet3]\n[   14.363317]  vmxnet3_activate_dev+0x3e3/0x2ca0 [vmxnet3]\n[   14.363661]  vmxnet3_open+0x387/0x470 [vmxnet3]\n...\n[   14.367309]\n[   14.367412] Freed by task 351:\n...\n[   14.368932]  __dev_kfree_skb_any+0xd2/0xe0\n[   14.369193]  vmxnet3_rq_alloc_rx_buf+0x71e/0x8d0 [vmxnet3]\n[   14.369544]  vmxnet3_activate_dev+0x3e3/0x2ca0 [vmxnet3]\n[   14.369883]  vmxnet3_open+0x387/0x470 [vmxnet3]\n[   14.370174]  __dev_open+0x28a/0x420\n[   14.370399]  __dev_change_flags+0x192/0x590\n[   14.370667]  dev_change_flags+0x7a/0x180\n[   14.370919]  do_setlink+0xb28/0x3570\n[   14.371150]  rtnl_newlink+0x1160/0x1740\n[   14.371399]  rtnetlink_rcv_msg+0x5bf/0xa50\n[   14.371661]  netlink_rcv_skb+0x1cd/0x3e0\n[   14.371913]  netlink_unicast+0x5dc/0x840\n[   14.372169]  netlink_sendmsg+0x856/0xc40\n[   14.372420]  ____sys_sendmsg+0x8a7/0x8d0\n[   14.372673]  __sys_sendmsg+0x1c2/0x270\n[   14.372914]  do_syscall_64+0x41/0x90\n[   14.373145]  entry_SYSCALL_64_after_hwframe+0x44/0xae\n...\n\nFixes: 5738a09d58d5a (\"vmxnet3: fix checks for dma mapping errors\")\nReported-by: TOTE Robot <oslab@tsinghua.edu.cn>\nSigned-off-by: Zixuan Fu <r33s3n6@gmail.com>\nLink: https://lore.kernel.org/r/20220514050656.2636588-1-r33s3n6@gmail.com\nSigned-off-by: Paolo Abeni <pabeni@redhat.com>",
        "commit_date": "2022-05-17T10:02:27Z",
        "project": "torvalds/linux",
        "url": "https://api.github.com/repos/torvalds/linux/commits/9e7fef9521e73ca8afd7da9e58c14654b02dfad8",
        "html_url": "https://github.com/torvalds/linux/commit/9e7fef9521e73ca8afd7da9e58c14654b02dfad8",
        "parents": [
            {
                "commit_id_before": "4d33ab08c0af140752a46f227a6bf97dab1e17b4",
                "url_before": "https://api.github.com/repos/torvalds/linux/commits/4d33ab08c0af140752a46f227a6bf97dab1e17b4",
                "html_url_before": "https://github.com/torvalds/linux/commit/4d33ab08c0af140752a46f227a6bf97dab1e17b4"
            }
        ],
        "outdated": 0,
        "cwe_descripiton": "",
        "cwe_consequence": "",
        "cwe_method": "",
        "cwe_solution": "",
        "localization": ""
    }
]